From a14028b366eaa969ebb13295d129e73236a653ee Mon Sep 17 00:00:00 2001
From: Sathesh Edara <sedara@marvell.com>
Date: Mon, 2 Jan 2023 03:00:20 -0800
Subject: [PATCH 132/955] net/octeon_ep: dpdk error handling

This commit ports DPDK error handling for otx2 EP
PMD from DPDK 19.11 to 21.11. Also ported code
that optimizes OcteonTX2 queue depth checking by
using ISM messages to write the queue depths to
host memory rather than reading the device
registers directly.

Signed-off-by: Sathesh Edara <sedara@marvell.com>
Change-Id: I8f3296d38981f1c4899653477e4b6da6c042cc67
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/93496
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Reviewed-by: Veerasenareddy Burru <vburru@marvell.com>
---
 drivers/net/octeon_ep/cnxk_ep_vf.c    |  39 +++-
 drivers/net/octeon_ep/otx2_ep_vf.c    | 312 ++++++++++++++++++++++----
 drivers/net/octeon_ep/otx2_ep_vf.h    | 148 ++++--------
 drivers/net/octeon_ep/otx_ep_common.h |  26 ++-
 drivers/net/octeon_ep/otx_ep_ethdev.c |  63 +++++-
 drivers/net/octeon_ep/otx_ep_rxtx.c   |  74 ++++--
 drivers/net/octeon_ep/otx_ep_vf.c     |  76 +++++--
 drivers/net/octeon_ep/otx_ep_vf.h     |   4 +
 lib/ethdev/rte_ethdev.h               |   4 +
 9 files changed, 540 insertions(+), 206 deletions(-)

diff --git a/drivers/net/octeon_ep/cnxk_ep_vf.c b/drivers/net/octeon_ep/cnxk_ep_vf.c
index 3427fb213b168..35b96471278c4 100644
--- a/drivers/net/octeon_ep/cnxk_ep_vf.c
+++ b/drivers/net/octeon_ep/cnxk_ep_vf.c
@@ -47,32 +47,43 @@ cnxk_ep_vf_setup_global_oq_reg(struct otx_ep_device *otx_ep, int q_no)
 	oct_ep_write64(reg_val, otx_ep->hw_addr + CNXK_EP_R_OUT_CONTROL(q_no));
 }
 
-static void
+static int
 cnxk_ep_vf_setup_global_input_regs(struct otx_ep_device *otx_ep)
 {
 	uint64_t q_no = 0ull;
+	int ret = 0;
 
 	for (q_no = 0; q_no < (otx_ep->sriov_info.rings_per_vf); q_no++)
 		cnxk_ep_vf_setup_global_iq_reg(otx_ep, q_no);
+
+	return ret;
 }
 
-static void
+static int
 cnxk_ep_vf_setup_global_output_regs(struct otx_ep_device *otx_ep)
 {
 	uint32_t q_no;
+	int ret = 0;
 
 	for (q_no = 0; q_no < (otx_ep->sriov_info.rings_per_vf); q_no++)
 		cnxk_ep_vf_setup_global_oq_reg(otx_ep, q_no);
+
+	return ret;
 }
 
-static void
+static int
 cnxk_ep_vf_setup_device_regs(struct otx_ep_device *otx_ep)
 {
-	cnxk_ep_vf_setup_global_input_regs(otx_ep);
-	cnxk_ep_vf_setup_global_output_regs(otx_ep);
+	int ret;
+	ret = cnxk_ep_vf_setup_global_input_regs(otx_ep);
+	if (ret)
+		return ret;
+	ret = cnxk_ep_vf_setup_global_output_regs(otx_ep);
+
+	return ret;
 }
 
-static void
+static int
 cnxk_ep_vf_setup_iq_regs(struct otx_ep_device *otx_ep, uint32_t iq_no)
 {
 	struct otx_ep_instr_queue *iq = otx_ep->instr_queue[iq_no];
@@ -93,7 +104,7 @@ cnxk_ep_vf_setup_iq_regs(struct otx_ep_device *otx_ep, uint32_t iq_no)
 
 	if (!loop) {
 		otx_ep_err("IDLE bit is not set\n");
-		return;
+		return -EIO;
 	}
 
 	/* Write the start of the input queue's ring and its size  */
@@ -117,7 +128,7 @@ cnxk_ep_vf_setup_iq_regs(struct otx_ep_device *otx_ep, uint32_t iq_no)
 
 	if (!loop) {
 		otx_ep_err("INST CNT REGISTER is not zero\n");
-		return;
+		return -EIO;
 	}
 
 	/* IN INTR_THRESHOLD is set to max(FFFFFFFF) which disable the IN INTR
@@ -125,9 +136,11 @@ cnxk_ep_vf_setup_iq_regs(struct otx_ep_device *otx_ep, uint32_t iq_no)
 	 */
 	oct_ep_write64(OTX_EP_CLEAR_SDP_IN_INT_LVLS,
 		       otx_ep->hw_addr + CNXK_EP_R_IN_INT_LEVELS(iq_no));
+
+	return 0;
 }
 
-static void
+static int
 cnxk_ep_vf_setup_oq_regs(struct otx_ep_device *otx_ep, uint32_t oq_no)
 {
 	volatile uint64_t reg_val = 0ull;
@@ -147,7 +160,7 @@ cnxk_ep_vf_setup_oq_regs(struct otx_ep_device *otx_ep, uint32_t oq_no)
 
 	if (!loop) {
 		otx_ep_err("OUT CNT REGISTER value is zero\n");
-		return;
+		return -EIO;
 	}
 
 	oct_ep_write64(droq->desc_ring_dma, otx_ep->hw_addr + CNXK_EP_R_OUT_SLIST_BADDR(oq_no));
@@ -183,7 +196,7 @@ cnxk_ep_vf_setup_oq_regs(struct otx_ep_device *otx_ep, uint32_t oq_no)
 
 	if (!loop) {
 		otx_ep_err("Packets credit register value is not cleared\n");
-		return;
+		return -EIO;
 	}
 
 	otx_ep_dbg("SDP_R[%d]_credit:%x", oq_no, rte_read32(droq->pkts_credit_reg));
@@ -203,10 +216,12 @@ cnxk_ep_vf_setup_oq_regs(struct otx_ep_device *otx_ep, uint32_t oq_no)
 
 	if (!loop) {
 		otx_ep_err("Packets sent register value is not cleared\n");
-		return;
+		return -EIO;
 	}
 
 	otx_ep_dbg("SDP_R[%d]_sent: %x", oq_no, rte_read32(droq->pkts_sent_reg));
+
+	return 0;
 }
 
 static int
diff --git a/drivers/net/octeon_ep/otx2_ep_vf.c b/drivers/net/octeon_ep/otx2_ep_vf.c
index 3c9a70157e3f8..351530e2f01a3 100644
--- a/drivers/net/octeon_ep/otx2_ep_vf.c
+++ b/drivers/net/octeon_ep/otx2_ep_vf.c
@@ -7,8 +7,120 @@
 #include <rte_common.h>
 #include <rte_cycles.h>
 #include "otx_ep_common.h"
+#include "common/cnxk/roc_api.h"
 #include "otx2_ep_vf.h"
 
+static int otx2_vf_enable_rxq_intr(struct otx_ep_device *otx_epvf,
+				   uint16_t q_no);
+
+static int
+otx2_vf_reset_iq(struct otx_ep_device *otx_ep, int q_no)
+{
+	int loop = SDP_VF_BUSY_LOOP_COUNT;
+	volatile uint64_t d64 = 0ull;
+
+	/* There is no RST for a ring.
+	 * Clear all registers one by one after disabling the ring
+	 */
+
+	otx2_write64(d64, otx_ep->hw_addr + SDP_VF_R_IN_ENABLE(q_no));
+	otx2_write64(d64, otx_ep->hw_addr + SDP_VF_R_IN_INSTR_BADDR(q_no));
+	otx2_write64(d64, otx_ep->hw_addr + SDP_VF_R_IN_INSTR_RSIZE(q_no));
+
+	d64 = 0xFFFFFFFF; /* ~0ull */
+	otx2_write64(d64, otx_ep->hw_addr + SDP_VF_R_IN_INSTR_DBELL(q_no));
+	d64 = otx2_read64(otx_ep->hw_addr + SDP_VF_R_IN_INSTR_DBELL(q_no));
+
+	while ((d64 != 0) && loop--) {
+		rte_delay_ms(1);
+		d64 = otx2_read64(otx_ep->hw_addr +
+				  SDP_VF_R_IN_INSTR_DBELL(q_no));
+	}
+	if (loop < 0) {
+		otx_ep_err("%s: doorbell init retry limit exceeded.\n", __func__);
+		return -EIO;
+	}
+
+	loop = SDP_VF_BUSY_LOOP_COUNT;
+	do {
+		d64 = otx2_read64(otx_ep->hw_addr + SDP_VF_R_IN_CNTS(q_no));
+		otx2_write64(d64, otx_ep->hw_addr + SDP_VF_R_IN_CNTS(q_no));
+		rte_delay_ms(1);
+	} while ((d64 & ~SDP_VF_R_IN_CNTS_OUT_INT) != 0 && loop--);
+	if (loop < 0) {
+		otx_ep_err("%s: in_cnts init retry limit exceeded.\n", __func__);
+		return -EIO;
+	}
+
+	d64 = 0ull;
+	otx2_write64(d64, otx_ep->hw_addr + SDP_VF_R_IN_INT_LEVELS(q_no));
+	otx2_write64(d64, otx_ep->hw_addr + SDP_VF_R_IN_PKT_CNT(q_no));
+	otx2_write64(d64, otx_ep->hw_addr + SDP_VF_R_IN_BYTE_CNT(q_no));
+
+	return 0;
+}
+
+static int
+otx2_vf_reset_oq(struct otx_ep_device *otx_ep, int q_no)
+{
+	int loop = SDP_VF_BUSY_LOOP_COUNT;
+	volatile uint64_t d64 = 0ull;
+
+	otx2_write64(d64, otx_ep->hw_addr + SDP_VF_R_OUT_ENABLE(q_no));
+
+	otx2_write64(d64, otx_ep->hw_addr + SDP_VF_R_OUT_SLIST_BADDR(q_no));
+
+	otx2_write64(d64, otx_ep->hw_addr + SDP_VF_R_OUT_SLIST_RSIZE(q_no));
+
+	d64 = 0xFFFFFFFF;
+	otx2_write64(d64, otx_ep->hw_addr + SDP_VF_R_OUT_SLIST_DBELL(q_no));
+	d64 = otx2_read64(otx_ep->hw_addr + SDP_VF_R_OUT_SLIST_DBELL(q_no));
+	while ((d64 != 0) && loop--) {
+		rte_delay_ms(1);
+		d64 = otx2_read64(otx_ep->hw_addr +
+				  SDP_VF_R_OUT_SLIST_DBELL(q_no));
+	}
+	if (loop < 0) {
+		otx_ep_err("%s: doorbell init retry limit exceeded.\n", __func__);
+		return -EIO;
+	}
+
+	if (otx2_read64(otx_ep->hw_addr + SDP_VF_R_OUT_CNTS(q_no))
+	    & SDP_VF_R_OUT_CNTS_OUT_INT) {
+		/*
+		 * The OUT_INT bit is set.  This interrupt must be enabled in
+		 * order to clear the interrupt.  Interrupts are disabled
+		 * at the end of this function.
+		 */
+		union out_int_lvl_t out_int_lvl;
+
+		out_int_lvl.d64 = otx2_read64(otx_ep->hw_addr +
+					SDP_VF_R_OUT_INT_LEVELS(q_no));
+		out_int_lvl.s.time_cnt_en = 1;
+		out_int_lvl.s.cnt = 0;
+		otx2_write64(out_int_lvl.d64, otx_ep->hw_addr +
+				SDP_VF_R_OUT_INT_LEVELS(q_no));
+	}
+
+	loop = SDP_VF_BUSY_LOOP_COUNT;
+	do {
+		d64 = otx2_read64(otx_ep->hw_addr + SDP_VF_R_OUT_CNTS(q_no));
+		otx2_write64(d64, otx_ep->hw_addr + SDP_VF_R_OUT_CNTS(q_no));
+		rte_delay_ms(1);
+	} while ((d64 & ~SDP_VF_R_OUT_CNTS_IN_INT) != 0 && loop--);
+	if (loop < 0) {
+		otx_ep_err("%s: out_cnts init retry limit exceeded.\n", __func__);
+		return -EIO;
+	}
+
+	d64 = 0ull;
+	otx2_write64(d64, otx_ep->hw_addr + SDP_VF_R_OUT_INT_LEVELS(q_no));
+	otx2_write64(d64, otx_ep->hw_addr + SDP_VF_R_OUT_PKT_CNT(q_no));
+	otx2_write64(d64, otx_ep->hw_addr + SDP_VF_R_OUT_BYTE_CNT(q_no));
+
+	return 0;
+}
+
 static void
 otx2_vf_setup_global_iq_reg(struct otx_ep_device *otx_ep, int q_no)
 {
@@ -49,36 +161,86 @@ otx2_vf_setup_global_oq_reg(struct otx_ep_device *otx_ep, int q_no)
 	oct_ep_write64(reg_val, otx_ep->hw_addr + SDP_VF_R_OUT_CONTROL(q_no));
 }
 
-static void
+static int
+otx2_vf_reset_input_queues(struct otx_ep_device *otx_ep)
+{
+	uint32_t q_no = 0;
+	int ret = 0;
+
+	for (q_no = 0; q_no < otx_ep->sriov_info.rings_per_vf; q_no++) {
+		ret = otx2_vf_reset_iq(otx_ep, q_no);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+static int
+otx2_vf_reset_output_queues(struct otx_ep_device *otx_ep)
+{
+	uint64_t q_no = 0ull;
+	int ret = 0;
+
+	for (q_no = 0; q_no < otx_ep->sriov_info.rings_per_vf; q_no++) {
+		ret = otx2_vf_reset_oq(otx_ep, q_no);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+static int
 otx2_vf_setup_global_input_regs(struct otx_ep_device *otx_ep)
 {
 	uint64_t q_no = 0ull;
+	int ret = 0;
 
+	ret = otx2_vf_reset_input_queues(otx_ep);
+	if (ret)
+		return ret;
 	for (q_no = 0; q_no < (otx_ep->sriov_info.rings_per_vf); q_no++)
 		otx2_vf_setup_global_iq_reg(otx_ep, q_no);
+
+	return ret;
 }
 
-static void
+static int
 otx2_vf_setup_global_output_regs(struct otx_ep_device *otx_ep)
 {
 	uint32_t q_no;
+	int ret;
+
+	ret = otx2_vf_reset_output_queues(otx_ep);
+	if (ret)
+		return ret;
 
 	for (q_no = 0; q_no < (otx_ep->sriov_info.rings_per_vf); q_no++)
 		otx2_vf_setup_global_oq_reg(otx_ep, q_no);
+
+	return ret;
 }
 
-static void
+static int
 otx2_vf_setup_device_regs(struct otx_ep_device *otx_ep)
 {
-	otx2_vf_setup_global_input_regs(otx_ep);
-	otx2_vf_setup_global_output_regs(otx_ep);
+	int ret;
+
+	ret = otx2_vf_setup_global_input_regs(otx_ep);
+	if (ret)
+		return ret;
+	ret = otx2_vf_setup_global_output_regs(otx_ep);
+
+	return ret;
 }
 
-static void
+static int
 otx2_vf_setup_iq_regs(struct otx_ep_device *otx_ep, uint32_t iq_no)
 {
 	struct otx_ep_instr_queue *iq = otx_ep->instr_queue[iq_no];
 	volatile uint64_t reg_val = 0ull;
+	uint64_t ism_addr;
 	int loop = SDP_VF_BUSY_LOOP_COUNT;
 
 	reg_val = oct_ep_read64(otx_ep->hw_addr + SDP_VF_R_IN_CONTROL(iq_no));
@@ -90,16 +252,15 @@ otx2_vf_setup_iq_regs(struct otx_ep_device *otx_ep, uint32_t iq_no)
 		do {
 			reg_val = oct_ep_read64(otx_ep->hw_addr + SDP_VF_R_IN_CONTROL(iq_no));
 		} while ((!(reg_val & SDP_VF_R_IN_CTL_IDLE)) && loop--);
-	}
-
-	if (!loop) {
-		otx_ep_err("IDLE bit is not set\n");
-		return;
+		if (loop < 0)
+			return -EIO;
 	}
 
 	/* Write the start of the input queue's ring and its size  */
-	oct_ep_write64(iq->base_addr_dma, otx_ep->hw_addr + SDP_VF_R_IN_INSTR_BADDR(iq_no));
-	oct_ep_write64(iq->nb_desc, otx_ep->hw_addr + SDP_VF_R_IN_INSTR_RSIZE(iq_no));
+	oct_ep_write64(iq->base_addr_dma, otx_ep->hw_addr +
+		       SDP_VF_R_IN_INSTR_BADDR(iq_no));
+	oct_ep_write64(iq->nb_desc, otx_ep->hw_addr +
+		       SDP_VF_R_IN_INSTR_RSIZE(iq_no));
 
 	/* Remember the doorbell & instruction count register addr
 	 * for this queue
@@ -115,25 +276,41 @@ otx2_vf_setup_iq_regs(struct otx_ep_device *otx_ep, uint32_t iq_no)
 		rte_write32(reg_val, iq->inst_cnt_reg);
 	} while (reg_val != 0 && loop--);
 
-	if (!loop) {
-		otx_ep_err("INST CNT REGISTER is not zero\n");
-		return;
-	}
+	if (loop < 0)
+		return -EIO;
 
 	/* IN INTR_THRESHOLD is set to max(FFFFFFFF) which disable the IN INTR
 	 * to raise
 	 */
 	oct_ep_write64(OTX_EP_CLEAR_SDP_IN_INT_LVLS,
 		       otx_ep->hw_addr + SDP_VF_R_IN_INT_LEVELS(iq_no));
+
+	/* Set up IQ ISM registers and structures */
+	ism_addr = (otx_ep->ism_buffer_mz->iova | OTX2_EP_ISM_EN
+		    | OTX2_EP_ISM_MSIX_DIS)
+		    + OTX2_EP_IQ_ISM_OFFSET(iq_no);
+	oct_ep_write64(ism_addr, (uint8_t *)otx_ep->hw_addr +
+		       SDP_VF_R_IN_CNTS_ISM(iq_no));
+	iq->inst_cnt_ism =
+		(uint32_t *)((uint8_t *)otx_ep->ism_buffer_mz->addr
+			     + OTX2_EP_IQ_ISM_OFFSET(iq_no));
+	otx_ep_err("SDP_R[%d] INST Q ISM virt: %p, dma: 0x%x", iq_no,
+		   (void *)iq->inst_cnt_ism,
+		   (unsigned int)ism_addr);
+	*iq->inst_cnt_ism = 0;
+	iq->inst_cnt_ism_prev = 0;
+
+	return 0;
 }
 
-static void
+static int
 otx2_vf_setup_oq_regs(struct otx_ep_device *otx_ep, uint32_t oq_no)
 {
 	volatile uint64_t reg_val = 0ull;
 	uint64_t oq_ctl = 0ull;
-	uint64_t loop = OTX_EP_BUSY_LOOP_COUNT;
 	struct otx_ep_droq *droq = otx_ep->droq[oq_no];
+	uint64_t ism_addr;
+	int loop = SDP_VF_BUSY_LOOP_COUNT;
 
 	/* Wait on IDLE to set to 1, supposed to configure BADDR
 	 * as long as IDLE is 0
@@ -141,16 +318,14 @@ otx2_vf_setup_oq_regs(struct otx_ep_device *otx_ep, uint32_t oq_no)
 	reg_val = oct_ep_read64(otx_ep->hw_addr + SDP_VF_R_OUT_CONTROL(oq_no));
 
 	while ((!(reg_val & SDP_VF_R_OUT_CTL_IDLE)) && loop--) {
-		reg_val = oct_ep_read64(otx_ep->hw_addr + SDP_VF_R_OUT_CONTROL(oq_no));
-		rte_delay_ms(1);
-	}
-
-	if (!loop) {
-		otx_ep_err("OUT CNT REGISTER value is zero\n");
-		return;
+		reg_val = oct_ep_read64(otx_ep->hw_addr +
+				      SDP_VF_R_OUT_CONTROL(oq_no));
 	}
+	if (loop < 0)
+		return -EIO;
 
-	oct_ep_write64(droq->desc_ring_dma, otx_ep->hw_addr + SDP_VF_R_OUT_SLIST_BADDR(oq_no));
+	oct_ep_write64(droq->desc_ring_dma, otx_ep->hw_addr +
+		     SDP_VF_R_OUT_SLIST_BADDR(oq_no));
 	oct_ep_write64(droq->nb_desc, otx_ep->hw_addr + SDP_VF_R_OUT_SLIST_RSIZE(oq_no));
 
 	oq_ctl = oct_ep_read64(otx_ep->hw_addr + SDP_VF_R_OUT_CONTROL(oq_no));
@@ -161,7 +336,7 @@ otx2_vf_setup_oq_regs(struct otx_ep_device *otx_ep, uint32_t oq_no)
 	/* Populate the BSIZE (15-0) */
 	oq_ctl |= (droq->buffer_size & OTX_EP_DROQ_BUFSZ_MASK);
 
-	oct_ep_write64(oq_ctl, otx_ep->hw_addr + SDP_VF_R_OUT_CONTROL(oq_no));
+	otx2_write64(oq_ctl, otx_ep->hw_addr + SDP_VF_R_OUT_CONTROL(oq_no));
 
 	/* Mapped address of the pkt_sent and pkts_credit regs */
 	droq->pkts_sent_reg = (uint8_t *)otx_ep->hw_addr + SDP_VF_R_OUT_CNTS(oq_no);
@@ -175,23 +350,39 @@ otx2_vf_setup_oq_regs(struct otx_ep_device *otx_ep, uint32_t oq_no)
 
 	loop = OTX_EP_BUSY_LOOP_COUNT;
 	/* Clear the OQ doorbell  */
+	loop = SDP_VF_BUSY_LOOP_COUNT;
 	rte_write32(OTX_EP_CLEAR_SLIST_DBELL, droq->pkts_credit_reg);
 	while ((rte_read32(droq->pkts_credit_reg) != 0ull) && loop--) {
 		rte_write32(OTX_EP_CLEAR_SLIST_DBELL, droq->pkts_credit_reg);
 		rte_delay_ms(1);
 	}
 
-	if (!loop) {
-		otx_ep_err("Packets credit register value is not cleared\n");
-		return;
-	}
-	otx_ep_dbg("SDP_R[%d]_credit:%x", oq_no, rte_read32(droq->pkts_credit_reg));
+	if (loop < 0)
+		return -EIO;
+	otx_ep_dbg("SDP_R[%d]_credit:%x", oq_no,
+		   rte_read32(droq->pkts_credit_reg));
 
 	/* Clear the OQ_OUT_CNTS doorbell  */
 	reg_val = rte_read32(droq->pkts_sent_reg);
 	rte_write32((uint32_t)reg_val, droq->pkts_sent_reg);
 
-	otx_ep_dbg("SDP_R[%d]_sent: %x", oq_no, rte_read32(droq->pkts_sent_reg));
+	otx_ep_dbg("SDP_R[%d]_sent: %x", oq_no,
+		   rte_read32(droq->pkts_sent_reg));
+
+	/* Set up ISM registers and structures */
+	ism_addr = (otx_ep->ism_buffer_mz->iova | OTX2_EP_ISM_EN
+		    | OTX2_EP_ISM_MSIX_DIS)
+		    + OTX2_EP_OQ_ISM_OFFSET(oq_no);
+	oct_ep_write64(ism_addr, (uint8_t *)otx_ep->hw_addr +
+		    SDP_VF_R_OUT_CNTS_ISM(oq_no));
+	droq->pkts_sent_ism =
+		(uint32_t *)((uint8_t *)otx_ep->ism_buffer_mz->addr
+			     + OTX2_EP_OQ_ISM_OFFSET(oq_no));
+	otx_ep_err("SDP_R[%d] OQ ISM virt: %p, dma: 0x%x", oq_no,
+		   (void *)droq->pkts_sent_ism,
+		   (unsigned int)ism_addr);
+	*droq->pkts_sent_ism = 0;
+	droq->pkts_sent_ism_prev = 0;
 
 	loop = OTX_EP_BUSY_LOOP_COUNT;
 	while (((rte_read32(droq->pkts_sent_reg)) != 0ull) && loop--) {
@@ -200,18 +391,19 @@ otx2_vf_setup_oq_regs(struct otx_ep_device *otx_ep, uint32_t oq_no)
 		rte_delay_ms(1);
 	}
 
-	if (!loop) {
-		otx_ep_err("Packets sent register value is not cleared\n");
-		return;
-	}
-	otx_ep_dbg("SDP_R[%d]_sent: %x", oq_no, rte_read32(droq->pkts_sent_reg));
+	if (loop < 0)
+		return -EIO;
+	otx_ep_dbg("SDP_R[%d]_sent: %x", oq_no,
+		   rte_read32(droq->pkts_sent_reg));
+
+	return 0;
 }
 
 static int
 otx2_vf_enable_iq(struct otx_ep_device *otx_ep, uint32_t q_no)
 {
-	uint64_t loop = SDP_VF_BUSY_LOOP_COUNT;
-	uint64_t reg_val = 0ull;
+	volatile uint64_t reg_val = 0ull;
+	int loop = SDP_VF_BUSY_LOOP_COUNT;
 
 	/* Resetting doorbells during IQ enabling also to handle abrupt
 	 * guest reboot. IQ reset does not clear the doorbells.
@@ -223,7 +415,7 @@ otx2_vf_enable_iq(struct otx_ep_device *otx_ep, uint32_t q_no)
 		rte_delay_ms(1);
 	}
 
-	if (!loop) {
+	if (loop < 0) {
 		otx_ep_err("INSTR DBELL not coming back to 0\n");
 		return -EIO;
 	}
@@ -335,6 +527,40 @@ otx2_ep_get_defconf(struct otx_ep_device *otx_ep_dev __rte_unused)
 	return default_conf;
 }
 
+static int otx2_vf_enable_rxq_intr(struct otx_ep_device *otx_epvf,
+				   uint16_t q_no)
+{
+	union out_int_lvl_t out_int_lvl;
+	union out_cnts_t out_cnts;
+
+	out_int_lvl.d64 = otx2_read64(otx_epvf->hw_addr +
+				SDP_VF_R_OUT_INT_LEVELS(q_no));
+	out_int_lvl.s.time_cnt_en = 1;
+	out_int_lvl.s.cnt = 0;
+	otx2_write64(out_int_lvl.d64, otx_epvf->hw_addr +
+			SDP_VF_R_OUT_INT_LEVELS(q_no));
+	out_cnts.d64 = 0;
+	out_cnts.s.resend = 1;
+	otx2_write64(out_cnts.d64, otx_epvf->hw_addr + SDP_VF_R_OUT_CNTS(q_no));
+	return 0;
+}
+
+static int otx2_vf_disable_rxq_intr(struct otx_ep_device *otx_epvf,
+				    uint16_t q_no)
+{
+	union out_int_lvl_t out_int_lvl;
+
+	/* Disable the interrupt for this queue */
+	out_int_lvl.d64 = otx2_read64(otx_epvf->hw_addr +
+				SDP_VF_R_OUT_INT_LEVELS(q_no));
+	out_int_lvl.s.time_cnt_en = 0;
+	out_int_lvl.s.cnt = 0;
+	otx2_write64(out_int_lvl.d64, otx_epvf->hw_addr +
+			SDP_VF_R_OUT_INT_LEVELS(q_no));
+
+	return 0;
+}
+
 int
 otx2_ep_vf_setup_device(struct otx_ep_device *otx_ep)
 {
@@ -371,6 +597,8 @@ otx2_ep_vf_setup_device(struct otx_ep_device *otx_ep)
 
 	otx_ep->fn_list.enable_oq           = otx2_vf_enable_oq;
 	otx_ep->fn_list.disable_oq          = otx2_vf_disable_oq;
+	otx_ep->fn_list.enable_rxq_intr     = otx2_vf_enable_rxq_intr;
+	otx_ep->fn_list.disable_rxq_intr    = otx2_vf_disable_rxq_intr;
 
 	return 0;
 }
diff --git a/drivers/net/octeon_ep/otx2_ep_vf.h b/drivers/net/octeon_ep/otx2_ep_vf.h
index 59e67ad38e710..40d35b6d8e2dc 100644
--- a/drivers/net/octeon_ep/otx2_ep_vf.h
+++ b/drivers/net/octeon_ep/otx2_ep_vf.h
@@ -6,109 +6,6 @@
 
 #include <rte_io.h>
 
-#define SDP_VF_R_IN_CTL_IDLE            (0x1ull << 28)
-#define SDP_VF_R_IN_CTL_RDSIZE          (0x3ull << 25) /* Setting to max(4) */
-#define SDP_VF_R_IN_CTL_IS_64B          (0x1ull << 24)
-#define SDP_VF_R_IN_CTL_ESR             (0x1ull << 1)
-
-#define SDP_VF_BUSY_LOOP_COUNT      (10000)
-
-/* SDP VF OQ Masks */
-#define SDP_VF_R_OUT_CTL_IDLE         (1ull << 40)
-#define SDP_VF_R_OUT_CTL_ES_I         (1ull << 34)
-#define SDP_VF_R_OUT_CTL_NSR_I        (1ull << 33)
-#define SDP_VF_R_OUT_CTL_ROR_I        (1ull << 32)
-#define SDP_VF_R_OUT_CTL_ES_D         (1ull << 30)
-#define SDP_VF_R_OUT_CTL_NSR_D        (1ull << 29)
-#define SDP_VF_R_OUT_CTL_ROR_D        (1ull << 28)
-#define SDP_VF_R_OUT_CTL_ES_P         (1ull << 26)
-#define SDP_VF_R_OUT_CTL_NSR_P        (1ull << 25)
-#define SDP_VF_R_OUT_CTL_ROR_P        (1ull << 24)
-#define SDP_VF_R_OUT_CTL_IMODE        (1ull << 23)
-
-/* SDP VF Register definitions */
-#define SDP_VF_RING_OFFSET                (0x1ull << 17)
-
-/* SDP VF IQ Registers */
-#define SDP_VF_R_IN_CONTROL_START         (0x10000)
-#define SDP_VF_R_IN_ENABLE_START          (0x10010)
-#define SDP_VF_R_IN_INSTR_BADDR_START     (0x10020)
-#define SDP_VF_R_IN_INSTR_RSIZE_START     (0x10030)
-#define SDP_VF_R_IN_INSTR_DBELL_START     (0x10040)
-#define SDP_VF_R_IN_CNTS_START            (0x10050)
-#define SDP_VF_R_IN_INT_LEVELS_START      (0x10060)
-#define SDP_VF_R_IN_PKT_CNT_START         (0x10080)
-#define SDP_VF_R_IN_BYTE_CNT_START        (0x10090)
-
-#define SDP_VF_R_IN_CONTROL(ring)  \
-	(SDP_VF_R_IN_CONTROL_START + ((ring) * SDP_VF_RING_OFFSET))
-
-#define SDP_VF_R_IN_ENABLE(ring)   \
-	(SDP_VF_R_IN_ENABLE_START + ((ring) * SDP_VF_RING_OFFSET))
-
-#define SDP_VF_R_IN_INSTR_BADDR(ring)   \
-	(SDP_VF_R_IN_INSTR_BADDR_START + ((ring) * SDP_VF_RING_OFFSET))
-
-#define SDP_VF_R_IN_INSTR_RSIZE(ring)   \
-	(SDP_VF_R_IN_INSTR_RSIZE_START + ((ring) * SDP_VF_RING_OFFSET))
-
-#define SDP_VF_R_IN_INSTR_DBELL(ring)   \
-	(SDP_VF_R_IN_INSTR_DBELL_START + ((ring) * SDP_VF_RING_OFFSET))
-
-#define SDP_VF_R_IN_CNTS(ring)          \
-	(SDP_VF_R_IN_CNTS_START + ((ring) * SDP_VF_RING_OFFSET))
-
-#define SDP_VF_R_IN_INT_LEVELS(ring)    \
-	(SDP_VF_R_IN_INT_LEVELS_START + ((ring) * SDP_VF_RING_OFFSET))
-
-#define SDP_VF_R_IN_PKT_CNT(ring)       \
-	(SDP_VF_R_IN_PKT_CNT_START + ((ring) * SDP_VF_RING_OFFSET))
-
-#define SDP_VF_R_IN_BYTE_CNT(ring)          \
-	(SDP_VF_R_IN_BYTE_CNT_START + ((ring) * SDP_VF_RING_OFFSET))
-
-/* SDP VF OQ Registers */
-#define SDP_VF_R_OUT_CNTS_START              (0x10100)
-#define SDP_VF_R_OUT_INT_LEVELS_START        (0x10110)
-#define SDP_VF_R_OUT_SLIST_BADDR_START       (0x10120)
-#define SDP_VF_R_OUT_SLIST_RSIZE_START       (0x10130)
-#define SDP_VF_R_OUT_SLIST_DBELL_START       (0x10140)
-#define SDP_VF_R_OUT_CONTROL_START           (0x10150)
-#define SDP_VF_R_OUT_ENABLE_START            (0x10160)
-#define SDP_VF_R_OUT_PKT_CNT_START           (0x10180)
-#define SDP_VF_R_OUT_BYTE_CNT_START          (0x10190)
-
-#define SDP_VF_R_OUT_CONTROL(ring)    \
-	(SDP_VF_R_OUT_CONTROL_START + ((ring) * SDP_VF_RING_OFFSET))
-
-#define SDP_VF_R_OUT_ENABLE(ring)     \
-	(SDP_VF_R_OUT_ENABLE_START + ((ring) * SDP_VF_RING_OFFSET))
-
-#define SDP_VF_R_OUT_SLIST_BADDR(ring)  \
-	(SDP_VF_R_OUT_SLIST_BADDR_START + ((ring) * SDP_VF_RING_OFFSET))
-
-#define SDP_VF_R_OUT_SLIST_RSIZE(ring)  \
-	(SDP_VF_R_OUT_SLIST_RSIZE_START + ((ring) * SDP_VF_RING_OFFSET))
-
-#define SDP_VF_R_OUT_SLIST_DBELL(ring)  \
-	(SDP_VF_R_OUT_SLIST_DBELL_START + ((ring) * SDP_VF_RING_OFFSET))
-
-#define SDP_VF_R_OUT_CNTS(ring)   \
-	(SDP_VF_R_OUT_CNTS_START + ((ring) * SDP_VF_RING_OFFSET))
-
-#define SDP_VF_R_OUT_INT_LEVELS(ring)   \
-	(SDP_VF_R_OUT_INT_LEVELS_START + ((ring) * SDP_VF_RING_OFFSET))
-
-#define SDP_VF_R_OUT_PKT_CNT(ring)   \
-	(SDP_VF_R_OUT_PKT_CNT_START + ((ring) * SDP_VF_RING_OFFSET))
-
-#define SDP_VF_R_OUT_BYTE_CNT(ring)   \
-	(SDP_VF_R_OUT_BYTE_CNT_START + ((ring) * SDP_VF_RING_OFFSET))
-
-/* SDP VF IQ Masks */
-#define SDP_VF_R_IN_CTL_RPVF_MASK       (0xF)
-#define	SDP_VF_R_IN_CTL_RPVF_POS        (48)
-
 /* IO Access */
 #define otx2_read64(addr) rte_read64_relaxed((void *)(addr))
 #define otx2_write64(val, addr) rte_write64_relaxed((val), (void *)(addr))
@@ -117,7 +14,6 @@
 #define PCI_DEVID_CN98XX_EP_NET_VF		0xB103
 #define PCI_DEVID_CNF95N_EP_NET_VF		0xB403
 #define PCI_DEVID_CNF95O_EP_NET_VF		0xB603
-#define PCI_DEVID_LIO3_EP_NET_VF		0x3383 /* LIO3 EP mode */
 
 #define OTX2_EP_MAX_RX_PKT_LEN			(16384)
 
@@ -142,6 +38,13 @@ struct otx2_ep_instr_64B {
 	/* Additional headers available in a 64-byte instruction. */
 	uint64_t exhdr[4];
 };
+
+#define OTX2_EP_IQ_ISM_OFFSET(queue)	(RTE_CACHE_LINE_SIZE * (queue) + 4)
+#define OTX2_EP_OQ_ISM_OFFSET(queue)	(RTE_CACHE_LINE_SIZE * (queue))
+#define OTX2_EP_ISM_EN			(0x1)
+#define OTX2_EP_ISM_MSIX_DIS		(0x2)
+#define OTX2_EP_MAX_RX_PKT_LEN		(16384)
+
 static inline int is_otx2_ep_vf(uint16_t chip_id)
 {
 	return (chip_id == PCI_DEVID_OCTEONTX2_EP_NET_VF ||
@@ -150,4 +53,41 @@ static inline int is_otx2_ep_vf(uint16_t chip_id)
 		chip_id == PCI_DEVID_CNF95O_EP_NET_VF ||
 		chip_id == PCI_DEVID_CN98XX_EP_NET_VF);
 }
+
+union out_int_lvl_t {
+	uint64_t d64;
+	struct {
+		uint64_t cnt:32;
+		uint64_t timet:22;
+		uint64_t max_len:7;
+		uint64_t max_len_en:1;
+		uint64_t time_cnt_en:1;
+		uint64_t bmode:1;
+	} s;
+};
+
+union out_cnts_t {
+	uint64_t d64;
+	struct {
+		uint64_t cnt:32;
+		uint64_t timer:22;
+		uint64_t rsvd:5;
+		uint64_t resend:1;
+		uint64_t mbox_int:1;
+		uint64_t in_int:1;
+		uint64_t out_int:1;
+		uint64_t send_ism:1;
+	} s;
+};
+
+#define OTX2_EP_64B_INSTR_SIZE	(sizeof(otx2_ep_instr_64B))
+
+#define NIX_MAX_HW_FRS			9212
+#define NIX_MAX_VTAG_INS		2
+#define NIX_MAX_VTAG_ACT_SIZE		(4 * NIX_MAX_VTAG_INS)
+#define NIX_MAX_FRS	\
+	(NIX_MAX_HW_FRS + RTE_ETHER_CRC_LEN - NIX_MAX_VTAG_ACT_SIZE)
+
+#define CN93XX_INTR_R_OUT_INT        (1ULL << 62)
+#define CN93XX_INTR_R_IN_INT         (1ULL << 61)
 #endif /*_OTX2_EP_VF_H_ */
diff --git a/drivers/net/octeon_ep/otx_ep_common.h b/drivers/net/octeon_ep/otx_ep_common.h
index a5b7a9ac2bc29..9abde270ecf3f 100644
--- a/drivers/net/octeon_ep/otx_ep_common.h
+++ b/drivers/net/octeon_ep/otx_ep_common.h
@@ -196,6 +196,8 @@ struct otx_ep_instr_queue {
 	 *  has read the commands.
 	 */
 	uint32_t flush_index;
+	/* Free-running/wrapping instruction counter for IQ. */
+	uint32_t inst_cnt;
 
 	/* This keeps track of the instructions pending in this queue. */
 	uint64_t instr_pending;
@@ -223,6 +225,11 @@ struct otx_ep_instr_queue {
 
 	/* Memory zone */
 	const struct rte_memzone *iq_mz;
+
+	/* Location in memory updated by SDP ISM */
+	uint32_t *inst_cnt_ism;
+	/* track inst count locally to consolidate HW counter updates */
+	uint32_t inst_cnt_ism_prev;
 };
 
 /** Descriptor format.
@@ -245,6 +252,8 @@ struct otx_ep_droq_desc {
 union otx_ep_rh {
 	uint64_t rh64;
 };
+
+#define OTX_EP_RH_SIZE (sizeof(union otx_ep_rh))
 #define OTX_EP_RH_SIZE_NIC (sizeof(union otx_ep_rh))
 #define OTX_EP_RH_SIZE_LOOP 0  /* Nothing in LOOP mode */
 
@@ -371,6 +380,10 @@ struct otx_ep_droq {
 	const struct rte_memzone *desc_ring_mz;
 
 	const struct rte_memzone *info_mz;
+
+	/* Pointer to host memory copy of output packet count, set by ISM */
+	uint32_t *pkts_sent_ism;
+	uint32_t pkts_sent_ism_prev;
 };
 #define OTX_EP_DROQ_SIZE		(sizeof(struct otx_ep_droq))
 
@@ -410,11 +423,11 @@ struct otx_ep_sriov_info {
 
 /* Required functions for each VF device */
 struct otx_ep_fn_list {
-	void (*setup_iq_regs)(struct otx_ep_device *otx_ep, uint32_t q_no);
+	int (*setup_iq_regs)(struct otx_ep_device *otx_ep, uint32_t q_no);
 
-	void (*setup_oq_regs)(struct otx_ep_device *otx_ep, uint32_t q_no);
+	int (*setup_oq_regs)(struct otx_ep_device *otx_ep, uint32_t q_no);
 
-	void (*setup_device_regs)(struct otx_ep_device *otx_ep);
+	int (*setup_device_regs)(struct otx_ep_device *otx_ep);
 
 	int (*enable_io_queues)(struct otx_ep_device *otx_ep);
 	void (*disable_io_queues)(struct otx_ep_device *otx_ep);
@@ -424,6 +437,8 @@ struct otx_ep_fn_list {
 
 	int (*enable_oq)(struct otx_ep_device *otx_ep, uint32_t q_no);
 	void (*disable_oq)(struct otx_ep_device *otx_ep, uint32_t q_no);
+	int (*enable_rxq_intr)(struct otx_ep_device *otx_epvf, uint16_t q_no);
+	int (*disable_rxq_intr)(struct otx_ep_device *otx_epvf, uint16_t q_no);
 };
 
 /* OTX_EP EP VF device data structure */
@@ -475,6 +490,9 @@ struct otx_ep_device {
 
 	/* Packet mode (LOOP vs NIC), set by parameter */
 	uint8_t sdp_packet_mode;
+
+	/* DMA buffer for SDP ISM messages */
+	const struct rte_memzone *ism_buffer_mz;
 };
 
 int otx_ep_setup_iqs(struct otx_ep_device *otx_ep, uint32_t iq_no,
@@ -517,7 +535,7 @@ struct otx_ep_buf_free_info {
 	struct otx_ep_gather g;
 };
 
-#define OTX_EP_MAX_PKT_SZ 64000U
+#define OTX_EP_MAX_PKT_SZ 65498U
 #define OTX_EP_MAX_MAC_ADDRS 1
 #define OTX_EP_SG_ALIGN 8
 #define OTX_EP_CLEAR_ISIZE_BSIZE 0x7FFFFFULL
diff --git a/drivers/net/octeon_ep/otx_ep_ethdev.c b/drivers/net/octeon_ep/otx_ep_ethdev.c
index 4e9fc6100b9bd..36227dabd3bd7 100644
--- a/drivers/net/octeon_ep/otx_ep_ethdev.c
+++ b/drivers/net/octeon_ep/otx_ep_ethdev.c
@@ -5,6 +5,7 @@
 #include <ethdev_pci.h>
 #include <rte_kvargs.h>
 
+#include "common/cnxk/roc_api.h"
 #include "otx_ep_common.h"
 #include "otx_ep_vf.h"
 #include "otx2_ep_vf.h"
@@ -40,8 +41,9 @@ otx_ep_dev_info_get(struct rte_eth_dev *eth_dev,
 
 	devinfo->min_rx_bufsize = OTX_EP_MIN_RX_BUF_SIZE;
 	devinfo->max_rx_pktlen = OTX_EP_MAX_PKT_SZ;
-	devinfo->rx_offload_capa = RTE_ETH_RX_OFFLOAD_SCATTER;
-	devinfo->tx_offload_capa = RTE_ETH_TX_OFFLOAD_MULTI_SEGS;
+	devinfo->rx_offload_capa = DEV_RX_OFFLOAD_JUMBO_FRAME;
+	devinfo->rx_offload_capa |= DEV_RX_OFFLOAD_SCATTER;
+	devinfo->tx_offload_capa = DEV_TX_OFFLOAD_MULTI_SEGS;
 
 	devinfo->max_mac_addrs = OTX_EP_MAX_MAC_ADDRS;
 
@@ -91,6 +93,28 @@ otx_ep_dev_stop(struct rte_eth_dev *eth_dev)
 	return 0;
 }
 
+/*
+ * We only need 2 uint32_t locations per IOQ, but separate these so
+ * each IOQ has the variables on its own cache line.
+ */
+#define OTX2_EP_ISM_BUFFER_SIZE	(OTX_EP_MAX_IOQS_PER_VF * RTE_CACHE_LINE_SIZE)
+static int
+otx2_ep_ism_setup(struct otx_ep_device *otx_epvf)
+{
+	otx_epvf->ism_buffer_mz =
+		rte_eth_dma_zone_reserve(otx_epvf->eth_dev, "ism",
+					 0, OTX2_EP_ISM_BUFFER_SIZE,
+					 OTX_EP_PCI_RING_ALIGN, 0);
+
+	/* Same DMA buffer is shared by OQ and IQ, clear it at start */
+	memset(otx_epvf->ism_buffer_mz->addr, 0, OTX2_EP_ISM_BUFFER_SIZE);
+	if (otx_epvf->ism_buffer_mz == NULL) {
+		otx_ep_err("Failed to allocate ISM buffer\n");
+		return(-1);
+	}
+
+	return 0;
+}
 static int
 otx_ep_chip_specific_setup(struct otx_ep_device *otx_epvf)
 {
@@ -105,12 +129,15 @@ otx_ep_chip_specific_setup(struct otx_ep_device *otx_epvf)
 		otx_epvf->fn_list.disable_io_queues(otx_epvf);
 		break;
 	case PCI_DEVID_OCTEONTX2_EP_NET_VF:
+	case PCI_DEVID_CNF95XXN_EP_NET_VF:
+	case PCI_DEVID_CNF95XXO_EP_NET_VF:
+	case PCI_DEVID_LIO3_EP_NET_VF:
 	case PCI_DEVID_CN98XX_EP_NET_VF:
-	case PCI_DEVID_CNF95N_EP_NET_VF:
-	case PCI_DEVID_CNF95O_EP_NET_VF:
 		otx_epvf->chip_id = dev_id;
 		ret = otx2_ep_vf_setup_device(otx_epvf);
 		otx_epvf->fn_list.disable_io_queues(otx_epvf);
+		if (otx2_ep_ism_setup(otx_epvf))
+			ret = -EINVAL;
 		break;
 	case PCI_DEVID_CN10KA_EP_NET_VF:
 	case PCI_DEVID_CN10KB_EP_NET_VF:
@@ -152,13 +179,17 @@ otx_epdev_init(struct otx_ep_device *otx_epvf)
 	else if (otx_epvf->chip_id == PCI_DEVID_OCTEONTX2_EP_NET_VF ||
 		 otx_epvf->chip_id == PCI_DEVID_CN98XX_EP_NET_VF ||
 		 otx_epvf->chip_id == PCI_DEVID_CNF95N_EP_NET_VF ||
-		 otx_epvf->chip_id == PCI_DEVID_CNF95O_EP_NET_VF)
-		otx_epvf->eth_dev->tx_pkt_burst = &otx2_ep_xmit_pkts;
-	else if (otx_epvf->chip_id == PCI_DEVID_CN10KA_EP_NET_VF ||
+		 otx_epvf->chip_id == PCI_DEVID_CNF95O_EP_NET_VF ||
+		 otx_epvf->chip_id == PCI_DEVID_CN10KA_EP_NET_VF ||
 		 otx_epvf->chip_id == PCI_DEVID_CN10KB_EP_NET_VF ||
 		 otx_epvf->chip_id == PCI_DEVID_CNF10KA_EP_NET_VF ||
-		 otx_epvf->chip_id == PCI_DEVID_CNF10KB_EP_NET_VF)
+		 otx_epvf->chip_id == PCI_DEVID_CNF10KB_EP_NET_VF) {
 		otx_epvf->eth_dev->tx_pkt_burst = &otx2_ep_xmit_pkts;
+	} else {
+		otx_ep_err("Invalid chip_id\n");
+		ret = -EINVAL;
+		goto setup_fail;
+	}
 	ethdev_queues = (uint32_t)(otx_epvf->sriov_info.rings_per_vf);
 	otx_epvf->max_rx_queues = ethdev_queues;
 	otx_epvf->max_tx_queues = ethdev_queues;
@@ -467,6 +498,11 @@ otx_epdev_exit(struct rte_eth_dev *eth_dev)
 	}
 	otx_ep_dbg("Num IQs:%d freed\n", otx_epvf->nb_tx_queues);
 
+	if (rte_eth_dma_zone_free(eth_dev, "ism", 0)) {
+		otx_ep_err("Failed to delete ISM buffer\n");
+		return -EINVAL;
+	}
+
 	return 0;
 }
 
@@ -553,7 +589,8 @@ otx_ep_eth_dev_init(struct rte_eth_dev *eth_dev)
 	otx_epvf->hw_addr = pdev->mem_resource[0].addr;
 	otx_epvf->pdev = pdev;
 
-	otx_epdev_init(otx_epvf);
+	if (otx_epdev_init(otx_epvf))
+		return -ENOMEM;
 	if (otx_epvf->chip_id == PCI_DEVID_OCTEONTX2_EP_NET_VF ||
 	    otx_epvf->chip_id == PCI_DEVID_CN98XX_EP_NET_VF ||
 	    otx_epvf->chip_id == PCI_DEVID_CNF95N_EP_NET_VF ||
@@ -566,8 +603,11 @@ otx_ep_eth_dev_init(struct rte_eth_dev *eth_dev)
 			otx_epvf->pkind = SDP_OTX2_PKIND_FS24;
 		else
 			otx_epvf->pkind = SDP_OTX2_PKIND_FS0;
-	} else {
+	} else if (otx_epvf->chip_id == PCI_DEVID_OCTEONTX_EP_VF) {
 		otx_epvf->pkind = SDP_PKIND;
+	} else {
+		otx_ep_err("Invalid chip id\n");
+		return -EINVAL;
 	}
 	otx_ep_info("using pkind %d\n", otx_epvf->pkind);
 
@@ -594,6 +634,9 @@ otx_ep_eth_dev_pci_remove(struct rte_pci_device *pci_dev)
 static const struct rte_pci_id pci_id_otx_ep_map[] = {
 	{ RTE_PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_OCTEONTX_EP_VF) },
 	{ RTE_PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_OCTEONTX2_EP_NET_VF) },
+	{ RTE_PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_CNF95XXN_EP_NET_VF) },
+	{ RTE_PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_CNF95XXO_EP_NET_VF) },
+	{ RTE_PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_LIO3_EP_NET_VF) },
 	{ RTE_PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_CN98XX_EP_NET_VF) },
 	{ RTE_PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_CNF95N_EP_NET_VF) },
 	{ RTE_PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_CNF95O_EP_NET_VF) },
diff --git a/drivers/net/octeon_ep/otx_ep_rxtx.c b/drivers/net/octeon_ep/otx_ep_rxtx.c
index ac0828c439efa..5e569be9da002 100644
--- a/drivers/net/octeon_ep/otx_ep_rxtx.c
+++ b/drivers/net/octeon_ep/otx_ep_rxtx.c
@@ -10,6 +10,7 @@
 #include <rte_io.h>
 #include <rte_net.h>
 #include <ethdev_pci.h>
+#include "common/cnxk/roc_api.h"
 
 #include "otx_ep_common.h"
 #include "otx_ep_vf.h"
@@ -19,6 +20,7 @@
 /* SDP_LENGTH_S specifies packet length and is of 8-byte size */
 #define INFO_SIZE 8
 #define DROQ_REFILL_THRESHOLD 16
+#define OTX2_SDP_REQUEST_ISM	(0x1ULL << 63)
 
 /* These arrays indexed by otx_ep_device->sdp_packet_mode */
 static uint8_t front_size[2] = {OTX2_EP_FSZ_NIC, OTX2_EP_FSZ_LOOP};
@@ -86,6 +88,7 @@ otx_ep_init_instr_queue(struct otx_ep_device *otx_ep, int iq_no, int num_descs,
 	const struct otx_ep_config *conf;
 	struct otx_ep_instr_queue *iq;
 	uint32_t q_size;
+	int ret;
 
 	conf = otx_ep->conf;
 	iq = otx_ep->instr_queue[iq_no];
@@ -145,7 +148,9 @@ otx_ep_init_instr_queue(struct otx_ep_device *otx_ep, int iq_no, int num_descs,
 	iq->iqcmd_64B = (conf->iq.instr_type == 64);
 
 	/* Set up IQ registers */
-	otx_ep->fn_list.setup_iq_regs(otx_ep, iq_no);
+	ret = otx_ep->fn_list.setup_iq_regs(otx_ep, iq_no);
+	if (ret)
+		return ret;
 
 	return 0;
 
@@ -276,6 +281,7 @@ otx_ep_init_droq(struct otx_ep_device *otx_ep, uint32_t q_no,
 	uint32_t c_refill_threshold;
 	struct otx_ep_droq *droq;
 	uint32_t desc_ring_size;
+	int ret;
 
 	otx_ep_info("OQ[%d] Init start\n", q_no);
 
@@ -323,7 +329,9 @@ otx_ep_init_droq(struct otx_ep_device *otx_ep, uint32_t q_no,
 	droq->refill_threshold = c_refill_threshold;
 
 	/* Set up OQ registers */
-	otx_ep->fn_list.setup_oq_regs(otx_ep, q_no);
+	ret = otx_ep->fn_list.setup_oq_regs(otx_ep, q_no);
+	if (ret)
+		return ret;
 
 	otx_ep->io_qmask.oq |= (1ull << q_no);
 
@@ -411,15 +419,32 @@ otx_ep_iqreq_add(struct otx_ep_instr_queue *iq, void *buf,
 static uint32_t
 otx_vf_update_read_index(struct otx_ep_instr_queue *iq)
 {
-	uint32_t new_idx = rte_read32(iq->inst_cnt_reg);
-	if (unlikely(new_idx == 0xFFFFFFFFU))
-		rte_write32(new_idx, iq->inst_cnt_reg);
+	uint32_t val;
+
+	/*
+	 * Batch subtractions from the HW counter to reduce PCIe traffic
+	 * This adds an extra local variable, but almost halves the
+	 * number of PCIe writes.
+	 */
+	val = *iq->inst_cnt_ism;
+	iq->inst_cnt += val - iq->inst_cnt_ism_prev;
+	iq->inst_cnt_ism_prev = val;
+
+	if (val > (uint32_t)(1 << 31)) {
+		/*
+		 * Only subtract the packet count in the HW counter
+		 * when count above halfway to saturation.
+		 */
+		rte_write32(val, iq->inst_cnt_reg);
+		*iq->inst_cnt_ism = 0;
+		iq->inst_cnt_ism_prev = 0;
+	}
+	rte_write64(OTX2_SDP_REQUEST_ISM, iq->inst_cnt_reg);
+
 	/* Modulo of the new index with the IQ size will give us
 	 * the new index.
 	 */
-	new_idx &= (iq->nb_desc - 1);
-
-	return new_idx;
+	return iq->inst_cnt & (iq->nb_desc - 1);
 }
 
 static void
@@ -968,6 +993,12 @@ otx_ep_droq_read_packet(struct otx_ep_device *otx_ep,
 		goto oq_read_fail;
 	}
 
+	if ((droq_pkt->pkt_len > (RTE_ETHER_MAX_LEN + OTX_CUST_DATA_LEN)) &&
+	    !(otx_ep->rx_offloads & DEV_RX_OFFLOAD_JUMBO_FRAME)) {
+		rte_pktmbuf_free(droq_pkt);
+		goto oq_read_fail;
+	}
+
 	if (droq_pkt->nb_segs > 1 &&
 	    !(otx_ep->rx_offloads & RTE_ETH_RX_OFFLOAD_SCATTER)) {
 		rte_pktmbuf_free(droq_pkt);
@@ -983,13 +1014,29 @@ otx_ep_droq_read_packet(struct otx_ep_device *otx_ep,
 static inline uint32_t
 otx_ep_check_droq_pkts(struct otx_ep_droq *droq)
 {
-	volatile uint64_t pkt_count;
 	uint32_t new_pkts;
+	uint32_t val;
+
+	/*
+	 * Batch subtractions from the HW counter to reduce PCIe traffic
+	 * This adds an extra local variable, but almost halves the
+	 * number of PCIe writes.
+	 */
+	val = *droq->pkts_sent_ism;
+	new_pkts = val - droq->pkts_sent_ism_prev;
+	droq->pkts_sent_ism_prev = val;
+
+	if (val > (uint32_t)(1 << 31)) {
+		/*
+		 * Only subtract the packet count in the HW counter
+		 * when count above halfway to saturation.
+		 */
+		rte_write32(val, droq->pkts_sent_reg);
+		*droq->pkts_sent_ism = 0;
+		droq->pkts_sent_ism_prev = 0;
+	}
+	rte_write64(OTX2_SDP_REQUEST_ISM, droq->pkts_sent_reg);
 
-	/* Latest available OQ packets */
-	pkt_count = rte_read32(droq->pkts_sent_reg);
-	rte_write32(pkt_count, droq->pkts_sent_reg);
-	new_pkts = pkt_count;
 	droq->pkts_pending += new_pkts;
 	return new_pkts;
 }
@@ -1035,6 +1082,7 @@ otx_ep_recv_pkts(void *rx_queue,
 				    "last_pkt_count %" PRIu64 "new_pkts %d.\n",
 				   droq->pkts_pending, droq->last_pkt_count,
 				   new_pkts);
+			droq->pkts_pending -= pkts;
 			droq->stats.rx_err++;
 			continue;
 		} else {
diff --git a/drivers/net/octeon_ep/otx_ep_vf.c b/drivers/net/octeon_ep/otx_ep_vf.c
index 96366b2a7f179..219cca1bedbc6 100644
--- a/drivers/net/octeon_ep/otx_ep_vf.c
+++ b/drivers/net/octeon_ep/otx_ep_vf.c
@@ -11,11 +11,11 @@
 #include "otx_ep_common.h"
 #include "otx_ep_vf.h"
 
-
-static void
+static int
 otx_ep_setup_global_iq_reg(struct otx_ep_device *otx_ep, int q_no)
 {
 	volatile uint64_t reg_val = 0ull;
+	int loop = OTX_EP_BUSY_LOOP_COUNT;
 
 	/* Select ES, RO, NS, RDSIZE,DPTR Format#0 for IQs
 	 * IS_64B is by default enabled.
@@ -33,8 +33,11 @@ otx_ep_setup_global_iq_reg(struct otx_ep_device *otx_ep, int q_no)
 		do {
 			reg_val = rte_read64(otx_ep->hw_addr +
 					      OTX_EP_R_IN_CONTROL(q_no));
-		} while (!(reg_val & OTX_EP_R_IN_CTL_IDLE));
+		} while (!(reg_val & OTX_EP_R_IN_CTL_IDLE) && loop--);
+		if (loop < 0)
+			return -EIO;
 	}
+	return 0;
 }
 
 static void
@@ -60,13 +63,19 @@ otx_ep_setup_global_oq_reg(struct otx_ep_device *otx_ep, int q_no)
 	otx_ep_write64(reg_val, otx_ep->hw_addr, OTX_EP_R_OUT_CONTROL(q_no));
 }
 
-static void
+static int
 otx_ep_setup_global_input_regs(struct otx_ep_device *otx_ep)
 {
 	uint64_t q_no = 0ull;
+	int ret = 0;
 
-	for (q_no = 0; q_no < (otx_ep->sriov_info.rings_per_vf); q_no++)
-		otx_ep_setup_global_iq_reg(otx_ep, q_no);
+	for (q_no = 0; q_no < (otx_ep->sriov_info.rings_per_vf); q_no++) {
+		ret = otx_ep_setup_global_iq_reg(otx_ep, q_no);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
 }
 
 static void
@@ -78,18 +87,24 @@ otx_ep_setup_global_output_regs(struct otx_ep_device *otx_ep)
 		otx_ep_setup_global_oq_reg(otx_ep, q_no);
 }
 
-static void
+static int
 otx_ep_setup_device_regs(struct otx_ep_device *otx_ep)
 {
-	otx_ep_setup_global_input_regs(otx_ep);
+	int ret;
+	ret = otx_ep_setup_global_input_regs(otx_ep);
+	if (ret)
+		return ret;
 	otx_ep_setup_global_output_regs(otx_ep);
+
+	return 0;
 }
 
-static void
+static int
 otx_ep_setup_iq_regs(struct otx_ep_device *otx_ep, uint32_t iq_no)
 {
 	struct otx_ep_instr_queue *iq = otx_ep->instr_queue[iq_no];
 	volatile uint64_t reg_val = 0ull;
+	int loop = OTX_EP_BUSY_LOOP_COUNT;
 
 	reg_val = rte_read64(otx_ep->hw_addr + OTX_EP_R_IN_CONTROL(iq_no));
 
@@ -100,7 +115,9 @@ otx_ep_setup_iq_regs(struct otx_ep_device *otx_ep, uint32_t iq_no)
 		do {
 			reg_val = rte_read64(otx_ep->hw_addr +
 					      OTX_EP_R_IN_CONTROL(iq_no));
-		} while (!(reg_val & OTX_EP_R_IN_CTL_IDLE));
+		} while (!(reg_val & OTX_EP_R_IN_CTL_IDLE) && loop--);
+		if (loop < 0)
+			return -EIO;
 	}
 
 	/* Write the start of the input queue's ring and its size  */
@@ -120,10 +137,13 @@ otx_ep_setup_iq_regs(struct otx_ep_device *otx_ep, uint32_t iq_no)
 	otx_ep_dbg("InstQ[%d]:dbell reg @ 0x%p inst_cnt_reg @ 0x%p\n",
 		     iq_no, iq->doorbell_reg, iq->inst_cnt_reg);
 
+	loop = OTX_EP_BUSY_LOOP_COUNT;
 	do {
 		reg_val = rte_read32(iq->inst_cnt_reg);
 		rte_write32(reg_val, iq->inst_cnt_reg);
-	} while (reg_val !=  0);
+	} while ((reg_val != 0) && loop--);
+	if (loop < 0)
+		return -EIO;
 
 	/* IN INTR_THRESHOLD is set to max(FFFFFFFF) which disable the IN INTR
 	 * to raise
@@ -133,13 +153,16 @@ otx_ep_setup_iq_regs(struct otx_ep_device *otx_ep, uint32_t iq_no)
 	 */
 	otx_ep_write64(OTX_EP_CLEAR_IN_INT_LVLS, otx_ep->hw_addr,
 		       OTX_EP_R_IN_INT_LEVELS(iq_no));
+
+	return 0;
 }
 
-static void
+static int
 otx_ep_setup_oq_regs(struct otx_ep_device *otx_ep, uint32_t oq_no)
 {
 	volatile uint64_t reg_val = 0ull;
 	uint64_t oq_ctl = 0ull;
+	int loop = OTX_EP_BUSY_LOOP_COUNT;
 
 	struct otx_ep_droq *droq = otx_ep->droq[oq_no];
 
@@ -150,10 +173,12 @@ otx_ep_setup_oq_regs(struct otx_ep_device *otx_ep, uint32_t oq_no)
 
 	reg_val = rte_read64(otx_ep->hw_addr + OTX_EP_R_OUT_CONTROL(oq_no));
 
-	while (!(reg_val & OTX_EP_R_OUT_CTL_IDLE)) {
+	while (!(reg_val & OTX_EP_R_OUT_CTL_IDLE) && loop--) {
 		reg_val = rte_read64(otx_ep->hw_addr +
 				      OTX_EP_R_OUT_CONTROL(oq_no));
 	}
+	if (loop < 0)
+		return -EIO;
 
 	otx_ep_write64(droq->desc_ring_dma, otx_ep->hw_addr,
 		       OTX_EP_R_OUT_SLIST_BADDR(oq_no));
@@ -180,11 +205,14 @@ otx_ep_setup_oq_regs(struct otx_ep_device *otx_ep, uint32_t oq_no)
 		       OTX_EP_R_OUT_INT_LEVELS(oq_no));
 
 	/* Clear the OQ doorbell  */
+	loop = OTX_EP_BUSY_LOOP_COUNT;
 	rte_write32(OTX_EP_CLEAR_SLIST_DBELL, droq->pkts_credit_reg);
-	while ((rte_read32(droq->pkts_credit_reg) != 0ull)) {
+	while ((rte_read32(droq->pkts_credit_reg) != 0ull) && loop--) {
 		rte_write32(OTX_EP_CLEAR_SLIST_DBELL, droq->pkts_credit_reg);
 		rte_delay_ms(1);
 	}
+	if (loop < 0)
+		return -EIO;
 	otx_ep_dbg("OTX_EP_R[%d]_credit:%x\n", oq_no,
 		     rte_read32(droq->pkts_credit_reg));
 
@@ -195,18 +223,23 @@ otx_ep_setup_oq_regs(struct otx_ep_device *otx_ep, uint32_t oq_no)
 	otx_ep_dbg("OTX_EP_R[%d]_sent: %x\n", oq_no,
 		     rte_read32(droq->pkts_sent_reg));
 
-	while (((rte_read32(droq->pkts_sent_reg)) != 0ull)) {
+	loop = OTX_EP_BUSY_LOOP_COUNT;
+	while (((rte_read32(droq->pkts_sent_reg)) != 0ull) && loop--) {
 		reg_val = rte_read32(droq->pkts_sent_reg);
 		rte_write32((uint32_t)reg_val, droq->pkts_sent_reg);
 		rte_delay_ms(1);
 	}
+	if (loop < 0)
+		return -EIO;
+
+	return 0;
 }
 
 static int
 otx_ep_enable_iq(struct otx_ep_device *otx_ep, uint32_t q_no)
 {
-	uint64_t loop = OTX_EP_BUSY_LOOP_COUNT;
-	uint64_t reg_val = 0ull;
+	volatile uint64_t reg_val = 0ull;
+	int loop = OTX_EP_BUSY_LOOP_COUNT;
 
 	/* Resetting doorbells during IQ enabling also to handle abrupt
 	 * guest reboot. IQ reset does not clear the doorbells.
@@ -219,7 +252,7 @@ otx_ep_enable_iq(struct otx_ep_device *otx_ep, uint32_t q_no)
 		rte_delay_ms(1);
 	}
 
-	if (loop == 0) {
+	if (loop < 0) {
 		otx_ep_err("dbell reset failed\n");
 		return -EIO;
 	}
@@ -238,8 +271,8 @@ otx_ep_enable_iq(struct otx_ep_device *otx_ep, uint32_t q_no)
 static int
 otx_ep_enable_oq(struct otx_ep_device *otx_ep, uint32_t q_no)
 {
-	uint64_t reg_val = 0ull;
-	uint64_t loop = OTX_EP_BUSY_LOOP_COUNT;
+	volatile uint64_t reg_val = 0ull;
+	int loop = OTX_EP_BUSY_LOOP_COUNT;
 
 	/* Resetting doorbells during IQ enabling also to handle abrupt
 	 * guest reboot. IQ reset does not clear the doorbells.
@@ -250,7 +283,8 @@ otx_ep_enable_oq(struct otx_ep_device *otx_ep, uint32_t q_no)
 		 OTX_EP_R_OUT_SLIST_DBELL(q_no))) != 0ull) && loop--) {
 		rte_delay_ms(1);
 	}
-	if (loop == 0) {
+
+	if (loop < 0) {
 		otx_ep_err("dbell reset failed\n");
 		return -EIO;
 	}
diff --git a/drivers/net/octeon_ep/otx_ep_vf.h b/drivers/net/octeon_ep/otx_ep_vf.h
index 1c98e626056ce..d38850b222285 100644
--- a/drivers/net/octeon_ep/otx_ep_vf.h
+++ b/drivers/net/octeon_ep/otx_ep_vf.h
@@ -89,6 +89,10 @@
 #define OTX_EP_R_OUT_CTL_IMODE        (1ull << 23)
 
 #define PCI_DEVID_OCTEONTX_EP_VF 0xa303
+static inline int is_otx_ep_vf(uint16_t chip_id)
+{
+	return (chip_id == PCI_DEVID_OCTEONTX_EP_VF);
+}
 
 /* this is a static value set by SLI PF driver in octeon
  * No handshake is available
diff --git a/lib/ethdev/rte_ethdev.h b/lib/ethdev/rte_ethdev.h
index c129ca1eaf938..96d0650d0c8b0 100644
--- a/lib/ethdev/rte_ethdev.h
+++ b/lib/ethdev/rte_ethdev.h
@@ -1502,7 +1502,10 @@ struct rte_eth_conf {
 #define RTE_ETH_RX_OFFLOAD_MACSEC_STRIP     RTE_BIT64(7)
 #define RTE_ETH_RX_OFFLOAD_VLAN_FILTER      RTE_BIT64(9)
 #define RTE_ETH_RX_OFFLOAD_VLAN_EXTEND      RTE_BIT64(10)
+#define RTE_ETH_RX_OFFLOAD_JUMBO_FRAME      RTE_BIT64(11)
+#define DEV_RX_OFFLOAD_JUMBO_FRAME          RTE_ETH_RX_OFFLOAD_JUMBO_FRAME
 #define RTE_ETH_RX_OFFLOAD_SCATTER          RTE_BIT64(13)
+#define DEV_RX_OFFLOAD_SCATTER              RTE_ETH_RX_OFFLOAD_SCATTER
 /**
  * Timestamp is set by the driver in RTE_MBUF_DYNFIELD_TIMESTAMP_NAME
  * and RTE_MBUF_DYNFLAG_RX_TIMESTAMP_NAME is set in ol_flags.
@@ -1553,6 +1556,7 @@ struct rte_eth_conf {
 #define RTE_ETH_TX_OFFLOAD_MT_LOCKFREE      RTE_BIT64(14)
 /** Device supports multi segment send. */
 #define RTE_ETH_TX_OFFLOAD_MULTI_SEGS       RTE_BIT64(15)
+#define DEV_TX_OFFLOAD_MULTI_SEGS           RTE_ETH_TX_OFFLOAD_MULTI_SEGS
 /**
  * Device supports optimization for fast release of mbufs.
  * When set application must guarantee that per-queue all mbufs comes from
-- 
2.25.1

