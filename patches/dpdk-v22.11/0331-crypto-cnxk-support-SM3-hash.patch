From e14fd3b5694c382316d2cdd72f1931d1d3dd8481 Mon Sep 17 00:00:00 2001
From: Vidya Sagar Velumuri <vvelumuri@marvell.com>
Date: Fri, 17 Mar 2023 03:35:16 -0700
Subject: [PATCH 331/955] crypto/cnxk: support SM3 hash

Add support for SM3 hash operations

Signed-off-by: Vidya Sagar Velumuri <vvelumuri@marvell.com>
Change-Id: Ic414e8aff5770c5401135c7269de32d8bd22057d
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/99680
Base-Builds: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Base-Tests: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Reviewed-by: Anoob Joseph <anoobj@marvell.com>
---
 doc/guides/cryptodevs/cnxk.rst                |  1 +
 doc/guides/cryptodevs/features/cn10k.ini      |  1 +
 drivers/common/cnxk/roc_se.h                  |  1 +
 drivers/crypto/cnxk/cnxk_cryptodev.h          |  2 +-
 .../crypto/cnxk/cnxk_cryptodev_capabilities.c | 32 +++++++++++++++++++
 drivers/crypto/cnxk/cnxk_cryptodev_ops.c      |  2 +-
 drivers/crypto/cnxk/cnxk_se.h                 | 12 ++++++-
 7 files changed, 48 insertions(+), 3 deletions(-)

diff --git a/doc/guides/cryptodevs/cnxk.rst b/doc/guides/cryptodevs/cnxk.rst
index 3c2e38fefdef1..991bbc2f99ef9 100644
--- a/doc/guides/cryptodevs/cnxk.rst
+++ b/doc/guides/cryptodevs/cnxk.rst
@@ -72,6 +72,7 @@ Hash algorithms:
 * ``RTE_CRYPTO_AUTH_SNOW3G_UIA2``
 * ``RTE_CRYPTO_AUTH_ZUC_EIA3``
 * ``RTE_CRYPTO_AUTH_AES_CMAC``
+* ``RTE_CRYPTO_AUTH_SM3``
 
 AEAD algorithms:
 
diff --git a/doc/guides/cryptodevs/features/cn10k.ini b/doc/guides/cryptodevs/features/cn10k.ini
index 162d1a25ca490..f18b7f3d768d4 100644
--- a/doc/guides/cryptodevs/features/cn10k.ini
+++ b/doc/guides/cryptodevs/features/cn10k.ini
@@ -73,6 +73,7 @@ SHA3_512        = Y
 SHA3_512 HMAC   = Y
 SHAKE_128       = Y
 SHAKE_256       = Y
+SM3             = Y
 
 ;
 ; Supported AEAD algorithms of 'cn10k' crypto driver.
diff --git a/drivers/common/cnxk/roc_se.h b/drivers/common/cnxk/roc_se.h
index 7771f22c6683d..1495088915884 100644
--- a/drivers/common/cnxk/roc_se.h
+++ b/drivers/common/cnxk/roc_se.h
@@ -81,6 +81,7 @@ typedef enum {
 	ROC_SE_SHA2_SHA512 = 6,
 	ROC_SE_GMAC_TYPE = 7,
 	ROC_SE_POLY1305 = 8,
+	ROC_SE_SM3 = 9,
 	ROC_SE_SHA3_SHA224 = 10,
 	ROC_SE_SHA3_SHA256 = 11,
 	ROC_SE_SHA3_SHA384 = 12,
diff --git a/drivers/crypto/cnxk/cnxk_cryptodev.h b/drivers/crypto/cnxk/cnxk_cryptodev.h
index 32dec70264f96..ce45f5d01b4c9 100644
--- a/drivers/crypto/cnxk/cnxk_cryptodev.h
+++ b/drivers/crypto/cnxk/cnxk_cryptodev.h
@@ -10,7 +10,7 @@
 
 #include "roc_cpt.h"
 
-#define CNXK_CPT_MAX_CAPS	 48
+#define CNXK_CPT_MAX_CAPS	 49
 #define CNXK_SEC_CRYPTO_MAX_CAPS 16
 #define CNXK_SEC_MAX_CAPS	 9
 #define CNXK_AE_EC_ID_MAX	 8
diff --git a/drivers/crypto/cnxk/cnxk_cryptodev_capabilities.c b/drivers/crypto/cnxk/cnxk_cryptodev_capabilities.c
index 19956ffa076a0..0b02cea308221 100644
--- a/drivers/crypto/cnxk/cnxk_cryptodev_capabilities.c
+++ b/drivers/crypto/cnxk/cnxk_cryptodev_capabilities.c
@@ -337,6 +337,29 @@ static const struct rte_cryptodev_capabilities caps_sha1_sha2[] = {
 	},
 };
 
+static const struct rte_cryptodev_capabilities caps_sm3[] = {
+	{	/* SM3 */
+		.op = RTE_CRYPTO_OP_TYPE_SYMMETRIC,
+		{.sym = {
+			.xform_type = RTE_CRYPTO_SYM_XFORM_AUTH,
+			{.auth = {
+				.algo = RTE_CRYPTO_AUTH_SM3,
+				.block_size = 64,
+				.key_size = {
+					.min = 0,
+					.max = 0,
+					.increment = 0
+				},
+				.digest_size = {
+					.min = 32,
+					.max = 32,
+					.increment = 0
+				},
+			}, }
+		}, }
+	}
+};
+
 static const struct rte_cryptodev_capabilities caps_sha3[] = {
 	{	/* SHA3_224 */
 		.op = RTE_CRYPTO_OP_TYPE_SYMMETRIC,
@@ -1459,6 +1482,12 @@ cn9k_crypto_caps_add(struct rte_cryptodev_capabilities cnxk_caps[], int *cur_pos
 	    cpt_caps_add(cnxk_caps, cur_pos, caps_docsis, RTE_DIM(caps_docsis));
 }
 
+static void
+cn10k_crypto_caps_add(struct rte_cryptodev_capabilities cnxk_caps[], int *cur_pos)
+{
+	cpt_caps_add(cnxk_caps, cur_pos, caps_sm3, RTE_DIM(caps_sm3));
+}
+
 static void
 crypto_caps_populate(struct rte_cryptodev_capabilities cnxk_caps[],
 		     union cpt_eng_caps *hw_caps)
@@ -1477,6 +1506,9 @@ crypto_caps_populate(struct rte_cryptodev_capabilities cnxk_caps[],
 	if (!roc_model_is_cn10k())
 		cn9k_crypto_caps_add(cnxk_caps, &cur_pos);
 
+	if (roc_model_is_cn10k())
+		cn10k_crypto_caps_add(cnxk_caps, &cur_pos);
+
 	cpt_caps_add(cnxk_caps, &cur_pos, caps_null, RTE_DIM(caps_null));
 	cpt_caps_add(cnxk_caps, &cur_pos, caps_end, RTE_DIM(caps_end));
 
diff --git a/drivers/crypto/cnxk/cnxk_cryptodev_ops.c b/drivers/crypto/cnxk/cnxk_cryptodev_ops.c
index dd35ee127838c..649b5754c86d4 100644
--- a/drivers/crypto/cnxk/cnxk_cryptodev_ops.c
+++ b/drivers/crypto/cnxk/cnxk_cryptodev_ops.c
@@ -662,7 +662,7 @@ cnxk_cpt_inst_w7_get(struct cnxk_se_sess *sess, struct roc_cpt *roc_cpt)
 		inst_w7.s.cptr += 8;
 
 	/* Set the engine group */
-	if (sess->zsk_flag || sess->aes_ctr_eea2 || sess->is_sha3)
+	if (sess->zsk_flag || sess->aes_ctr_eea2 || sess->is_sha3 || sess->is_sm3)
 		inst_w7.s.egrp = roc_cpt->eng_grp[CPT_ENG_TYPE_SE];
 	else
 		inst_w7.s.egrp = roc_cpt->eng_grp[CPT_ENG_TYPE_IE];
diff --git a/drivers/crypto/cnxk/cnxk_se.h b/drivers/crypto/cnxk/cnxk_se.h
index d780bdaede77f..34dd549b279c6 100644
--- a/drivers/crypto/cnxk/cnxk_se.h
+++ b/drivers/crypto/cnxk/cnxk_se.h
@@ -44,7 +44,8 @@ struct cnxk_se_sess {
 	uint16_t aad_length;
 	uint8_t is_sha3 : 1;
 	uint8_t short_iv : 1;
-	uint8_t rsvd : 6;
+	uint8_t is_sm3 : 1;
+	uint8_t rsvd : 5;
 	uint8_t mac_len;
 	uint8_t iv_length;
 	uint8_t auth_iv_length;
@@ -199,6 +200,9 @@ cpt_mac_len_verify(struct rte_crypto_auth_xform *auth)
 	case RTE_CRYPTO_AUTH_SHAKE_256:
 		ret = (mac_len <= UINT8_MAX) ? 0 : -1;
 		break;
+	case RTE_CRYPTO_AUTH_SM3:
+		ret = (mac_len <= 32) ? 0 : -1;
+		break;
 	case RTE_CRYPTO_AUTH_NULL:
 		ret = 0;
 		break;
@@ -1999,6 +2003,7 @@ fill_sess_auth(struct rte_crypto_sym_xform *xform, struct cnxk_se_sess *sess)
 	uint8_t zsk_flag = 0, zs_auth = 0, aes_gcm = 0, is_null = 0, is_sha3 = 0;
 	struct rte_crypto_auth_xform *a_form;
 	roc_se_auth_type auth_type = 0; /* NULL Auth type */
+	uint8_t is_sm3 = 0;
 
 	if (xform->auth.algo == RTE_CRYPTO_AUTH_AES_GMAC)
 		return fill_sess_gmac(xform, sess);
@@ -2109,6 +2114,10 @@ fill_sess_auth(struct rte_crypto_sym_xform *xform, struct cnxk_se_sess *sess)
 		auth_type = ROC_SE_AES_CMAC_EIA2;
 		zsk_flag = ROC_SE_ZS_IA;
 		break;
+	case RTE_CRYPTO_AUTH_SM3:
+		auth_type = ROC_SE_SM3;
+		is_sm3 = 1;
+		break;
 	case RTE_CRYPTO_AUTH_AES_XCBC_MAC:
 	case RTE_CRYPTO_AUTH_AES_CBC_MAC:
 		plt_dp_err("Crypto: Unsupported hash algo %u", a_form->algo);
@@ -2136,6 +2145,7 @@ fill_sess_auth(struct rte_crypto_sym_xform *xform, struct cnxk_se_sess *sess)
 	sess->mac_len = a_form->digest_length;
 	sess->is_null = is_null;
 	sess->is_sha3 = is_sha3;
+	sess->is_sm3 = is_sm3;
 	if (zsk_flag) {
 		sess->auth_iv_offset = a_form->iv.offset;
 		sess->auth_iv_length = a_form->iv.length;
-- 
2.25.1

