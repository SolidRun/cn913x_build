From 14146b20a279af8aec3c89ef31f3fb7312a23b9a Mon Sep 17 00:00:00 2001
From: Pavan Nikhilesh <pbhagavatula@marvell.com>
Date: Tue, 13 Dec 2022 22:34:44 +0530
Subject: [PATCH 081/955] common/cnxk: remove unnecessary locks

Remove unnecessary locks as locking is now taken care by
mbox_get and mbox_put.

Signed-off-by: Pavan Nikhilesh <pbhagavatula@marvell.com>
Change-Id: I40f53eb46536cd4363e3c8b17ab84a4167dc79d5
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/92514
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Reviewed-by: Jerin Jacob Kollanukkaran <jerinj@marvell.com>
---
 drivers/common/cnxk/roc_sso.c      | 27 ---------------------------
 drivers/common/cnxk/roc_sso_priv.h |  1 -
 2 files changed, 28 deletions(-)

diff --git a/drivers/common/cnxk/roc_sso.c b/drivers/common/cnxk/roc_sso.c
index 123bef2cb9db6..9c92580d4de07 100644
--- a/drivers/common/cnxk/roc_sso.c
+++ b/drivers/common/cnxk/roc_sso.c
@@ -327,7 +327,6 @@ roc_sso_hws_stats_get(struct roc_sso *roc_sso, uint8_t hws,
 	struct mbox *mbox;
 	int rc;
 
-	plt_spinlock_lock(&sso->mbox_lock);
 	mbox = mbox_get(dev->mbox);
 	req_rsp = (struct sso_hws_stats *)mbox_alloc_msg_sso_hws_get_stats(
 		mbox);
@@ -354,7 +353,6 @@ roc_sso_hws_stats_get(struct roc_sso *roc_sso, uint8_t hws,
 	stats->arbitration = req_rsp->arbitration;
 fail:
 	mbox_put(mbox);
-	plt_spinlock_unlock(&sso->mbox_lock);
 	return rc;
 }
 
@@ -368,7 +366,6 @@ roc_sso_hwgrp_stats_get(struct roc_sso *roc_sso, uint8_t hwgrp,
 	struct mbox *mbox;
 	int rc;
 
-	plt_spinlock_lock(&sso->mbox_lock);
 	mbox = mbox_get(dev->mbox);
 	req_rsp = (struct sso_grp_stats *)mbox_alloc_msg_sso_grp_get_stats(
 		mbox);
@@ -403,7 +400,6 @@ roc_sso_hwgrp_stats_get(struct roc_sso *roc_sso, uint8_t hwgrp,
 
 fail:
 	mbox_put(mbox);
-	plt_spinlock_unlock(&sso->mbox_lock);
 	return rc;
 }
 
@@ -430,7 +426,6 @@ roc_sso_hwgrp_qos_config(struct roc_sso *roc_sso, struct roc_sso_hwgrp_qos *qos,
 	if (!nb_qos)
 		return 0;
 
-	plt_spinlock_lock(&sso->mbox_lock);
 	mbox = mbox_get(dev->mbox);
 	for (i = 0; i < nb_qos; i++) {
 		uint8_t iaq_prcnt = qos[i].iaq_prcnt;
@@ -464,7 +459,6 @@ roc_sso_hwgrp_qos_config(struct roc_sso *roc_sso, struct roc_sso_hwgrp_qos *qos,
 		rc = -EIO;
 fail:
 	mbox_put(mbox);
-	plt_spinlock_unlock(&sso->mbox_lock);
 	return rc;
 }
 
@@ -565,11 +559,9 @@ roc_sso_hwgrp_init_xaq_aura(struct roc_sso *roc_sso, uint32_t nb_xae)
 	struct dev *dev = &sso->dev;
 	int rc;
 
-	plt_spinlock_lock(&sso->mbox_lock);
 	rc = sso_hwgrp_init_xaq_aura(dev, &roc_sso->xaq, nb_xae,
 				     roc_sso->xae_waes, roc_sso->xaq_buf_size,
 				     roc_sso->nb_hwgrp);
-	plt_spinlock_unlock(&sso->mbox_lock);
 	return rc;
 }
 
@@ -603,9 +595,7 @@ roc_sso_hwgrp_free_xaq_aura(struct roc_sso *roc_sso, uint16_t nb_hwgrp)
 	struct dev *dev = &sso->dev;
 	int rc;
 
-	plt_spinlock_lock(&sso->mbox_lock);
 	rc = sso_hwgrp_free_xaq_aura(dev, &roc_sso->xaq, nb_hwgrp);
-	plt_spinlock_unlock(&sso->mbox_lock);
 	return rc;
 }
 
@@ -642,9 +632,7 @@ roc_sso_hwgrp_alloc_xaq(struct roc_sso *roc_sso, uint32_t npa_aura_id,
 	struct dev *dev = &sso->dev;
 	int rc;
 
-	plt_spinlock_lock(&sso->mbox_lock);
 	rc = sso_hwgrp_alloc_xaq(dev, npa_aura_id, hwgrps);
-	plt_spinlock_unlock(&sso->mbox_lock);
 	return rc;
 }
 
@@ -680,9 +668,7 @@ roc_sso_hwgrp_release_xaq(struct roc_sso *roc_sso, uint16_t hwgrps)
 	struct dev *dev = &sso->dev;
 	int rc;
 
-	plt_spinlock_lock(&sso->mbox_lock);
 	rc = sso_hwgrp_release_xaq(dev, hwgrps);
-	plt_spinlock_unlock(&sso->mbox_lock);
 	return rc;
 }
 
@@ -696,7 +682,6 @@ roc_sso_hwgrp_set_priority(struct roc_sso *roc_sso, uint16_t hwgrp,
 	struct mbox *mbox;
 	int rc = -ENOSPC;
 
-	plt_spinlock_lock(&sso->mbox_lock);
 	mbox = mbox_get(dev->mbox);
 	req = mbox_alloc_msg_sso_grp_set_priority(mbox);
 	if (req == NULL)
@@ -712,14 +697,12 @@ roc_sso_hwgrp_set_priority(struct roc_sso *roc_sso, uint16_t hwgrp,
 		goto fail;
 	}
 	mbox_put(mbox);
-	plt_spinlock_unlock(&sso->mbox_lock);
 	plt_sso_dbg("HWGRP %d weight %d affinity %d priority %d", hwgrp, weight,
 		    affinity, priority);
 
 	return 0;
 fail:
 	mbox_put(mbox);
-	plt_spinlock_unlock(&sso->mbox_lock);
 	return rc;
 }
 
@@ -736,7 +719,6 @@ roc_sso_hwgrp_stash_config(struct roc_sso *roc_sso,
 	if (!nb_stash)
 		return 0;
 
-	plt_spinlock_lock(&sso->mbox_lock);
 	mbox = mbox_get(dev->mbox);
 	for (i = 0; i < nb_stash; i++) {
 		req = mbox_alloc_msg_sso_grp_stash_config(mbox);
@@ -764,7 +746,6 @@ roc_sso_hwgrp_stash_config(struct roc_sso *roc_sso,
 		rc = -EIO;
 fail:
 	mbox_put(mbox);
-	plt_spinlock_unlock(&sso->mbox_lock);
 	return rc;
 }
 
@@ -826,7 +807,6 @@ roc_sso_rsrc_init(struct roc_sso *roc_sso, uint8_t nb_hws, uint16_t nb_hwgrp, ui
 	if (!nb_hws || roc_sso->max_hws < nb_hws)
 		return -ENOENT;
 
-	plt_spinlock_lock(&sso->mbox_lock);
 	rc = sso_rsrc_attach(roc_sso, SSO_LF_TYPE_HWS, nb_hws);
 	if (rc < 0) {
 		plt_err("Unable to attach SSO HWS LFs");
@@ -893,7 +873,6 @@ roc_sso_rsrc_init(struct roc_sso *roc_sso, uint8_t nb_hws, uint16_t nb_hwgrp, ui
 		goto sso_msix_fail;
 	}
 
-	plt_spinlock_unlock(&sso->mbox_lock);
 	roc_sso->nb_hwgrp = nb_hwgrp;
 	roc_sso->nb_hws = nb_hws;
 
@@ -907,7 +886,6 @@ roc_sso_rsrc_init(struct roc_sso *roc_sso, uint8_t nb_hws, uint16_t nb_hwgrp, ui
 hwgrp_atch_fail:
 	sso_rsrc_detach(roc_sso, SSO_LF_TYPE_HWS);
 fail:
-	plt_spinlock_unlock(&sso->mbox_lock);
 	return rc;
 }
 
@@ -929,7 +907,6 @@ roc_sso_rsrc_fini(struct roc_sso *roc_sso)
 
 	roc_sso->nb_hwgrp = 0;
 	roc_sso->nb_hws = 0;
-	plt_spinlock_unlock(&sso->mbox_lock);
 }
 
 int
@@ -948,7 +925,6 @@ roc_sso_dev_init(struct roc_sso *roc_sso)
 	sso = roc_sso_to_sso_priv(roc_sso);
 	memset(sso, 0, sizeof(*sso));
 	pci_dev = roc_sso->pci_dev;
-	plt_spinlock_init(&sso->mbox_lock);
 
 	rc = sso_update_msix_vec_count(roc_sso, 0);
 	if (rc < 0) {
@@ -962,7 +938,6 @@ roc_sso_dev_init(struct roc_sso *roc_sso)
 		goto fail;
 	}
 
-	plt_spinlock_lock(&sso->mbox_lock);
 	rc = sso_rsrc_get(roc_sso);
 	if (rc < 0) {
 		plt_err("Failed to get SSO resources");
@@ -1004,7 +979,6 @@ roc_sso_dev_init(struct roc_sso *roc_sso)
 	sso->pci_dev = pci_dev;
 	sso->dev.drv_inited = true;
 	roc_sso->lmt_base = sso->dev.lmt_base;
-	plt_spinlock_unlock(&sso->mbox_lock);
 
 	return 0;
 link_mem_free:
@@ -1012,7 +986,6 @@ roc_sso_dev_init(struct roc_sso *roc_sso)
 rsrc_fail:
 	rc |= dev_fini(&sso->dev, pci_dev);
 fail:
-	plt_spinlock_unlock(&sso->mbox_lock);
 	return rc;
 }
 
diff --git a/drivers/common/cnxk/roc_sso_priv.h b/drivers/common/cnxk/roc_sso_priv.h
index 674e4e0a39a79..09729d4f62877 100644
--- a/drivers/common/cnxk/roc_sso_priv.h
+++ b/drivers/common/cnxk/roc_sso_priv.h
@@ -22,7 +22,6 @@ struct sso {
 	/* SSO link mapping. */
 	struct plt_bitmap **link_map;
 	void *link_map_mem;
-	plt_spinlock_t mbox_lock;
 } __plt_cache_aligned;
 
 enum sso_err_status {
-- 
2.25.1

