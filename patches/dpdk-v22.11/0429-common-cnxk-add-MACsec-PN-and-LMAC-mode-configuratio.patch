From 86d50ea7ca917136d014947a1303bded10c2c4de Mon Sep 17 00:00:00 2001
From: Akhil Goyal <gakhil@marvell.com>
Date: Fri, 19 May 2023 00:25:16 +0530
Subject: [PATCH 429/955] common/cnxk: add MACsec PN and LMAC mode
 configuration

Added ROC APIs for setting packet number and LMAC
related configurations.

Signed-off-by: Ankur Dwivedi <adwivedi@marvell.com>
Signed-off-by: Vamsi Attunuru <vattunuru@marvell.com>
Signed-off-by: Akhil Goyal <gakhil@marvell.com>
Change-Id: I5f2e9e9f243b1341a7b174a1813cdf2a604b9cdd
---
 drivers/common/cnxk/roc_mbox.h        | 56 +++++++++++++++++++++
 drivers/common/cnxk/roc_mcs.c         | 71 +++++++++++++++++++++++++++
 drivers/common/cnxk/roc_mcs.h         | 48 ++++++++++++++++++
 drivers/common/cnxk/roc_mcs_sec_cfg.c | 31 ++++++++++++
 drivers/common/cnxk/version.map       |  5 ++
 5 files changed, 211 insertions(+)

diff --git a/drivers/common/cnxk/roc_mbox.h b/drivers/common/cnxk/roc_mbox.h
index fcfcc90f6c6e4..6f7eaae909094 100644
--- a/drivers/common/cnxk/roc_mbox.h
+++ b/drivers/common/cnxk/roc_mbox.h
@@ -308,7 +308,11 @@ struct mbox_msghdr {
 	M(MCS_TX_SC_SA_MAP_WRITE, 0xa006, mcs_tx_sc_sa_map_write, mcs_tx_sc_sa_map, msg_rsp)       \
 	M(MCS_RX_SC_SA_MAP_WRITE, 0xa007, mcs_rx_sc_sa_map_write, mcs_rx_sc_sa_map, msg_rsp)       \
 	M(MCS_FLOWID_ENA_ENTRY, 0xa008, mcs_flowid_ena_entry, mcs_flowid_ena_dis_entry, msg_rsp)   \
+	M(MCS_PN_TABLE_WRITE, 0xa009, mcs_pn_table_write, mcs_pn_table_write_req, msg_rsp)         \
+	M(MCS_SET_ACTIVE_LMAC, 0xa00a, mcs_set_active_lmac, mcs_set_active_lmac, msg_rsp)          \
 	M(MCS_GET_HW_INFO, 0xa00b, mcs_get_hw_info, msg_req, mcs_hw_info)                          \
+	M(MCS_SET_LMAC_MODE, 0xa013, mcs_set_lmac_mode, mcs_set_lmac_mode, msg_rsp)                \
+	M(MCS_SET_PN_THRESHOLD, 0xa014, mcs_set_pn_threshold, mcs_set_pn_threshold, msg_rsp)       \
 
 /* Messages initiated by AF (range 0xC00 - 0xDFF) */
 #define MBOX_UP_CGX_MESSAGES                                                   \
@@ -812,6 +816,34 @@ struct mcs_flowid_ena_dis_entry {
 	uint64_t __io rsvd;
 };
 
+struct mcs_pn_table_write_req {
+	struct mbox_msghdr hdr;
+	uint64_t __io next_pn;
+	uint8_t __io pn_id;
+	uint8_t __io mcs_id;
+	uint8_t __io dir;
+	uint64_t __io rsvd;
+};
+
+struct mcs_cam_entry_read_req {
+	struct mbox_msghdr hdr;
+	uint8_t __io rsrc_type; /* TCAM/SECY/SC/SA/PN */
+	uint8_t __io rsrc_id;
+	uint8_t __io mcs_id;
+	uint8_t __io dir;
+	uint64_t __io rsvd;
+};
+
+struct mcs_cam_entry_read_rsp {
+	struct mbox_msghdr hdr;
+	uint64_t __io reg_val[10];
+	uint8_t __io rsrc_type;
+	uint8_t __io rsrc_id;
+	uint8_t __io mcs_id;
+	uint8_t __io dir;
+	uint64_t __io rsvd;
+};
+
 struct mcs_hw_info {
 	struct mbox_msghdr hdr;
 	uint8_t __io num_mcs_blks; /* Number of MCS blocks */
@@ -822,6 +854,30 @@ struct mcs_hw_info {
 	uint64_t __io rsvd[16];
 };
 
+struct mcs_set_active_lmac {
+	struct mbox_msghdr hdr;
+	uint32_t __io lmac_bmap; /* bitmap of active lmac per mcs block */
+	uint8_t __io mcs_id;
+	uint16_t channel_base; /* MCS channel base */
+	uint64_t __io rsvd;
+};
+
+struct mcs_set_lmac_mode {
+	struct mbox_msghdr hdr;
+	uint8_t __io mode; /* '1' for internal bypass mode (passthrough), '0' for MCS processing */
+	uint8_t __io lmac_id;
+	uint8_t __io mcs_id;
+	uint64_t __io rsvd;
+};
+
+struct mcs_set_pn_threshold {
+	struct mbox_msghdr hdr;
+	uint64_t __io threshold;
+	uint8_t __io xpn; /* '1' for setting xpn threshold */
+	uint8_t __io mcs_id;
+	uint8_t __io dir;
+	uint64_t __io rsvd;
+};
 
 /* NPA mbox message formats */
 
diff --git a/drivers/common/cnxk/roc_mcs.c b/drivers/common/cnxk/roc_mcs.c
index ce92a6cd470e4..b15933d362971 100644
--- a/drivers/common/cnxk/roc_mcs.c
+++ b/drivers/common/cnxk/roc_mcs.c
@@ -42,6 +42,77 @@ roc_mcs_hw_info_get(struct roc_mcs_hw_info *hw_info)
 	return rc;
 }
 
+int
+roc_mcs_active_lmac_set(struct roc_mcs *mcs, struct roc_mcs_set_active_lmac *lmac)
+{
+	struct mcs_set_active_lmac *req;
+	struct msg_rsp *rsp;
+
+	/* Only needed for 105N */
+	if (!roc_model_is_cnf10kb())
+		return 0;
+
+	if (lmac == NULL)
+		return -EINVAL;
+
+	MCS_SUPPORT_CHECK;
+
+	req = mbox_alloc_msg_mcs_set_active_lmac(mcs->mbox);
+	if (req == NULL)
+		return -ENOMEM;
+
+	req->lmac_bmap = lmac->lmac_bmap;
+	req->channel_base = lmac->channel_base;
+	req->mcs_id = mcs->idx;
+
+	return mbox_process_msg(mcs->mbox, (void *)&rsp);
+}
+
+int
+roc_mcs_lmac_mode_set(struct roc_mcs *mcs, struct roc_mcs_set_lmac_mode *port)
+{
+	struct mcs_set_lmac_mode *req;
+	struct msg_rsp *rsp;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	MCS_SUPPORT_CHECK;
+
+	req = mbox_alloc_msg_mcs_set_lmac_mode(mcs->mbox);
+	if (req == NULL)
+		return -ENOMEM;
+
+	req->lmac_id = port->lmac_id;
+	req->mcs_id = mcs->idx;
+	req->mode = port->mode;
+
+	return mbox_process_msg(mcs->mbox, (void *)&rsp);
+}
+
+int
+roc_mcs_pn_threshold_set(struct roc_mcs *mcs, struct roc_mcs_set_pn_threshold *pn)
+{
+	struct mcs_set_pn_threshold *req;
+	struct msg_rsp *rsp;
+
+	if (pn == NULL)
+		return -EINVAL;
+
+	MCS_SUPPORT_CHECK;
+
+	req = mbox_alloc_msg_mcs_set_pn_threshold(mcs->mbox);
+	if (req == NULL)
+		return -ENOMEM;
+
+	req->threshold = pn->threshold;
+	req->mcs_id = mcs->idx;
+	req->dir = pn->dir;
+	req->xpn = pn->xpn;
+
+	return mbox_process_msg(mcs->mbox, (void *)&rsp);
+}
+
 static int
 mcs_alloc_bmap(uint16_t entries, void **mem, struct plt_bitmap **bmap)
 {
diff --git a/drivers/common/cnxk/roc_mcs.h b/drivers/common/cnxk/roc_mcs.h
index 7e0a98e91a8d2..a51ee21278b30 100644
--- a/drivers/common/cnxk/roc_mcs.h
+++ b/drivers/common/cnxk/roc_mcs.h
@@ -88,6 +88,25 @@ struct roc_mcs_flowid_ena_dis_entry {
 	uint8_t dir;
 };
 
+struct roc_mcs_pn_table_write_req {
+	uint64_t next_pn;
+	uint8_t pn_id;
+	uint8_t dir;
+};
+
+struct roc_mcs_cam_entry_read_req {
+	uint8_t rsrc_type; /* TCAM/SECY/SC/SA/PN */
+	uint8_t rsrc_id;
+	uint8_t dir;
+};
+
+struct roc_mcs_cam_entry_read_rsp {
+	uint64_t reg_val[10];
+	uint8_t rsrc_type;
+	uint8_t rsrc_id;
+	uint8_t dir;
+};
+
 struct roc_mcs_hw_info {
 	uint8_t num_mcs_blks; /* Number of MCS blocks */
 	uint8_t tcam_entries; /* RX/TX Tcam entries per mcs block */
@@ -97,6 +116,24 @@ struct roc_mcs_hw_info {
 	uint64_t rsvd[16];
 };
 
+struct roc_mcs_set_lmac_mode {
+	uint8_t mode; /* '1' for internal bypass mode (passthrough), '0' for MCS processing */
+	uint8_t lmac_id;
+	uint64_t rsvd;
+};
+
+struct roc_mcs_set_active_lmac {
+	uint32_t lmac_bmap;    /* bitmap of active lmac per mcs block */
+	uint16_t channel_base; /* MCS channel base */
+	uint64_t rsvd;
+};
+
+struct roc_mcs_set_pn_threshold {
+	uint64_t threshold;
+	uint8_t xpn; /* '1' for setting xpn threshold */
+	uint8_t dir;
+	uint64_t rsvd;
+};
 
 struct roc_mcs {
 	TAILQ_ENTRY(roc_mcs) next;
@@ -117,6 +154,12 @@ __roc_api void roc_mcs_dev_fini(struct roc_mcs *mcs);
 __roc_api struct roc_mcs *roc_mcs_dev_get(uint8_t mcs_idx);
 /* HW info get */
 __roc_api int roc_mcs_hw_info_get(struct roc_mcs_hw_info *hw_info);
+/* Active lmac bmap set */
+__roc_api int roc_mcs_active_lmac_set(struct roc_mcs *mcs, struct roc_mcs_set_active_lmac *lmac);
+/* Port bypass mode set */
+__roc_api int roc_mcs_lmac_mode_set(struct roc_mcs *mcs, struct roc_mcs_set_lmac_mode *port);
+/* (X)PN threshold set */
+__roc_api int roc_mcs_pn_threshold_set(struct roc_mcs *mcs, struct roc_mcs_set_pn_threshold *pn);
 
 /* Resource allocation and free */
 __roc_api int roc_mcs_alloc_rsrc(struct roc_mcs *mcs, struct roc_mcs_alloc_rsrc_req *req,
@@ -127,6 +170,11 @@ __roc_api int roc_mcs_sa_policy_write(struct roc_mcs *mcs,
 				      struct roc_mcs_sa_plcy_write_req *sa_plcy);
 __roc_api int roc_mcs_sa_policy_read(struct roc_mcs *mcs,
 				     struct roc_mcs_sa_plcy_write_req *sa_plcy);
+/* PN Table read and write */
+__roc_api int roc_mcs_pn_table_write(struct roc_mcs *mcs,
+				     struct roc_mcs_pn_table_write_req *pn_table);
+__roc_api int roc_mcs_pn_table_read(struct roc_mcs *mcs,
+				    struct roc_mcs_pn_table_write_req *pn_table);
 /* RX SC read, write and enable */
 __roc_api int roc_mcs_rx_sc_cam_write(struct roc_mcs *mcs,
 				      struct roc_mcs_rx_sc_cam_write_req *rx_sc_cam);
diff --git a/drivers/common/cnxk/roc_mcs_sec_cfg.c b/drivers/common/cnxk/roc_mcs_sec_cfg.c
index 50369c73d74ab..99afb63904532 100644
--- a/drivers/common/cnxk/roc_mcs_sec_cfg.c
+++ b/drivers/common/cnxk/roc_mcs_sec_cfg.c
@@ -210,6 +210,37 @@ roc_mcs_sa_policy_read(struct roc_mcs *mcs __plt_unused,
 	return -ENOTSUP;
 }
 
+int
+roc_mcs_pn_table_write(struct roc_mcs *mcs, struct roc_mcs_pn_table_write_req *pn_table)
+{
+	struct mcs_pn_table_write_req *pn;
+	struct msg_rsp *rsp;
+
+	MCS_SUPPORT_CHECK;
+
+	if (pn_table == NULL)
+		return -EINVAL;
+
+	pn = mbox_alloc_msg_mcs_pn_table_write(mcs->mbox);
+	if (pn == NULL)
+		return -ENOMEM;
+
+	pn->next_pn = pn_table->next_pn;
+	pn->pn_id = pn_table->pn_id;
+	pn->mcs_id = mcs->idx;
+	pn->dir = pn_table->dir;
+
+	return mbox_process_msg(mcs->mbox, (void *)&rsp);
+}
+
+int
+roc_mcs_pn_table_read(struct roc_mcs *mcs __plt_unused,
+		      struct roc_mcs_pn_table_write_req *sa __plt_unused)
+{
+	MCS_SUPPORT_CHECK;
+
+	return -ENOTSUP;
+}
 
 int
 roc_mcs_rx_sc_cam_write(struct roc_mcs *mcs, struct roc_mcs_rx_sc_cam_write_req *rx_sc_cam)
diff --git a/drivers/common/cnxk/version.map b/drivers/common/cnxk/version.map
index 3e99bcea02369..f7414059fd284 100644
--- a/drivers/common/cnxk/version.map
+++ b/drivers/common/cnxk/version.map
@@ -105,6 +105,7 @@ INTERNAL {
 	roc_se_auth_key_set;
 	roc_se_ciph_key_set;
 	roc_se_ctx_init;
+	roc_mcs_active_lmac_set;
 	roc_mcs_alloc_rsrc;
 	roc_mcs_dev_init;
 	roc_mcs_dev_fini;
@@ -114,6 +115,10 @@ INTERNAL {
 	roc_mcs_flowid_entry_write;
 	roc_mcs_free_rsrc;
 	roc_mcs_hw_info_get;
+	roc_mcs_lmac_mode_set;
+	roc_mcs_pn_table_write;
+	roc_mcs_pn_table_read;
+	roc_mcs_pn_threshold_set;
 	roc_mcs_rx_sc_cam_enable;
 	roc_mcs_rx_sc_cam_read;
 	roc_mcs_rx_sc_cam_write;
-- 
2.25.1

