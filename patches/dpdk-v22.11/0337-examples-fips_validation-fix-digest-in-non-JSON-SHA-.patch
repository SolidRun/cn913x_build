From 217967ca7c9d822bf204e2fb31507ca5bdc4a676 Mon Sep 17 00:00:00 2001
From: Gowrishankar Muthukrishnan <gmuthukrishn@marvell.com>
Date: Fri, 24 Mar 2023 11:09:57 +0530
Subject: [PATCH 337/955] examples/fips_validation: fix digest in non JSON SHA
 MCT

Non JSON SHA MCT tests produce incorrect digest due to a regression
while handling MD blocks in common for all kind of SHA, SHA2, SHA3
and SHAKE algorithms. Fixing this along with some cleanup to use
only rte_malloc API for storing test vectors as in other tests.

Fixes: d8417b5ef4e ("examples/fips_validation: add SHA3 validation")

Signed-off-by: Gowrishankar Muthukrishnan <gmuthukrishn@marvell.com>
Change-Id: I8613bf50f3c45b76b6709d285bfa161d52ff184e
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/99857
Base-Builds: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Base-Tests: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Reviewed-by: Anoob Joseph <anoobj@marvell.com>
---
 .../fips_validation/fips_validation_sha.c     | 31 ++++++-----
 examples/fips_validation/main.c               | 53 +++++++++----------
 2 files changed, 42 insertions(+), 42 deletions(-)

diff --git a/examples/fips_validation/fips_validation_sha.c b/examples/fips_validation/fips_validation_sha.c
index 7ce7d3744fc05..e81bfecedaa57 100644
--- a/examples/fips_validation/fips_validation_sha.c
+++ b/examples/fips_validation/fips_validation_sha.c
@@ -7,6 +7,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 
+#include <rte_malloc.h>
 #include <rte_cryptodev.h>
 
 #include "fips_validation.h"
@@ -28,19 +29,20 @@
 
 struct plain_hash_size_conversion {
 	const char *str;
+	uint8_t md_blocks;
 	enum rte_crypto_auth_algorithm algo;
 } phsc[] = {
-		{"20", RTE_CRYPTO_AUTH_SHA1},
-		{"28", RTE_CRYPTO_AUTH_SHA224},
-		{"32", RTE_CRYPTO_AUTH_SHA256},
-		{"48", RTE_CRYPTO_AUTH_SHA384},
-		{"64", RTE_CRYPTO_AUTH_SHA512},
-		{"28", RTE_CRYPTO_AUTH_SHA3_224},
-		{"32", RTE_CRYPTO_AUTH_SHA3_256},
-		{"48", RTE_CRYPTO_AUTH_SHA3_384},
-		{"64", RTE_CRYPTO_AUTH_SHA3_512},
-		{"16", RTE_CRYPTO_AUTH_SHAKE_128},
-		{"32", RTE_CRYPTO_AUTH_SHAKE_256},
+		{"20", 3, RTE_CRYPTO_AUTH_SHA1},
+		{"28", 3, RTE_CRYPTO_AUTH_SHA224},
+		{"32", 3, RTE_CRYPTO_AUTH_SHA256},
+		{"48", 3, RTE_CRYPTO_AUTH_SHA384},
+		{"64", 3, RTE_CRYPTO_AUTH_SHA512},
+		{"28", 1, RTE_CRYPTO_AUTH_SHA3_224},
+		{"32", 1, RTE_CRYPTO_AUTH_SHA3_256},
+		{"48", 1, RTE_CRYPTO_AUTH_SHA3_384},
+		{"64", 1, RTE_CRYPTO_AUTH_SHA3_512},
+		{"16", 1, RTE_CRYPTO_AUTH_SHAKE_128},
+		{"32", 1, RTE_CRYPTO_AUTH_SHAKE_256},
 };
 
 int
@@ -69,6 +71,7 @@ parse_interim_algo(__rte_unused const char *key,
 	for (i = 0; i < RTE_DIM(phsc); i++) {
 		if (strstr(text, phsc[i].str)) {
 			info.interim_info.sha_data.algo = phsc[i].algo;
+			info.interim_info.sha_data.md_blocks = phsc[i].md_blocks;
 			parser_read_uint32_val(ALGO_PREFIX,
 				text, &vec.cipher_auth.digest);
 			break;
@@ -84,7 +87,7 @@ parse_interim_algo(__rte_unused const char *key,
 struct fips_test_callback sha_tests_vectors[] = {
 		{MSGLEN_STR, parser_read_uint32_bit_val, &vec.pt},
 		{MSG_STR, parse_uint8_known_len_hex_str, &vec.pt},
-		{SEED_STR, parse_uint8_hex_str, &vec.cipher_auth.digest},
+		{SEED_STR, parse_uint8_hex_str, &vec.pt},
 		{NULL, NULL, NULL} /**< end pointer */
 };
 
@@ -307,8 +310,8 @@ parse_test_sha_json_algorithm(void)
 	if (sz < 0)
 		return -1;
 
-	free(vec.cipher_auth.digest.val);
-	vec.cipher_auth.digest.val = calloc(1, sz);
+	rte_free(vec.cipher_auth.digest.val);
+	vec.cipher_auth.digest.val = rte_malloc(NULL, sz, 0);
 	if (vec.cipher_auth.digest.val == NULL)
 		return -1;
 
diff --git a/examples/fips_validation/main.c b/examples/fips_validation/main.c
index 4c231fdb29cda..4237224d9d7db 100644
--- a/examples/fips_validation/main.c
+++ b/examples/fips_validation/main.c
@@ -1618,11 +1618,11 @@ get_writeback_data(struct fips_val *val)
 
 	/* in case val is reused for MCT test, try to free the buffer first */
 	if (val->val) {
-		free(val->val);
+		rte_free(val->val);
 		val->val = NULL;
 	}
 
-	wb_data = dst = calloc(1, total_len);
+	wb_data = dst = rte_malloc(NULL, total_len, 0);
 	if (!dst) {
 		RTE_LOG(ERR, USER1, "Error %i: Not enough memory\n", -ENOMEM);
 		return -ENOMEM;
@@ -1640,7 +1640,7 @@ get_writeback_data(struct fips_val *val)
 
 	if (data_len) {
 		RTE_LOG(ERR, USER1, "Error -1: write back data\n");
-		free(wb_data);
+		rte_free(wb_data);
 		return -1;
 	}
 
@@ -1863,7 +1863,7 @@ fips_generic_test(void)
 
 	if (info.file_type != FIPS_TYPE_JSON)
 		fprintf(info.fp_wr, "\n");
-	free(val.val);
+	rte_free(val.val);
 
 	return 0;
 }
@@ -1883,11 +1883,11 @@ fips_mct_tdes_test(void)
 	int test_mode = info.interim_info.tdes_data.test_mode;
 
 	pt.len = vec.pt.len;
-	pt.val = calloc(1, pt.len);
+	pt.val = rte_malloc(NULL, pt.len, 0);
 	ct.len = vec.ct.len;
-	ct.val = calloc(1, ct.len);
+	ct.val = rte_malloc(NULL, ct.len, 0);
 	iv.len = vec.iv.len;
-	iv.val = calloc(1, iv.len);
+	iv.val = rte_malloc(NULL, iv.len, 0);
 
 	for (i = 0; i < TDES_EXTERN_ITER; i++) {
 		if (info.file_type != FIPS_TYPE_JSON) {
@@ -2055,10 +2055,10 @@ fips_mct_tdes_test(void)
 		}
 	}
 
-	free(val[0].val);
-	free(pt.val);
-	free(ct.val);
-	free(iv.val);
+	rte_free(val[0].val);
+	rte_free(pt.val);
+	rte_free(ct.val);
+	rte_free(iv.val);
 
 	return 0;
 }
@@ -2140,7 +2140,7 @@ fips_mct_aes_ecb_test(void)
 		}
 	}
 
-	free(val.val);
+	rte_free(val.val);
 
 	return 0;
 }
@@ -2160,11 +2160,11 @@ fips_mct_aes_test(void)
 		return fips_mct_aes_ecb_test();
 
 	pt.len = vec.pt.len;
-	pt.val = calloc(1, pt.len);
+	pt.val = rte_malloc(NULL, pt.len, 0);
 	ct.len = vec.ct.len;
-	ct.val = calloc(1, ct.len);
+	ct.val = rte_malloc(NULL, ct.len, 0);
 	iv.len = vec.iv.len;
-	iv.val = calloc(1, iv.len);
+	iv.val = rte_malloc(NULL, iv.len, 0);
 	for (i = 0; i < AES_EXTERN_ITER; i++) {
 		if (info.file_type != FIPS_TYPE_JSON) {
 			if (i != 0)
@@ -2267,10 +2267,10 @@ fips_mct_aes_test(void)
 			memcpy(vec.iv.val, val[0].val, AES_BLOCK_SIZE);
 	}
 
-	free(val[0].val);
-	free(pt.val);
-	free(ct.val);
-	free(iv.val);
+	rte_free(val[0].val);
+	rte_free(pt.val);
+	rte_free(ct.val);
+	rte_free(iv.val);
 
 	return 0;
 }
@@ -2288,9 +2288,8 @@ fips_mct_sha_test(void)
 
 	max_outlen = md_blocks * vec.cipher_auth.digest.len;
 
-	free(vec.cipher_auth.digest.val);
-
-	vec.cipher_auth.digest.val = calloc(1, max_outlen);
+	rte_free(vec.cipher_auth.digest.val);
+	vec.cipher_auth.digest.val = rte_malloc(NULL, max_outlen, 0);
 
 	if (vec.pt.val)
 		memcpy(vec.cipher_auth.digest.val, vec.pt.val, vec.cipher_auth.digest.len);
@@ -2364,7 +2363,7 @@ fips_mct_sha_test(void)
 
 	rte_free(vec.pt.val);
 
-	free(val.val);
+	rte_free(val.val);
 	return 0;
 }
 
@@ -2381,9 +2380,8 @@ fips_mct_shake_test(void)
 
 	max_outlen = vec.cipher_auth.digest.len;
 
-	free(vec.cipher_auth.digest.val);
-
-	vec.cipher_auth.digest.val = calloc(1, max_outlen);
+	rte_free(vec.cipher_auth.digest.val);
+	vec.cipher_auth.digest.val = rte_malloc(NULL, max_outlen, 0);
 
 	if (vec.pt.val)
 		memcpy(vec.cipher_auth.digest.val, vec.pt.val, vec.pt.len);
@@ -2452,8 +2450,7 @@ fips_mct_shake_test(void)
 
 	rte_free(md.val);
 	rte_free(vec.pt.val);
-
-	free(val.val);
+	rte_free(val.val);
 	return 0;
 }
 
-- 
2.25.1

