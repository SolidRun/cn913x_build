From a97de941c770dfe13f72952f7f3babbb895081c3 Mon Sep 17 00:00:00 2001
From: Ankur Dwivedi <adwivedi@marvell.com>
Date: Wed, 8 Feb 2023 22:42:11 +0530
Subject: [PATCH 289/955] ethdev: add trace points

Adds trace points for ethdev functions.

The rte_ethdev_trace.h is removed. The file ethdev_trace.h is added as
an internal header. ethdev_trace.h contains internal slow path and
fast path tracepoints. The public fast path tracepoints are present in
rte_ethdev_trace_fp.h header.

Signed-off-by: Ankur Dwivedi <adwivedi@marvell.com>
Acked-by: Sunil Kumar Kori <skori@marvell.com>
Reviewed-by: Ferruh Yigit <ferruh.yigit@amd.com>
Change-Id: Icebffd8d5ebc3a218f89deb799f9244f24472a16
---
 lib/ethdev/ethdev_private.c      |    7 +
 lib/ethdev/ethdev_trace.h        | 1512 ++++++++++++++++++++++++++++++
 lib/ethdev/ethdev_trace_points.c |  447 ++++++++-
 lib/ethdev/meson.build           |    2 +-
 lib/ethdev/rte_ethdev.c          |  872 ++++++++++++++---
 lib/ethdev/rte_ethdev_cman.c     |   29 +-
 lib/ethdev/rte_ethdev_trace.h    |   95 --
 lib/ethdev/rte_ethdev_trace_fp.h |   36 +
 8 files changed, 2761 insertions(+), 239 deletions(-)
 create mode 100644 lib/ethdev/ethdev_trace.h
 delete mode 100644 lib/ethdev/rte_ethdev_trace.h

diff --git a/lib/ethdev/ethdev_private.c b/lib/ethdev/ethdev_private.c
index 48090c879af34..14ec8c6ccf3fa 100644
--- a/lib/ethdev/ethdev_private.c
+++ b/lib/ethdev/ethdev_private.c
@@ -5,6 +5,7 @@
 #include <rte_debug.h>
 
 #include "rte_ethdev.h"
+#include "rte_ethdev_trace_fp.h"
 #include "ethdev_driver.h"
 #include "ethdev_private.h"
 
@@ -297,6 +298,9 @@ rte_eth_call_rx_callbacks(uint16_t port_id, uint16_t queue_id,
 		cb = cb->next;
 	}
 
+	rte_eth_trace_call_rx_callbacks(port_id, queue_id, (void **)rx_pkts,
+					nb_rx, nb_pkts);
+
 	return nb_rx;
 }
 
@@ -312,6 +316,9 @@ rte_eth_call_tx_callbacks(uint16_t port_id, uint16_t queue_id,
 		cb = cb->next;
 	}
 
+	rte_eth_trace_call_tx_callbacks(port_id, queue_id, (void **)tx_pkts,
+					nb_pkts);
+
 	return nb_pkts;
 }
 
diff --git a/lib/ethdev/ethdev_trace.h b/lib/ethdev/ethdev_trace.h
new file mode 100644
index 0000000000000..e83f866584c1d
--- /dev/null
+++ b/lib/ethdev/ethdev_trace.h
@@ -0,0 +1,1512 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(C) 2023 Marvell International Ltd.
+ */
+
+#ifndef ETHDEV_TRACE_H
+#define ETHDEV_TRACE_H
+
+/**
+ * @file
+ *
+ * API for ethdev trace support
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <dev_driver.h>
+#include <rte_trace_point.h>
+
+#include "rte_ethdev.h"
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_configure,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t nb_rx_q,
+		uint16_t nb_tx_q, const struct rte_eth_conf *dev_conf, int rc),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(nb_rx_q);
+	rte_trace_point_emit_u16(nb_tx_q);
+	rte_trace_point_emit_u32(dev_conf->link_speeds);
+	rte_trace_point_emit_u32(dev_conf->rxmode.mq_mode);
+	rte_trace_point_emit_u32(dev_conf->rxmode.mtu);
+	rte_trace_point_emit_u64(dev_conf->rxmode.offloads);
+	rte_trace_point_emit_u32(dev_conf->txmode.mq_mode);
+	rte_trace_point_emit_u64(dev_conf->txmode.offloads);
+	rte_trace_point_emit_u32(dev_conf->lpbk_mode);
+	rte_trace_point_emit_int(rc);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_rxq_setup,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t rx_queue_id,
+		uint16_t nb_rx_desc, void *mp,
+		const struct rte_eth_rxconf *rx_conf, int rc),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(rx_queue_id);
+	rte_trace_point_emit_u16(nb_rx_desc);
+	rte_trace_point_emit_ptr(mp);
+	rte_trace_point_emit_u8(rx_conf->rx_thresh.pthresh);
+	rte_trace_point_emit_u8(rx_conf->rx_thresh.hthresh);
+	rte_trace_point_emit_u8(rx_conf->rx_thresh.wthresh);
+	rte_trace_point_emit_u8(rx_conf->rx_drop_en);
+	rte_trace_point_emit_u8(rx_conf->rx_deferred_start);
+	rte_trace_point_emit_u64(rx_conf->offloads);
+	rte_trace_point_emit_int(rc);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_txq_setup,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t tx_queue_id,
+		uint16_t nb_tx_desc, const struct rte_eth_txconf *tx_conf),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(tx_queue_id);
+	rte_trace_point_emit_u16(nb_tx_desc);
+	rte_trace_point_emit_u8(tx_conf->tx_thresh.pthresh);
+	rte_trace_point_emit_u8(tx_conf->tx_thresh.hthresh);
+	rte_trace_point_emit_u8(tx_conf->tx_thresh.wthresh);
+	rte_trace_point_emit_u8(tx_conf->tx_deferred_start);
+	rte_trace_point_emit_u16(tx_conf->tx_free_thresh);
+	rte_trace_point_emit_u64(tx_conf->offloads);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_start,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id),
+	rte_trace_point_emit_u16(port_id);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_stop,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_close,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id),
+	rte_trace_point_emit_u16(port_id);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_iterator_init,
+	RTE_TRACE_POINT_ARGS(const char *devargs),
+	rte_trace_point_emit_string(devargs);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_iterator_next,
+	RTE_TRACE_POINT_ARGS(const struct rte_dev_iterator *iter, uint16_t id),
+	rte_trace_point_emit_string(iter->bus_str);
+	rte_trace_point_emit_string(iter->cls_str);
+	rte_trace_point_emit_u16(id);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_iterator_cleanup,
+	RTE_TRACE_POINT_ARGS(const struct rte_dev_iterator *iter),
+	rte_trace_point_emit_string(iter->bus_str);
+	rte_trace_point_emit_string(iter->cls_str);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_owner_new,
+	RTE_TRACE_POINT_ARGS(uint64_t owner_id),
+	rte_trace_point_emit_u64(owner_id);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_owner_set,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_dev_owner *owner, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u64(owner->id);
+	rte_trace_point_emit_string(owner->name);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_owner_unset,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint64_t owner_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u64(owner_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_owner_delete,
+	RTE_TRACE_POINT_ARGS(uint64_t owner_id, int ret),
+	rte_trace_point_emit_u64(owner_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_socket_id,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int socket_id),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(socket_id);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_rx_queue_start,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t rx_queue_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(rx_queue_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_rx_queue_stop,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t rx_queue_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(rx_queue_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_tx_queue_start,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t tx_queue_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(tx_queue_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_tx_queue_stop,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t tx_queue_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(tx_queue_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_speed_bitflag,
+	RTE_TRACE_POINT_ARGS(uint32_t speed, int duplex, uint32_t ret),
+	rte_trace_point_emit_u32(speed);
+	rte_trace_point_emit_int(duplex);
+	rte_trace_point_emit_u32(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_rx_offload_name,
+	RTE_TRACE_POINT_ARGS(uint64_t offload, const char *name),
+	rte_trace_point_emit_u64(offload);
+	rte_trace_point_emit_string(name);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_tx_offload_name,
+	RTE_TRACE_POINT_ARGS(uint64_t offload, const char *name),
+	rte_trace_point_emit_u64(offload);
+	rte_trace_point_emit_string(name);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_capability_name,
+	RTE_TRACE_POINT_ARGS(uint64_t capability, const char *name),
+	rte_trace_point_emit_u64(capability);
+	rte_trace_point_emit_string(name);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_set_link_up,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_set_link_down,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_reset,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_rx_hairpin_queue_setup,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t rx_queue_id,
+		uint16_t nb_rx_desc, const struct rte_eth_hairpin_conf *conf,
+		int ret),
+	uint16_t peer_count = conf->peer_count;
+	uint8_t tx_explicit = conf->tx_explicit;
+	uint8_t manual_bind = conf->manual_bind;
+	uint8_t use_locked_device_memory = conf->use_locked_device_memory;
+	uint8_t use_rte_memory = conf->use_rte_memory;
+	uint8_t force_memory = conf->force_memory;
+
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(rx_queue_id);
+	rte_trace_point_emit_u16(nb_rx_desc);
+	rte_trace_point_emit_u16(peer_count);
+	rte_trace_point_emit_u8(tx_explicit);
+	rte_trace_point_emit_u8(manual_bind);
+	rte_trace_point_emit_u8(use_locked_device_memory);
+	rte_trace_point_emit_u8(use_rte_memory);
+	rte_trace_point_emit_u8(force_memory);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_tx_hairpin_queue_setup,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t tx_queue_id,
+		uint16_t nb_tx_desc, const struct rte_eth_hairpin_conf *conf,
+		int ret),
+	uint16_t peer_count = conf->peer_count;
+	uint8_t tx_explicit = conf->tx_explicit;
+	uint8_t manual_bind = conf->manual_bind;
+	uint8_t use_locked_device_memory = conf->use_locked_device_memory;
+	uint8_t use_rte_memory = conf->use_rte_memory;
+	uint8_t force_memory = conf->force_memory;
+
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(tx_queue_id);
+	rte_trace_point_emit_u16(nb_tx_desc);
+	rte_trace_point_emit_u16(peer_count);
+	rte_trace_point_emit_u8(tx_explicit);
+	rte_trace_point_emit_u8(manual_bind);
+	rte_trace_point_emit_u8(use_locked_device_memory);
+	rte_trace_point_emit_u8(use_rte_memory);
+	rte_trace_point_emit_u8(force_memory);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_hairpin_bind,
+	RTE_TRACE_POINT_ARGS(uint16_t tx_port, uint16_t rx_port, int ret),
+	rte_trace_point_emit_u16(tx_port);
+	rte_trace_point_emit_u16(rx_port);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_hairpin_unbind,
+	RTE_TRACE_POINT_ARGS(uint16_t tx_port, uint16_t rx_port, int ret),
+	rte_trace_point_emit_u16(tx_port);
+	rte_trace_point_emit_u16(rx_port);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_tx_buffer_set_err_callback,
+	RTE_TRACE_POINT_ARGS(const struct rte_eth_dev_tx_buffer *buffer),
+	rte_trace_point_emit_ptr(buffer->error_callback);
+	rte_trace_point_emit_ptr(buffer->error_userdata);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_promiscuous_enable,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int promiscuous, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(promiscuous);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_promiscuous_disable,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int promiscuous, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(promiscuous);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_allmulticast_enable,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int all_multicast, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(all_multicast);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_allmulticast_disable,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int all_multicast, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(all_multicast);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_set_rx_queue_stats_mapping,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t rx_queue_id,
+		uint8_t stat_idx, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(rx_queue_id);
+	rte_trace_point_emit_u8(stat_idx);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_set_tx_queue_stats_mapping,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t tx_queue_id,
+		uint8_t stat_idx, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(tx_queue_id);
+	rte_trace_point_emit_u8(stat_idx);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_fw_version_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, const char *fw_version,
+		size_t fw_size, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_string(fw_version);
+	rte_trace_point_emit_size_t(fw_size);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_find_next,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id),
+	rte_trace_point_emit_u16(port_id);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_find_next_of,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, const struct rte_device *parent),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_string(parent->name);
+	rte_trace_point_emit_string(parent->bus_info);
+	rte_trace_point_emit_int(parent->numa_node);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_find_next_sibling,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id_start, uint16_t ref_port_id,
+		uint16_t ret),
+	rte_trace_point_emit_u16(port_id_start);
+	rte_trace_point_emit_u16(ref_port_id);
+	rte_trace_point_emit_u16(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_is_valid_port,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int is_valid),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(is_valid);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_find_next_owned_by,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint64_t owner_id),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u64(owner_id);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_owner_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_dev_owner *owner),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u64(owner->id);
+	rte_trace_point_emit_string(owner->name);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_get_sec_ctx,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, const void *ctx),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_ptr(ctx);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_count_avail,
+	RTE_TRACE_POINT_ARGS(uint16_t count),
+	rte_trace_point_emit_u16(count);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_count_total,
+	RTE_TRACE_POINT_ARGS(uint16_t count),
+	rte_trace_point_emit_u16(count);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_get_name_by_port,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, const char *name),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_string(name);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_get_port_by_name,
+	RTE_TRACE_POINT_ARGS(const char *name, uint16_t port_id),
+	rte_trace_point_emit_string(name);
+	rte_trace_point_emit_u16(port_id);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_is_removed,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_hairpin_get_peer_ports,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, const uint16_t *peer_ports,
+		size_t len, uint32_t direction, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_ptr(peer_ports);
+	rte_trace_point_emit_size_t(len);
+	rte_trace_point_emit_u32(direction);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_tx_buffer_init,
+	RTE_TRACE_POINT_ARGS(const struct rte_eth_dev_tx_buffer *buffer,
+		uint16_t size, int ret),
+	rte_trace_point_emit_ptr(buffer);
+	rte_trace_point_emit_u16(size);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_tx_done_cleanup,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id,
+		uint32_t free_cnt, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_u32(free_cnt);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_promiscuous_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int promiscuous),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(promiscuous);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_allmulticast_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int all_multicast),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(all_multicast);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_link_get_nowait,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, const struct rte_eth_link *link),
+	uint8_t link_duplex = link->link_duplex;
+	uint8_t link_autoneg = link->link_autoneg;
+	uint8_t link_status = link->link_status;
+
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u32(link->link_speed);
+	rte_trace_point_emit_u8(link_duplex);
+	rte_trace_point_emit_u8(link_autoneg);
+	rte_trace_point_emit_u8(link_status);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_link_to_str,
+	RTE_TRACE_POINT_ARGS(size_t len, const struct rte_eth_link *link,
+		char *str, int ret),
+	uint8_t link_duplex = link->link_duplex;
+	uint8_t link_autoneg = link->link_autoneg;
+	uint8_t link_status = link->link_status;
+
+	rte_trace_point_emit_size_t(len);
+	rte_trace_point_emit_u32(link->link_speed);
+	rte_trace_point_emit_u8(link_duplex);
+	rte_trace_point_emit_u8(link_autoneg);
+	rte_trace_point_emit_u8(link_status);
+	rte_trace_point_emit_string(str);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_stats_reset,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id),
+	rte_trace_point_emit_u16(port_id);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_xstats_get_id_by_name,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, const char *xstat_name,
+		uint64_t id),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_string(xstat_name);
+	rte_trace_point_emit_u64(id);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_xstats_get_names_by_id,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_xstat_name *xstats_names, uint64_t ids),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_string(xstats_names->name);
+	rte_trace_point_emit_u64(ids);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_xstats_get_names,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int i,
+		struct rte_eth_xstat_name xstats_names,
+		unsigned int size, int cnt_used_entries),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(i);
+	rte_trace_point_emit_string(xstats_names.name);
+	rte_trace_point_emit_u32(size);
+	rte_trace_point_emit_int(cnt_used_entries);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_xstats_get_by_id,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, const uint64_t *ids,
+		const uint64_t *values, unsigned int size),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_ptr(ids);
+	rte_trace_point_emit_ptr(values);
+	rte_trace_point_emit_u32(size);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_xstats_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, struct rte_eth_xstat xstats),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u64(xstats.id);
+	rte_trace_point_emit_u64(xstats.value);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_xstats_reset,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_info_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_dev_info *dev_info),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_string(dev_info->driver_name);
+	rte_trace_point_emit_u16(dev_info->min_mtu);
+	rte_trace_point_emit_u16(dev_info->max_mtu);
+	rte_trace_point_emit_u32(dev_info->min_rx_bufsize);
+	rte_trace_point_emit_u32(dev_info->max_rx_pktlen);
+	rte_trace_point_emit_u16(dev_info->max_rx_queues);
+	rte_trace_point_emit_u16(dev_info->max_tx_queues);
+	rte_trace_point_emit_u32(dev_info->max_mac_addrs);
+	rte_trace_point_emit_u64(dev_info->rx_offload_capa);
+	rte_trace_point_emit_u64(dev_info->tx_offload_capa);
+	rte_trace_point_emit_u64(dev_info->rx_queue_offload_capa);
+	rte_trace_point_emit_u64(dev_info->tx_queue_offload_capa);
+	rte_trace_point_emit_u16(dev_info->reta_size);
+	rte_trace_point_emit_u8(dev_info->hash_key_size);
+	rte_trace_point_emit_u64(dev_info->flow_type_rss_offloads);
+	rte_trace_point_emit_u16(dev_info->rx_desc_lim.nb_max);
+	rte_trace_point_emit_u16(dev_info->rx_desc_lim.nb_min);
+	rte_trace_point_emit_u16(dev_info->rx_desc_lim.nb_align);
+	rte_trace_point_emit_u16(dev_info->tx_desc_lim.nb_max);
+	rte_trace_point_emit_u16(dev_info->tx_desc_lim.nb_min);
+	rte_trace_point_emit_u16(dev_info->tx_desc_lim.nb_align);
+	rte_trace_point_emit_u32(dev_info->speed_capa);
+	rte_trace_point_emit_u16(dev_info->nb_rx_queues);
+	rte_trace_point_emit_u16(dev_info->nb_tx_queues);
+	rte_trace_point_emit_u64(dev_info->dev_capa);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_conf_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_conf *dev_conf),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u32(dev_conf->link_speeds);
+	rte_trace_point_emit_u64(dev_conf->rxmode.offloads);
+	rte_trace_point_emit_u64(dev_conf->txmode.offloads);
+	rte_trace_point_emit_u32(dev_conf->lpbk_mode);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_get_supported_ptypes,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int supported_num, int num,
+		uint32_t ptypes),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(supported_num);
+	rte_trace_point_emit_int(num);
+	rte_trace_point_emit_u32(ptypes);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_set_ptypes,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int supported_num,
+		unsigned int num, uint32_t set_ptypes),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(supported_num);
+	rte_trace_point_emit_u32(num);
+	rte_trace_point_emit_u32(set_ptypes);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_macaddrs_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, unsigned int num),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u32(num);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_set_mtu,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t mtu, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(mtu);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_vlan_filter,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t vlan_id, int on,
+		int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(vlan_id);
+	rte_trace_point_emit_int(on);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_set_vlan_strip_on_queue,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t rx_queue_id, int on),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(rx_queue_id);
+	rte_trace_point_emit_int(on);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_set_vlan_ether_type,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, enum rte_vlan_type vlan_type,
+		uint16_t tag_type, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(vlan_type);
+	rte_trace_point_emit_u16(tag_type);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_set_vlan_offload,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int offload_mask, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(offload_mask);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_get_vlan_offload,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_set_vlan_pvid,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t pvid, int on, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(pvid);
+	rte_trace_point_emit_int(on);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_flow_ctrl_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_fc_conf *fc_conf, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u32(fc_conf->high_water);
+	rte_trace_point_emit_u32(fc_conf->low_water);
+	rte_trace_point_emit_u16(fc_conf->pause_time);
+	rte_trace_point_emit_u16(fc_conf->send_xon);
+	rte_trace_point_emit_int(fc_conf->mode);
+	rte_trace_point_emit_u8(fc_conf->mac_ctrl_frame_fwd);
+	rte_trace_point_emit_u8(fc_conf->autoneg);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_flow_ctrl_set,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_fc_conf *fc_conf, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u32(fc_conf->high_water);
+	rte_trace_point_emit_u32(fc_conf->low_water);
+	rte_trace_point_emit_u16(fc_conf->pause_time);
+	rte_trace_point_emit_u16(fc_conf->send_xon);
+	rte_trace_point_emit_int(fc_conf->mode);
+	rte_trace_point_emit_u8(fc_conf->mac_ctrl_frame_fwd);
+	rte_trace_point_emit_u8(fc_conf->autoneg);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_priority_flow_ctrl_set,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_pfc_conf *pfc_conf, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u32(pfc_conf->fc.high_water);
+	rte_trace_point_emit_u32(pfc_conf->fc.low_water);
+	rte_trace_point_emit_u16(pfc_conf->fc.pause_time);
+	rte_trace_point_emit_u16(pfc_conf->fc.send_xon);
+	rte_trace_point_emit_int(pfc_conf->fc.mode);
+	rte_trace_point_emit_u8(pfc_conf->fc.mac_ctrl_frame_fwd);
+	rte_trace_point_emit_u8(pfc_conf->fc.autoneg);
+	rte_trace_point_emit_u8(pfc_conf->priority);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_priority_flow_ctrl_queue_info_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_pfc_queue_info *pfc_queue_info, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u8(pfc_queue_info->tc_max);
+	rte_trace_point_emit_int(pfc_queue_info->mode_capa);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_priority_flow_ctrl_queue_configure,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_pfc_queue_conf *pfc_queue_conf, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(pfc_queue_conf->mode);
+	rte_trace_point_emit_u16(pfc_queue_conf->rx_pause.tx_qid);
+	rte_trace_point_emit_u16(pfc_queue_conf->tx_pause.rx_qid);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_rss_reta_update,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_rss_reta_entry64 *reta_conf,
+		uint16_t reta_size, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u64(reta_conf->mask);
+	rte_trace_point_emit_u16(reta_size);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_rss_reta_query,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_rss_reta_entry64 *reta_conf,
+		uint16_t reta_size, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u64(reta_conf->mask);
+	rte_trace_point_emit_u16(reta_size);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_rss_hash_update,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_rss_conf *rss_conf, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_ptr(rss_conf->rss_key);
+	rte_trace_point_emit_u8(rss_conf->rss_key_len);
+	rte_trace_point_emit_u64(rss_conf->rss_hf);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_rss_hash_conf_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_rss_conf *rss_conf, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_ptr(rss_conf->rss_key);
+	rte_trace_point_emit_u8(rss_conf->rss_key_len);
+	rte_trace_point_emit_u64(rss_conf->rss_hf);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_udp_tunnel_port_add,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_udp_tunnel *tunnel_udp, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(tunnel_udp->udp_port);
+	rte_trace_point_emit_u8(tunnel_udp->prot_type);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_udp_tunnel_port_delete,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_udp_tunnel *tunnel_udp, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(tunnel_udp->udp_port);
+	rte_trace_point_emit_u8(tunnel_udp->prot_type);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_led_on,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_led_off,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_fec_get_capability,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_fec_capa *speed_fec_capa,
+		unsigned int num, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u32(speed_fec_capa->speed);
+	rte_trace_point_emit_u32(speed_fec_capa->capa);
+	rte_trace_point_emit_u32(num);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_fec_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, const uint32_t *fec_capa,
+		int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_ptr(fec_capa);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_fec_set,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint32_t fec_capa, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u32(fec_capa);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_mac_addr_add,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_ether_addr *addr, uint32_t pool, int ret),
+	uint8_t len = RTE_ETHER_ADDR_LEN;
+
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_blob(addr->addr_bytes, len);
+	rte_trace_point_emit_u32(pool);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_mac_addr_remove,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_ether_addr *addr),
+	uint8_t len = RTE_ETHER_ADDR_LEN;
+
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_blob(addr->addr_bytes, len);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_default_mac_addr_set,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_ether_addr *addr),
+	uint8_t len = RTE_ETHER_ADDR_LEN;
+
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_blob(addr->addr_bytes, len);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_uc_hash_table_set,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint8_t on, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u8(on);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_uc_all_hash_table_set,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint8_t on, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u8(on);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_set_queue_rate_limit,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_idx,
+		uint16_t tx_rate, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_idx);
+	rte_trace_point_emit_u16(tx_rate);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_rx_avail_thresh_set,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id,
+		uint8_t avail_thresh, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_u8(avail_thresh);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_rx_avail_thresh_query,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_callback_register,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, enum rte_eth_event_type event,
+		rte_eth_dev_cb_fn cb_fn, const void *cb_arg),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(event);
+	rte_trace_point_emit_ptr(cb_fn);
+	rte_trace_point_emit_ptr(cb_arg);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_callback_unregister,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, enum rte_eth_event_type event,
+		rte_eth_dev_cb_fn cb_fn, const void *cb_arg, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(event);
+	rte_trace_point_emit_ptr(cb_fn);
+	rte_trace_point_emit_ptr(cb_arg);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_rx_intr_ctl,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t qid, int epfd, int op,
+		const void *data, int rc),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(qid);
+	rte_trace_point_emit_int(epfd);
+	rte_trace_point_emit_int(op);
+	rte_trace_point_emit_ptr(data);
+	rte_trace_point_emit_int(rc);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_rx_intr_ctl_q_get_fd,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id, int fd),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_int(fd);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_rx_intr_ctl_q,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id, int epfd,
+		int op, const void *data, int rc),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_int(epfd);
+	rte_trace_point_emit_int(op);
+	rte_trace_point_emit_ptr(data);
+	rte_trace_point_emit_int(rc);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_add_rx_callback,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id,
+		rte_rx_callback_fn fn, void *user_param,
+		const struct rte_eth_rxtx_callback *cb),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_ptr(fn);
+	rte_trace_point_emit_ptr(user_param);
+	rte_trace_point_emit_ptr(cb);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_add_first_rx_callback,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id,
+		rte_rx_callback_fn fn, const void *user_param,
+		const struct rte_eth_rxtx_callback *cb),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_ptr(fn);
+	rte_trace_point_emit_ptr(user_param);
+	rte_trace_point_emit_ptr(cb);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_add_tx_callback,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id,
+		rte_tx_callback_fn fn, const void *user_param,
+		const struct rte_eth_rxtx_callback *cb),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_ptr(fn);
+	rte_trace_point_emit_ptr(user_param);
+	rte_trace_point_emit_ptr(cb);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_remove_rx_callback,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id,
+		const struct rte_eth_rxtx_callback *user_cb, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_ptr(user_cb);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_remove_tx_callback,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id,
+		const struct rte_eth_rxtx_callback *user_cb, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_ptr(user_cb);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_rx_queue_info_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id,
+		const struct rte_eth_rxq_info *qinfo),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_ptr(qinfo->mp);
+	rte_trace_point_emit_u8(qinfo->conf.rx_drop_en);
+	rte_trace_point_emit_u64(qinfo->conf.offloads);
+	rte_trace_point_emit_u8(qinfo->scattered_rx);
+	rte_trace_point_emit_u8(qinfo->queue_state);
+	rte_trace_point_emit_u16(qinfo->nb_desc);
+	rte_trace_point_emit_u16(qinfo->rx_buf_size);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_tx_queue_info_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id,
+		const struct rte_eth_txq_info *qinfo),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_u16(qinfo->nb_desc);
+	rte_trace_point_emit_u8(qinfo->queue_state);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_rx_burst_mode_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id,
+		const struct rte_eth_burst_mode *mode, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_u64(mode->flags);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_tx_burst_mode_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id,
+		const struct rte_eth_burst_mode *mode, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_u64(mode->flags);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_get_monitor_addr,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id,
+		const struct rte_power_monitor_cond *pmc, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_ptr(pmc->addr);
+	rte_trace_point_emit_u8(pmc->size);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_set_mc_addr_list,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_ether_addr *mc_addr_set, uint32_t nb_mc_addr,
+		int ret),
+	uint8_t len = nb_mc_addr * RTE_ETHER_ADDR_LEN;
+
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u32(nb_mc_addr);
+	rte_trace_point_emit_blob(mc_addr_set, len);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_timesync_enable,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_timesync_disable,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_timesync_write_time,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, const struct timespec *time,
+		int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_size_t(time->tv_sec);
+	rte_trace_point_emit_long(time->tv_nsec);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_read_clock,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, const uint64_t *clk, int ret),
+	uint64_t clk_v = *clk;
+
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u64(clk_v);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_get_reg_info,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_dev_reg_info *info, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_ptr(info->data);
+	rte_trace_point_emit_u32(info->offset);
+	rte_trace_point_emit_u32(info->length);
+	rte_trace_point_emit_u32(info->width);
+	rte_trace_point_emit_u32(info->version);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_get_eeprom_length,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_get_eeprom,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_dev_eeprom_info *info, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_ptr(info->data);
+	rte_trace_point_emit_u32(info->offset);
+	rte_trace_point_emit_u32(info->length);
+	rte_trace_point_emit_u32(info->magic);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_set_eeprom,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_dev_eeprom_info *info, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_ptr(info->data);
+	rte_trace_point_emit_u32(info->offset);
+	rte_trace_point_emit_u32(info->length);
+	rte_trace_point_emit_u32(info->magic);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_get_module_info,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_dev_module_info *modinfo, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u32(modinfo->type);
+	rte_trace_point_emit_u32(modinfo->eeprom_len);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_get_module_eeprom,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_dev_eeprom_info *info, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_ptr(info->data);
+	rte_trace_point_emit_u32(info->offset);
+	rte_trace_point_emit_u32(info->length);
+	rte_trace_point_emit_u32(info->magic);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_get_dcb_info,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_dcb_info *dcb_info, int ret),
+	uint8_t num_user_priorities = RTE_ETH_DCB_NUM_USER_PRIORITIES;
+	uint8_t num_tcs = RTE_ETH_DCB_NUM_TCS;
+
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u8(dcb_info->nb_tcs);
+	rte_trace_point_emit_blob(dcb_info->prio_tc, num_user_priorities);
+	rte_trace_point_emit_blob(dcb_info->tc_bws, num_tcs);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_adjust_nb_rx_tx_desc,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id),
+	rte_trace_point_emit_u16(port_id);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_hairpin_capability_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_hairpin_cap *cap, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(cap->max_nb_queues);
+	rte_trace_point_emit_u16(cap->max_rx_2_tx);
+	rte_trace_point_emit_u16(cap->max_tx_2_rx);
+	rte_trace_point_emit_u16(cap->max_nb_desc);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_ethdev_trace_pool_ops_supported,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, const char *pool, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_string(pool);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_representor_info_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_representor_info *info, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_ptr(info);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_rx_metadata_negotiate,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint64_t features_val, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u64(features_val);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_ip_reassembly_capability_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_ip_reassembly_params *capa, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u32(capa->timeout_ms);
+	rte_trace_point_emit_u16(capa->max_frags);
+	rte_trace_point_emit_u16(capa->flags);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_ip_reassembly_conf_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_ip_reassembly_params *conf, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u32(conf->timeout_ms);
+	rte_trace_point_emit_u16(conf->max_frags);
+	rte_trace_point_emit_u16(conf->flags);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_ip_reassembly_conf_set,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_ip_reassembly_params *conf, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u32(conf->timeout_ms);
+	rte_trace_point_emit_u16(conf->max_frags);
+	rte_trace_point_emit_u16(conf->flags);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_buffer_split_get_supported_hdr_ptypes,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int supported_num,
+		uint32_t ptypes),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(supported_num);
+	rte_trace_point_emit_u32(ptypes);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_cman_info_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_cman_info *info, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u64(info->modes_supported);
+	rte_trace_point_emit_u64(info->objs_supported);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_cman_config_init,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_cman_config *config, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(config->obj);
+	rte_trace_point_emit_int(config->mode);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_cman_config_set,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_cman_config *config, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(config->obj);
+	rte_trace_point_emit_int(config->mode);
+	rte_trace_point_emit_int(ret);
+)
+
+RTE_TRACE_POINT(
+	rte_eth_trace_cman_config_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_cman_config *config, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_int(config->obj);
+	rte_trace_point_emit_int(config->mode);
+	rte_trace_point_emit_int(ret);
+)
+
+/* Fast path trace points */
+
+/* Called in loop in examples/qos_sched and examples/distributor */
+RTE_TRACE_POINT_FP(
+	rte_eth_trace_stats_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_eth_stats *stats, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u64(stats->rx_nombuf);
+	rte_trace_point_emit_u64(stats->ipackets);
+	rte_trace_point_emit_u64(stats->opackets);
+	rte_trace_point_emit_u64(stats->ibytes);
+	rte_trace_point_emit_u64(stats->obytes);
+	rte_trace_point_emit_u64(stats->imissed);
+	rte_trace_point_emit_u64(stats->ierrors);
+	rte_trace_point_emit_u64(stats->oerrors);
+	rte_trace_point_emit_int(ret);
+)
+
+/* Called in loop in examples/ip_pipeline */
+RTE_TRACE_POINT_FP(
+	rte_eth_trace_link_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, const struct rte_eth_link *link),
+	uint8_t link_duplex = link->link_duplex;
+	uint8_t link_autoneg = link->link_autoneg;
+	uint8_t link_status = link->link_status;
+
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u32(link->link_speed);
+	rte_trace_point_emit_u8(link_duplex);
+	rte_trace_point_emit_u8(link_autoneg);
+	rte_trace_point_emit_u8(link_status);
+)
+
+/* Called in loop in examples/ip_pipeline */
+RTE_TRACE_POINT_FP(
+	rte_eth_trace_link_speed_to_str,
+	RTE_TRACE_POINT_ARGS(uint32_t link_speed, const char *ret),
+	rte_trace_point_emit_u32(link_speed);
+	rte_trace_point_emit_string(ret);
+)
+
+/* Called in loop in examples/bond and examples/ethtool */
+RTE_TRACE_POINT_FP(
+	rte_eth_trace_macaddr_get,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id,
+		const struct rte_ether_addr *mac_addr),
+	uint8_t len = RTE_ETHER_ADDR_LEN;
+
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_blob(mac_addr->addr_bytes, len);
+)
+
+/* Called in loop in examples/ip_pipeline */
+RTE_TRACE_POINT_FP(
+	rte_ethdev_trace_get_mtu,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t mtu),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(mtu);
+)
+
+/* Called in loop in examples/l3fwd-power */
+RTE_TRACE_POINT_FP(
+	rte_ethdev_trace_rx_intr_enable,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_int(ret);
+)
+
+/* Called in loop in examples/l3fwd-power */
+RTE_TRACE_POINT_FP(
+	rte_ethdev_trace_rx_intr_disable,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_int(ret);
+)
+
+/* Called in loop in examples/ptpclient */
+RTE_TRACE_POINT_FP(
+	rte_eth_trace_timesync_read_rx_timestamp,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, const struct timespec *timestamp,
+		uint32_t flags, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_size_t(timestamp->tv_sec);
+	rte_trace_point_emit_long(timestamp->tv_nsec);
+	rte_trace_point_emit_u32(flags);
+	rte_trace_point_emit_int(ret);
+)
+
+/* Called in loop in examples/ptpclient */
+RTE_TRACE_POINT_FP(
+	rte_eth_trace_timesync_read_tx_timestamp,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, const struct timespec *timestamp,
+		int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_size_t(timestamp->tv_sec);
+	rte_trace_point_emit_long(timestamp->tv_nsec);
+	rte_trace_point_emit_int(ret);
+)
+
+/* Called in loop in examples/ptpclient */
+RTE_TRACE_POINT_FP(
+	rte_eth_trace_timesync_read_time,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, const struct timespec *time,
+		int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_size_t(time->tv_sec);
+	rte_trace_point_emit_long(time->tv_nsec);
+	rte_trace_point_emit_int(ret);
+)
+
+/* Called in loop in examples/ptpclient */
+RTE_TRACE_POINT_FP(
+	rte_eth_trace_timesync_adjust_time,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, int64_t delta, int ret),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_i64(delta);
+	rte_trace_point_emit_int(ret);
+)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ETHDEV_TRACE_H */
diff --git a/lib/ethdev/ethdev_trace_points.c b/lib/ethdev/ethdev_trace_points.c
index 2919409a1534e..7a08104dc9589 100644
--- a/lib/ethdev/ethdev_trace_points.c
+++ b/lib/ethdev/ethdev_trace_points.c
@@ -4,7 +4,8 @@
 
 #include <rte_trace_point_register.h>
 
-#include <rte_ethdev_trace.h>
+#include <ethdev_trace.h>
+#include <rte_ethdev_trace_fp.h>
 
 RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_configure,
 	lib.ethdev.configure)
@@ -29,3 +30,447 @@ RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_rx_burst,
 
 RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_tx_burst,
 	lib.ethdev.tx.burst)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_call_rx_callbacks,
+	lib.ethdev.call_rx_callbacks)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_call_tx_callbacks,
+	lib.ethdev.call_tx_callbacks)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_iterator_init,
+	lib.ethdev.iterator_init)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_iterator_next,
+	lib.ethdev.iterator_next)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_iterator_cleanup,
+	lib.ethdev.iterator_cleanup)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_find_next,
+	lib.ethdev.find_next)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_find_next_of,
+	lib.ethdev.find_next_of)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_find_next_sibling,
+	lib.ethdev.find_next_sibling)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_is_valid_port,
+	lib.ethdev.is_valid_port)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_find_next_owned_by,
+	lib.ethdev.find_next_owned_by)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_owner_new,
+	lib.ethdev.owner_new)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_owner_set,
+	lib.ethdev.owner_set)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_owner_unset,
+	lib.ethdev.owner_unset)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_owner_delete,
+	lib.ethdev.owner_delete)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_owner_get,
+	lib.ethdev.owner_get)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_socket_id,
+	lib.ethdev.socket_id)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_get_sec_ctx,
+	lib.ethdev.get_sec_ctx)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_count_avail,
+	lib.ethdev.count_avail)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_count_total,
+	lib.ethdev.count_total)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_get_name_by_port,
+	lib.ethdev.get_name_by_port)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_get_port_by_name,
+	lib.ethdev.get_port_by_name)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_rx_queue_start,
+	lib.ethdev.rx_queue_start)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_rx_queue_stop,
+	lib.ethdev.rx_queue_stop)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_tx_queue_start,
+	lib.ethdev.tx_queue_start)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_tx_queue_stop,
+	lib.ethdev.tx_queue_stop)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_speed_bitflag,
+	lib.ethdev.speed_bitflag)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_rx_offload_name,
+	lib.ethdev.rx_offload_name)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_tx_offload_name,
+	lib.ethdev.tx_offload_name)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_capability_name,
+	lib.ethdev.capability_name)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_set_link_up,
+	lib.ethdev.set_link_up)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_set_link_down,
+	lib.ethdev.set_link_down)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_reset,
+	lib.ethdev.reset)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_is_removed,
+	lib.ethdev.is_removed)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_rx_hairpin_queue_setup,
+	lib.ethdev.rx_hairpin_queue_setup)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_tx_hairpin_queue_setup,
+	lib.ethdev.tx_hairpin_queue_setup)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_hairpin_bind,
+	lib.ethdev.hairpin_bind)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_hairpin_unbind,
+	lib.ethdev.hairpin_unbind)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_hairpin_get_peer_ports,
+	lib.ethdev.hairpin_get_peer_ports)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_tx_buffer_drop_callback,
+	lib.ethdev.tx_buffer_drop_callback)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_tx_buffer_count_callback,
+	lib.ethdev.tx_buffer_count_callback)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_tx_buffer_set_err_callback,
+	lib.ethdev.tx_buffer_set_err_callback)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_tx_buffer_init,
+	lib.ethdev.tx_buffer_init)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_tx_done_cleanup,
+	lib.ethdev.tx_done_cleanup)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_promiscuous_enable,
+	lib.ethdev.promiscuous_enable)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_promiscuous_disable,
+	lib.ethdev.promiscuous_disable)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_promiscuous_get,
+	lib.ethdev.promiscuous_get)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_allmulticast_enable,
+	lib.ethdev.allmulticast_enable)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_allmulticast_disable,
+	lib.ethdev.allmulticast_disable)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_allmulticast_get,
+	lib.ethdev.allmulticast_get)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_link_get,
+	lib.ethdev.link_get)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_link_get_nowait,
+	lib.ethdev.link_get_nowait)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_link_speed_to_str,
+	lib.ethdev.link_speed_to_str)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_link_to_str,
+	lib.ethdev.link_to_str)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_stats_get,
+	lib.ethdev.stats_get)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_stats_reset,
+	lib.ethdev.stats_reset)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_xstats_get_id_by_name,
+	lib.ethdev.xstats_get_id_by_name)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_xstats_get_names_by_id,
+	lib.ethdev.xstats_get_names_by_id)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_xstats_get_names,
+	lib.ethdev.xstats_get_names)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_xstats_get_by_id,
+	lib.ethdev.xstats_get_by_id)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_xstats_get,
+	lib.ethdev.xstats_get)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_xstats_reset,
+	lib.ethdev.xstats_reset)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_set_tx_queue_stats_mapping,
+	lib.ethdev.set_tx_queue_stats_mapping)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_set_rx_queue_stats_mapping,
+	lib.ethdev.set_rx_queue_stats_mapping)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_fw_version_get,
+	lib.ethdev.fw_version_get)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_info_get,
+	lib.ethdev.info_get)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_conf_get,
+	lib.ethdev.conf_get)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_get_supported_ptypes,
+	lib.ethdev.get_supported_ptypes)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_set_ptypes,
+	lib.ethdev.set_ptypes)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_macaddrs_get,
+	lib.ethdev.macaddrs_get)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_macaddr_get,
+	lib.ethdev.macaddr_get)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_get_mtu,
+	lib.ethdev.get_mtu)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_set_mtu,
+	lib.ethdev.set_mtu)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_vlan_filter,
+	lib.ethdev.vlan_filter)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_set_vlan_strip_on_queue,
+	lib.ethdev.set_vlan_strip_on_queue)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_set_vlan_ether_type,
+	lib.ethdev.set_vlan_ether_type)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_set_vlan_offload,
+	lib.ethdev.set_vlan_offload)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_get_vlan_offload,
+	lib.ethdev.get_vlan_offload)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_set_vlan_pvid,
+	lib.ethdev.set_vlan_pvid)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_flow_ctrl_get,
+	lib.ethdev.flow_ctrl_get)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_flow_ctrl_set,
+	lib.ethdev.flow_ctrl_set)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_priority_flow_ctrl_set,
+	lib.ethdev.priority_flow_ctrl_set)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_priority_flow_ctrl_queue_info_get,
+	lib.ethdev.priority_flow_ctrl_queue_info_get)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_priority_flow_ctrl_queue_configure,
+	lib.ethdev.priority_flow_ctrl_queue_configure)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_rss_reta_update,
+	lib.ethdev.rss_reta_update)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_rss_reta_query,
+	lib.ethdev.rss_reta_query)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_rss_hash_update,
+	lib.ethdev.rss_hash_update)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_rss_hash_conf_get,
+	lib.ethdev.rss_hash_conf_get)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_udp_tunnel_port_add,
+	lib.ethdev.udp_tunnel_port_add)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_udp_tunnel_port_delete,
+	lib.ethdev.udp_tunnel_port_delete)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_led_on,
+	lib.ethdev.led_on)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_led_off,
+	lib.ethdev.led_off)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_fec_get_capability,
+	lib.ethdev.fec_get_capability)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_fec_get,
+	lib.ethdev.fec_get)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_fec_set,
+	lib.ethdev.fec_set)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_mac_addr_add,
+	lib.ethdev.mac_addr_add)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_mac_addr_remove,
+	lib.ethdev.mac_addr_remove)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_default_mac_addr_set,
+	lib.ethdev.default_mac_addr_set)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_uc_hash_table_set,
+	lib.ethdev.uc_hash_table_set)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_uc_all_hash_table_set,
+	lib.ethdev.uc_all_hash_table_set)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_set_queue_rate_limit,
+	lib.ethdev.set_queue_rate_limit)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_rx_avail_thresh_set,
+	lib.ethdev.rx_avail_thresh_set)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_rx_avail_thresh_query,
+	lib.ethdev.rx_avail_thresh_query)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_callback_register,
+	lib.ethdev.callback_register)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_callback_unregister,
+	lib.ethdev.callback_unregister)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_rx_intr_ctl,
+	lib.ethdev.rx_intr_ctl)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_rx_intr_ctl_q_get_fd,
+	lib.ethdev.rx_intr_ctl_q_get_fd)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_rx_intr_ctl_q,
+	lib.ethdev.rx_intr_ctl_q)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_rx_intr_enable,
+	lib.ethdev.rx_intr_enable)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_rx_intr_disable,
+	lib.ethdev.rx_intr_disable)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_add_rx_callback,
+	lib.ethdev.add_rx_callback)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_add_first_rx_callback,
+	lib.ethdev.add_first_rx_callback)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_add_tx_callback,
+	lib.ethdev.add_tx_callback)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_remove_rx_callback,
+	lib.ethdev.remove_rx_callback)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_remove_tx_callback,
+	lib.ethdev.remove_tx_callback)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_rx_queue_info_get,
+	lib.ethdev.rx_queue_info_get)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_tx_queue_info_get,
+	lib.ethdev.tx_queue_info_get)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_rx_burst_mode_get,
+	lib.ethdev.rx_burst_mode_get)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_tx_burst_mode_get,
+	lib.ethdev.tx_burst_mode_get)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_get_monitor_addr,
+	lib.ethdev.get_monitor_addr)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_set_mc_addr_list,
+	lib.ethdev.set_mc_addr_list)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_timesync_enable,
+	lib.ethdev.timesync_enable)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_timesync_disable,
+	lib.ethdev.timesync_disable)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_timesync_read_rx_timestamp,
+	lib.ethdev.timesync_read_rx_timestamp)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_timesync_read_tx_timestamp,
+	lib.ethdev.timesync_read_tx_timestamp)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_timesync_adjust_time,
+	lib.ethdev.timesync_adjust_time)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_timesync_read_time,
+	lib.ethdev.timesync_read_time)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_timesync_write_time,
+	lib.ethdev.timesync_write_time)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_read_clock,
+	lib.ethdev.read_clock)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_get_reg_info,
+	lib.ethdev.get_reg_info)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_get_eeprom_length,
+	lib.ethdev.get_eeprom_length)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_get_eeprom,
+	lib.ethdev.get_eeprom)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_set_eeprom,
+	lib.ethdev.set_eeprom)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_get_module_info,
+	lib.ethdev.get_module_info)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_get_module_eeprom,
+	lib.ethdev.get_module_eeprom)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_get_dcb_info,
+	lib.ethdev.get_dcb_info)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_adjust_nb_rx_tx_desc,
+	lib.ethdev.adjust_nb_rx_tx_desc)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_hairpin_capability_get,
+	lib.ethdev.hairpin_capability_get)
+
+RTE_TRACE_POINT_REGISTER(rte_ethdev_trace_pool_ops_supported,
+	lib.ethdev.pool_ops_supported)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_representor_info_get,
+	lib.ethdev.representor_info_get)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_rx_metadata_negotiate,
+	lib.ethdev.rx_metadata_negotiate)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_ip_reassembly_capability_get,
+	lib.ethdev.ip_reassembly_capability_get)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_ip_reassembly_conf_get,
+	lib.ethdev.ip_reassembly_conf_get)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_ip_reassembly_conf_set,
+	lib.ethdev.ip_reassembly_conf_set)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_buffer_split_get_supported_hdr_ptypes,
+	lib.ethdev.buffer_split_get_supported_hdr_ptypes)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_cman_info_get,
+	lib.ethdev.cman_info_get)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_cman_config_init,
+	lib.ethdev.cman_config_init)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_cman_config_set,
+	lib.ethdev.cman_config_set)
+
+RTE_TRACE_POINT_REGISTER(rte_eth_trace_cman_config_get,
+	lib.ethdev.cman_config_get)
diff --git a/lib/ethdev/meson.build b/lib/ethdev/meson.build
index 39250b5da18ba..7835c966010cf 100644
--- a/lib/ethdev/meson.build
+++ b/lib/ethdev/meson.build
@@ -22,7 +22,6 @@ sources = files(
 headers = files(
         'rte_cman.h',
         'rte_ethdev.h',
-        'rte_ethdev_trace.h',
         'rte_ethdev_trace_fp.h',
         'rte_dev_info.h',
         'rte_flow.h',
@@ -41,6 +40,7 @@ indirect_headers += files(
 driver_sdk_headers += files(
         'ethdev_driver.h',
         'ethdev_pci.h',
+        'ethdev_trace.h',
         'ethdev_vdev.h',
 )
 
diff --git a/lib/ethdev/rte_ethdev.c b/lib/ethdev/rte_ethdev.c
index 5d5e18db1e016..6c7aa1801a937 100644
--- a/lib/ethdev/rte_ethdev.c
+++ b/lib/ethdev/rte_ethdev.c
@@ -27,11 +27,12 @@
 #include <rte_ether.h>
 #include <rte_telemetry.h>
 
-#include "rte_ethdev_trace.h"
 #include "rte_ethdev.h"
+#include "rte_ethdev_trace_fp.h"
 #include "ethdev_driver.h"
 #include "ethdev_profile.h"
 #include "ethdev_private.h"
+#include "ethdev_trace.h"
 #include "sff_telemetry.h"
 
 struct rte_eth_dev rte_eth_devices[RTE_MAX_ETHPORTS];
@@ -259,6 +260,9 @@ rte_eth_iterator_init(struct rte_dev_iterator *iter, const char *devargs_str)
 end:
 	iter->cls = rte_class_find_by_name("eth");
 	rte_devargs_reset(&devargs);
+
+	rte_eth_trace_iterator_init(devargs_str);
+
 	return 0;
 
 error:
@@ -297,8 +301,13 @@ rte_eth_iterator_next(struct rte_dev_iterator *iter)
 		/* A device is matching bus part, need to check ethdev part. */
 		iter->class_device = iter->cls->dev_iterate(
 				iter->class_device, iter->cls_str, iter);
-		if (iter->class_device != NULL)
-			return eth_dev_to_id(iter->class_device); /* match */
+		if (iter->class_device != NULL) {
+			uint16_t id = eth_dev_to_id(iter->class_device);
+
+			rte_eth_trace_iterator_next(iter, id);
+
+			return id; /* match */
+		}
 	} while (iter->bus != NULL); /* need to try next rte_device */
 
 	/* No more ethdev port to iterate. */
@@ -316,6 +325,9 @@ rte_eth_iterator_cleanup(struct rte_dev_iterator *iter)
 
 	if (iter->bus_str == NULL)
 		return; /* nothing to free in pure class filter */
+
+	rte_eth_trace_iterator_cleanup(iter);
+
 	free(RTE_CAST_FIELD(iter, bus_str, char *)); /* workaround const */
 	free(RTE_CAST_FIELD(iter, cls_str, char *)); /* workaround const */
 	memset(iter, 0, sizeof(*iter));
@@ -331,6 +343,8 @@ rte_eth_find_next(uint16_t port_id)
 	if (port_id >= RTE_MAX_ETHPORTS)
 		return RTE_MAX_ETHPORTS;
 
+	rte_eth_trace_find_next(port_id);
+
 	return port_id;
 }
 
@@ -351,15 +365,23 @@ rte_eth_find_next_of(uint16_t port_id, const struct rte_device *parent)
 			rte_eth_devices[port_id].device != parent)
 		port_id = rte_eth_find_next(port_id + 1);
 
+	rte_eth_trace_find_next_of(port_id, parent);
+
 	return port_id;
 }
 
 uint16_t
 rte_eth_find_next_sibling(uint16_t port_id, uint16_t ref_port_id)
 {
+	uint16_t ret;
+
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(ref_port_id, RTE_MAX_ETHPORTS);
-	return rte_eth_find_next_of(port_id,
+	ret = rte_eth_find_next_of(port_id,
 			rte_eth_devices[ref_port_id].device);
+
+	rte_eth_trace_find_next_sibling(port_id, ref_port_id, ret);
+
+	return ret;
 }
 
 static bool
@@ -371,11 +393,17 @@ eth_dev_is_allocated(const struct rte_eth_dev *ethdev)
 int
 rte_eth_dev_is_valid_port(uint16_t port_id)
 {
+	int is_valid;
+
 	if (port_id >= RTE_MAX_ETHPORTS ||
 	    (rte_eth_devices[port_id].state == RTE_ETH_DEV_UNUSED))
-		return 0;
+		is_valid = 0;
 	else
-		return 1;
+		is_valid = 1;
+
+	rte_ethdev_trace_is_valid_port(port_id, is_valid);
+
+	return is_valid;
 }
 
 static int
@@ -395,6 +423,8 @@ rte_eth_find_next_owned_by(uint16_t port_id, const uint64_t owner_id)
 			rte_eth_devices[port_id].data->owner.id != owner_id)
 		port_id = rte_eth_find_next(port_id + 1);
 
+	rte_eth_trace_find_next_owned_by(port_id, owner_id);
+
 	return port_id;
 }
 
@@ -413,6 +443,9 @@ rte_eth_dev_owner_new(uint64_t *owner_id)
 	*owner_id = eth_dev_shared_data->next_owner_id++;
 
 	rte_spinlock_unlock(&eth_dev_shared_data->ownership_lock);
+
+	rte_ethdev_trace_owner_new(*owner_id);
+
 	return 0;
 }
 
@@ -476,6 +509,9 @@ rte_eth_dev_owner_set(const uint16_t port_id,
 	ret = eth_dev_owner_set(port_id, RTE_ETH_DEV_NO_OWNER, owner);
 
 	rte_spinlock_unlock(&eth_dev_shared_data->ownership_lock);
+
+	rte_ethdev_trace_owner_set(port_id, owner, ret);
+
 	return ret;
 }
 
@@ -493,6 +529,9 @@ rte_eth_dev_owner_unset(const uint16_t port_id, const uint64_t owner_id)
 	ret = eth_dev_owner_set(port_id, owner_id, &new_owner);
 
 	rte_spinlock_unlock(&eth_dev_shared_data->ownership_lock);
+
+	rte_ethdev_trace_owner_unset(port_id, owner_id, ret);
+
 	return ret;
 }
 
@@ -526,6 +565,8 @@ rte_eth_dev_owner_delete(const uint64_t owner_id)
 
 	rte_spinlock_unlock(&eth_dev_shared_data->ownership_lock);
 
+	rte_ethdev_trace_owner_delete(owner_id, ret);
+
 	return ret;
 }
 
@@ -555,6 +596,8 @@ rte_eth_dev_owner_get(const uint16_t port_id, struct rte_eth_dev_owner *owner)
 	rte_memcpy(owner, &ethdev->data->owner, sizeof(*owner));
 	rte_spinlock_unlock(&eth_dev_shared_data->ownership_lock);
 
+	rte_ethdev_trace_owner_get(port_id, owner);
+
 	return 0;
 }
 
@@ -570,14 +613,23 @@ rte_eth_dev_socket_id(uint16_t port_id)
 		if (socket_id == SOCKET_ID_ANY)
 			rte_errno = 0;
 	}
+
+	rte_ethdev_trace_socket_id(port_id, socket_id);
+
 	return socket_id;
 }
 
 void *
 rte_eth_dev_get_sec_ctx(uint16_t port_id)
 {
+	void *ctx;
+
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, NULL);
-	return rte_eth_devices[port_id].security_ctx;
+	ctx = rte_eth_devices[port_id].security_ctx;
+
+	rte_ethdev_trace_get_sec_ctx(port_id, ctx);
+
+	return ctx;
 }
 
 uint16_t
@@ -591,6 +643,8 @@ rte_eth_dev_count_avail(void)
 	RTE_ETH_FOREACH_DEV(p)
 		count++;
 
+	rte_ethdev_trace_count_avail(count);
+
 	return count;
 }
 
@@ -602,6 +656,8 @@ rte_eth_dev_count_total(void)
 	RTE_ETH_FOREACH_VALID_DEV(port)
 		count++;
 
+	rte_ethdev_trace_count_total(count);
+
 	return count;
 }
 
@@ -622,6 +678,9 @@ rte_eth_dev_get_name_by_port(uint16_t port_id, char *name)
 	 * because it might be overwritten by VDEV PMD */
 	tmp = eth_dev_shared_data->data[port_id].name;
 	strcpy(name, tmp);
+
+	rte_ethdev_trace_get_name_by_port(port_id, name);
+
 	return 0;
 }
 
@@ -644,6 +703,9 @@ rte_eth_dev_get_port_by_name(const char *name, uint16_t *port_id)
 	RTE_ETH_FOREACH_VALID_DEV(pid)
 		if (!strcmp(name, eth_dev_shared_data->data[pid].name)) {
 			*port_id = pid;
+
+			rte_ethdev_trace_get_port_by_name(name, *port_id);
+
 			return 0;
 		}
 
@@ -745,7 +807,11 @@ rte_eth_dev_rx_queue_start(uint16_t port_id, uint16_t rx_queue_id)
 		return 0;
 	}
 
-	return eth_err(port_id, dev->dev_ops->rx_queue_start(dev, rx_queue_id));
+	ret = eth_err(port_id, dev->dev_ops->rx_queue_start(dev, rx_queue_id));
+
+	rte_ethdev_trace_rx_queue_start(port_id, rx_queue_id, ret);
+
+	return ret;
 }
 
 int
@@ -778,7 +844,11 @@ rte_eth_dev_rx_queue_stop(uint16_t port_id, uint16_t rx_queue_id)
 		return 0;
 	}
 
-	return eth_err(port_id, dev->dev_ops->rx_queue_stop(dev, rx_queue_id));
+	ret = eth_err(port_id, dev->dev_ops->rx_queue_stop(dev, rx_queue_id));
+
+	rte_ethdev_trace_rx_queue_stop(port_id, rx_queue_id, ret);
+
+	return ret;
 }
 
 int
@@ -818,7 +888,11 @@ rte_eth_dev_tx_queue_start(uint16_t port_id, uint16_t tx_queue_id)
 		return 0;
 	}
 
-	return eth_err(port_id, dev->dev_ops->tx_queue_start(dev, tx_queue_id));
+	ret = eth_err(port_id, dev->dev_ops->tx_queue_start(dev, tx_queue_id));
+
+	rte_ethdev_trace_tx_queue_start(port_id, tx_queue_id, ret);
+
+	return ret;
 }
 
 int
@@ -851,42 +925,65 @@ rte_eth_dev_tx_queue_stop(uint16_t port_id, uint16_t tx_queue_id)
 		return 0;
 	}
 
-	return eth_err(port_id, dev->dev_ops->tx_queue_stop(dev, tx_queue_id));
+	ret = eth_err(port_id, dev->dev_ops->tx_queue_stop(dev, tx_queue_id));
+
+	rte_ethdev_trace_tx_queue_stop(port_id, tx_queue_id, ret);
+
+	return ret;
 }
 
 uint32_t
 rte_eth_speed_bitflag(uint32_t speed, int duplex)
 {
+	uint32_t ret;
+
 	switch (speed) {
 	case RTE_ETH_SPEED_NUM_10M:
-		return duplex ? RTE_ETH_LINK_SPEED_10M : RTE_ETH_LINK_SPEED_10M_HD;
+		ret = duplex ? RTE_ETH_LINK_SPEED_10M : RTE_ETH_LINK_SPEED_10M_HD;
+		break;
 	case RTE_ETH_SPEED_NUM_100M:
-		return duplex ? RTE_ETH_LINK_SPEED_100M : RTE_ETH_LINK_SPEED_100M_HD;
+		ret = duplex ? RTE_ETH_LINK_SPEED_100M : RTE_ETH_LINK_SPEED_100M_HD;
+		break;
 	case RTE_ETH_SPEED_NUM_1G:
-		return RTE_ETH_LINK_SPEED_1G;
+		ret = RTE_ETH_LINK_SPEED_1G;
+		break;
 	case RTE_ETH_SPEED_NUM_2_5G:
-		return RTE_ETH_LINK_SPEED_2_5G;
+		ret = RTE_ETH_LINK_SPEED_2_5G;
+		break;
 	case RTE_ETH_SPEED_NUM_5G:
-		return RTE_ETH_LINK_SPEED_5G;
+		ret = RTE_ETH_LINK_SPEED_5G;
+		break;
 	case RTE_ETH_SPEED_NUM_10G:
-		return RTE_ETH_LINK_SPEED_10G;
+		ret = RTE_ETH_LINK_SPEED_10G;
+		break;
 	case RTE_ETH_SPEED_NUM_20G:
-		return RTE_ETH_LINK_SPEED_20G;
+		ret = RTE_ETH_LINK_SPEED_20G;
+		break;
 	case RTE_ETH_SPEED_NUM_25G:
-		return RTE_ETH_LINK_SPEED_25G;
+		ret = RTE_ETH_LINK_SPEED_25G;
+		break;
 	case RTE_ETH_SPEED_NUM_40G:
-		return RTE_ETH_LINK_SPEED_40G;
+		ret = RTE_ETH_LINK_SPEED_40G;
+		break;
 	case RTE_ETH_SPEED_NUM_50G:
-		return RTE_ETH_LINK_SPEED_50G;
+		ret = RTE_ETH_LINK_SPEED_50G;
+		break;
 	case RTE_ETH_SPEED_NUM_56G:
-		return RTE_ETH_LINK_SPEED_56G;
+		ret = RTE_ETH_LINK_SPEED_56G;
+		break;
 	case RTE_ETH_SPEED_NUM_100G:
-		return RTE_ETH_LINK_SPEED_100G;
+		ret = RTE_ETH_LINK_SPEED_100G;
+		break;
 	case RTE_ETH_SPEED_NUM_200G:
-		return RTE_ETH_LINK_SPEED_200G;
+		ret = RTE_ETH_LINK_SPEED_200G;
+		break;
 	default:
-		return 0;
+		ret = 0;
 	}
+
+	rte_eth_trace_speed_bitflag(speed, duplex, ret);
+
+	return ret;
 }
 
 const char *
@@ -902,6 +999,8 @@ rte_eth_dev_rx_offload_name(uint64_t offload)
 		}
 	}
 
+	rte_ethdev_trace_rx_offload_name(offload, name);
+
 	return name;
 }
 
@@ -918,6 +1017,8 @@ rte_eth_dev_tx_offload_name(uint64_t offload)
 		}
 	}
 
+	rte_ethdev_trace_tx_offload_name(offload, name);
+
 	return name;
 }
 
@@ -934,6 +1035,8 @@ rte_eth_dev_capability_name(uint64_t capability)
 		}
 	}
 
+	rte_ethdev_trace_capability_name(capability, name);
+
 	return name;
 }
 
@@ -1554,26 +1657,36 @@ int
 rte_eth_dev_set_link_up(uint16_t port_id)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
 
 	if (*dev->dev_ops->dev_set_link_up == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->dev_set_link_up)(dev));
+	ret = eth_err(port_id, (*dev->dev_ops->dev_set_link_up)(dev));
+
+	rte_ethdev_trace_set_link_up(port_id, ret);
+
+	return ret;
 }
 
 int
 rte_eth_dev_set_link_down(uint16_t port_id)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
 
 	if (*dev->dev_ops->dev_set_link_down == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->dev_set_link_down)(dev));
+	ret = eth_err(port_id, (*dev->dev_ops->dev_set_link_down)(dev));
+
+	rte_ethdev_trace_set_link_down(port_id, ret);
+
+	return ret;
 }
 
 int
@@ -1628,9 +1741,11 @@ rte_eth_dev_reset(uint16_t port_id)
 			"Failed to stop device (port %u) before reset: %s - ignore\n",
 			port_id, rte_strerror(-ret));
 	}
-	ret = dev->dev_ops->dev_reset(dev);
+	ret = eth_err(port_id, dev->dev_ops->dev_reset(dev));
 
-	return eth_err(port_id, ret);
+	rte_ethdev_trace_reset(port_id, ret);
+
+	return ret;
 }
 
 int
@@ -1653,6 +1768,8 @@ rte_eth_dev_is_removed(uint16_t port_id)
 		/* Device is physically removed. */
 		dev->state = RTE_ETH_DEV_REMOVED;
 
+	rte_ethdev_trace_is_removed(port_id, ret);
+
 	return ret;
 }
 
@@ -2151,7 +2268,12 @@ rte_eth_rx_hairpin_queue_setup(uint16_t port_id, uint16_t rx_queue_id,
 	if (ret == 0)
 		dev->data->rx_queue_state[rx_queue_id] =
 			RTE_ETH_QUEUE_STATE_HAIRPIN;
-	return eth_err(port_id, ret);
+	ret = eth_err(port_id, ret);
+
+	rte_eth_trace_rx_hairpin_queue_setup(port_id, rx_queue_id, nb_rx_desc,
+					     conf, ret);
+
+	return ret;
 }
 
 int
@@ -2340,7 +2462,12 @@ rte_eth_tx_hairpin_queue_setup(uint16_t port_id, uint16_t tx_queue_id,
 	if (ret == 0)
 		dev->data->tx_queue_state[tx_queue_id] =
 			RTE_ETH_QUEUE_STATE_HAIRPIN;
-	return eth_err(port_id, ret);
+	ret = eth_err(port_id, ret);
+
+	rte_eth_trace_tx_hairpin_queue_setup(port_id, tx_queue_id, nb_tx_desc,
+					     conf, ret);
+
+	return ret;
 }
 
 int
@@ -2365,6 +2492,8 @@ rte_eth_hairpin_bind(uint16_t tx_port, uint16_t rx_port)
 			       " to Rx %d (%d - all ports)\n",
 			       tx_port, rx_port, RTE_MAX_ETHPORTS);
 
+	rte_eth_trace_hairpin_bind(tx_port, rx_port, ret);
+
 	return ret;
 }
 
@@ -2390,6 +2519,8 @@ rte_eth_hairpin_unbind(uint16_t tx_port, uint16_t rx_port)
 			       " from Rx %d (%d - all ports)\n",
 			       tx_port, rx_port, RTE_MAX_ETHPORTS);
 
+	rte_eth_trace_hairpin_unbind(tx_port, rx_port, ret);
+
 	return ret;
 }
 
@@ -2426,6 +2557,9 @@ rte_eth_hairpin_get_peer_ports(uint16_t port_id, uint16_t *peer_ports,
 		RTE_ETHDEV_LOG(ERR, "Failed to get %d hairpin peer %s ports\n",
 			       port_id, direction ? "Rx" : "Tx");
 
+	rte_eth_trace_hairpin_get_peer_ports(port_id, peer_ports, len,
+					     direction, ret);
+
 	return ret;
 }
 
@@ -2434,6 +2568,8 @@ rte_eth_tx_buffer_drop_callback(struct rte_mbuf **pkts, uint16_t unsent,
 		void *userdata __rte_unused)
 {
 	rte_pktmbuf_free_bulk(pkts, unsent);
+
+	rte_eth_trace_tx_buffer_drop_callback((void **)pkts, unsent);
 }
 
 void
@@ -2444,6 +2580,8 @@ rte_eth_tx_buffer_count_callback(struct rte_mbuf **pkts, uint16_t unsent,
 
 	rte_pktmbuf_free_bulk(pkts, unsent);
 	*count += unsent;
+
+	rte_eth_trace_tx_buffer_count_callback((void **)pkts, unsent, *count);
 }
 
 int
@@ -2458,6 +2596,9 @@ rte_eth_tx_buffer_set_err_callback(struct rte_eth_dev_tx_buffer *buffer,
 
 	buffer->error_callback = cbfn;
 	buffer->error_userdata = userdata;
+
+	rte_eth_trace_tx_buffer_set_err_callback(buffer);
+
 	return 0;
 }
 
@@ -2477,6 +2618,8 @@ rte_eth_tx_buffer_init(struct rte_eth_dev_tx_buffer *buffer, uint16_t size)
 			buffer, rte_eth_tx_buffer_drop_callback, NULL);
 	}
 
+	rte_eth_trace_tx_buffer_init(buffer, size, ret);
+
 	return ret;
 }
 
@@ -2495,7 +2638,11 @@ rte_eth_tx_done_cleanup(uint16_t port_id, uint16_t queue_id, uint32_t free_cnt)
 	/* Call driver to free pending mbufs. */
 	ret = (*dev->dev_ops->tx_done_cleanup)(dev->data->tx_queues[queue_id],
 					       free_cnt);
-	return eth_err(port_id, ret);
+	ret = eth_err(port_id, ret);
+
+	rte_eth_trace_tx_done_cleanup(port_id, queue_id, free_cnt, ret);
+
+	return ret;
 }
 
 int
@@ -2516,7 +2663,12 @@ rte_eth_promiscuous_enable(uint16_t port_id)
 	diag = (*dev->dev_ops->promiscuous_enable)(dev);
 	dev->data->promiscuous = (diag == 0) ? 1 : 0;
 
-	return eth_err(port_id, diag);
+	diag = eth_err(port_id, diag);
+
+	rte_eth_trace_promiscuous_enable(port_id, dev->data->promiscuous,
+					 diag);
+
+	return diag;
 }
 
 int
@@ -2539,7 +2691,12 @@ rte_eth_promiscuous_disable(uint16_t port_id)
 	if (diag != 0)
 		dev->data->promiscuous = 1;
 
-	return eth_err(port_id, diag);
+	diag = eth_err(port_id, diag);
+
+	rte_eth_trace_promiscuous_disable(port_id, dev->data->promiscuous,
+					  diag);
+
+	return diag;
 }
 
 int
@@ -2550,6 +2707,8 @@ rte_eth_promiscuous_get(uint16_t port_id)
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
 
+	rte_eth_trace_promiscuous_get(port_id, dev->data->promiscuous);
+
 	return dev->data->promiscuous;
 }
 
@@ -2570,7 +2729,12 @@ rte_eth_allmulticast_enable(uint16_t port_id)
 	diag = (*dev->dev_ops->allmulticast_enable)(dev);
 	dev->data->all_multicast = (diag == 0) ? 1 : 0;
 
-	return eth_err(port_id, diag);
+	diag = eth_err(port_id, diag);
+
+	rte_eth_trace_allmulticast_enable(port_id, dev->data->all_multicast,
+					  diag);
+
+	return diag;
 }
 
 int
@@ -2592,7 +2756,12 @@ rte_eth_allmulticast_disable(uint16_t port_id)
 	if (diag != 0)
 		dev->data->all_multicast = 1;
 
-	return eth_err(port_id, diag);
+	diag = eth_err(port_id, diag);
+
+	rte_eth_trace_allmulticast_disable(port_id, dev->data->all_multicast,
+					   diag);
+
+	return diag;
 }
 
 int
@@ -2603,6 +2772,8 @@ rte_eth_allmulticast_get(uint16_t port_id)
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
 
+	rte_eth_trace_allmulticast_get(port_id, dev->data->all_multicast);
+
 	return dev->data->all_multicast;
 }
 
@@ -2629,6 +2800,8 @@ rte_eth_link_get(uint16_t port_id, struct rte_eth_link *eth_link)
 		*eth_link = dev->data->dev_link;
 	}
 
+	rte_eth_trace_link_get(port_id, eth_link);
+
 	return 0;
 }
 
@@ -2655,35 +2828,76 @@ rte_eth_link_get_nowait(uint16_t port_id, struct rte_eth_link *eth_link)
 		*eth_link = dev->data->dev_link;
 	}
 
+	rte_eth_trace_link_get_nowait(port_id, eth_link);
+
 	return 0;
 }
 
 const char *
 rte_eth_link_speed_to_str(uint32_t link_speed)
 {
+	const char *ret;
+
 	switch (link_speed) {
-	case RTE_ETH_SPEED_NUM_NONE: return "None";
-	case RTE_ETH_SPEED_NUM_10M:  return "10 Mbps";
-	case RTE_ETH_SPEED_NUM_100M: return "100 Mbps";
-	case RTE_ETH_SPEED_NUM_1G:   return "1 Gbps";
-	case RTE_ETH_SPEED_NUM_2_5G: return "2.5 Gbps";
-	case RTE_ETH_SPEED_NUM_5G:   return "5 Gbps";
-	case RTE_ETH_SPEED_NUM_10G:  return "10 Gbps";
-	case RTE_ETH_SPEED_NUM_20G:  return "20 Gbps";
-	case RTE_ETH_SPEED_NUM_25G:  return "25 Gbps";
-	case RTE_ETH_SPEED_NUM_40G:  return "40 Gbps";
-	case RTE_ETH_SPEED_NUM_50G:  return "50 Gbps";
-	case RTE_ETH_SPEED_NUM_56G:  return "56 Gbps";
-	case RTE_ETH_SPEED_NUM_100G: return "100 Gbps";
-	case RTE_ETH_SPEED_NUM_200G: return "200 Gbps";
-	case RTE_ETH_SPEED_NUM_UNKNOWN: return "Unknown";
-	default: return "Invalid";
+	case RTE_ETH_SPEED_NUM_NONE:
+		ret = "None";
+		break;
+	case RTE_ETH_SPEED_NUM_10M:
+		ret = "10 Mbps";
+		break;
+	case RTE_ETH_SPEED_NUM_100M:
+		ret = "100 Mbps";
+		break;
+	case RTE_ETH_SPEED_NUM_1G:
+		ret = "1 Gbps";
+		break;
+	case RTE_ETH_SPEED_NUM_2_5G:
+		ret = "2.5 Gbps";
+		break;
+	case RTE_ETH_SPEED_NUM_5G:
+		ret = "5 Gbps";
+		break;
+	case RTE_ETH_SPEED_NUM_10G:
+		ret = "10 Gbps";
+		break;
+	case RTE_ETH_SPEED_NUM_20G:
+		ret = "20 Gbps";
+		break;
+	case RTE_ETH_SPEED_NUM_25G:
+		ret = "25 Gbps";
+		break;
+	case RTE_ETH_SPEED_NUM_40G:
+		ret = "40 Gbps";
+		break;
+	case RTE_ETH_SPEED_NUM_50G:
+		ret = "50 Gbps";
+		break;
+	case RTE_ETH_SPEED_NUM_56G:
+		ret = "56 Gbps";
+		break;
+	case RTE_ETH_SPEED_NUM_100G:
+		ret = "100 Gbps";
+		break;
+	case RTE_ETH_SPEED_NUM_200G:
+		ret = "200 Gbps";
+		break;
+	case RTE_ETH_SPEED_NUM_UNKNOWN:
+		ret = "Unknown";
+		break;
+	default:
+		ret = "Invalid";
 	}
+
+	rte_eth_trace_link_speed_to_str(link_speed, ret);
+
+	return ret;
 }
 
 int
 rte_eth_link_to_str(char *str, size_t len, const struct rte_eth_link *eth_link)
 {
+	int ret;
+
 	if (str == NULL) {
 		RTE_ETHDEV_LOG(ERR, "Cannot convert link to NULL string\n");
 		return -EINVAL;
@@ -2701,20 +2915,25 @@ rte_eth_link_to_str(char *str, size_t len, const struct rte_eth_link *eth_link)
 	}
 
 	if (eth_link->link_status == RTE_ETH_LINK_DOWN)
-		return snprintf(str, len, "Link down");
+		ret = snprintf(str, len, "Link down");
 	else
-		return snprintf(str, len, "Link up at %s %s %s",
+		ret = snprintf(str, len, "Link up at %s %s %s",
 			rte_eth_link_speed_to_str(eth_link->link_speed),
 			(eth_link->link_duplex == RTE_ETH_LINK_FULL_DUPLEX) ?
 			"FDX" : "HDX",
 			(eth_link->link_autoneg == RTE_ETH_LINK_AUTONEG) ?
 			"Autoneg" : "Fixed");
+
+	rte_eth_trace_link_to_str(len, eth_link, str, ret);
+
+	return ret;
 }
 
 int
 rte_eth_stats_get(uint16_t port_id, struct rte_eth_stats *stats)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -2730,7 +2949,11 @@ rte_eth_stats_get(uint16_t port_id, struct rte_eth_stats *stats)
 	if (*dev->dev_ops->stats_get == NULL)
 		return -ENOTSUP;
 	stats->rx_nombuf = dev->data->rx_mbuf_alloc_failed;
-	return eth_err(port_id, (*dev->dev_ops->stats_get)(dev, stats));
+	ret = eth_err(port_id, (*dev->dev_ops->stats_get)(dev, stats));
+
+	rte_eth_trace_stats_get(port_id, stats, ret);
+
+	return ret;
 }
 
 int
@@ -2750,6 +2973,8 @@ rte_eth_stats_reset(uint16_t port_id)
 
 	dev->data->rx_mbuf_alloc_failed = 0;
 
+	rte_eth_trace_stats_reset(port_id);
+
 	return 0;
 }
 
@@ -2833,6 +3058,10 @@ rte_eth_xstats_get_id_by_name(uint16_t port_id, const char *xstat_name,
 	for (idx_xstat = 0; idx_xstat < cnt_xstats; idx_xstat++) {
 		if (!strcmp(xstats_names[idx_xstat].name, xstat_name)) {
 			*id = idx_xstat;
+
+			rte_eth_trace_xstats_get_id_by_name(port_id,
+							    xstat_name, *id);
+
 			return 0;
 		};
 	}
@@ -2986,6 +3215,9 @@ rte_eth_xstats_get_names_by_id(uint16_t port_id,
 			return -1;
 		}
 		xstats_names[i] = xstats_names_copy[ids[i]];
+
+		rte_eth_trace_xstats_get_names_by_id(port_id, &xstats_names[i],
+						     ids[i]);
 	}
 
 	free(xstats_names_copy);
@@ -3001,6 +3233,7 @@ rte_eth_xstats_get_names(uint16_t port_id,
 	int cnt_used_entries;
 	int cnt_expected_entries;
 	int cnt_driver_entries;
+	int i;
 
 	cnt_expected_entries = eth_dev_get_xstats_count(port_id);
 	if (xstats_names == NULL || cnt_expected_entries < 0 ||
@@ -3025,6 +3258,10 @@ rte_eth_xstats_get_names(uint16_t port_id,
 		cnt_used_entries += cnt_driver_entries;
 	}
 
+	for (i = 0; i < cnt_used_entries; i++)
+		rte_eth_trace_xstats_get_names(port_id, i, xstats_names[i],
+					       size, cnt_used_entries);
+
 	return cnt_used_entries;
 }
 
@@ -3174,6 +3411,9 @@ rte_eth_xstats_get_by_id(uint16_t port_id, const uint64_t *ids,
 		}
 		values[i] = xstats[ids[i]].value;
 	}
+
+	rte_eth_trace_xstats_get_by_id(port_id, ids, values, size);
+
 	return size;
 }
 
@@ -3221,6 +3461,9 @@ rte_eth_xstats_get(uint16_t port_id, struct rte_eth_xstat *xstats,
 	for ( ; i < count + xcount; i++)
 		xstats[i].id += count;
 
+	for (i = 0; i < n; i++)
+		rte_eth_trace_xstats_get(port_id, xstats[i]);
+
 	return count + xcount;
 }
 
@@ -3234,8 +3477,13 @@ rte_eth_xstats_reset(uint16_t port_id)
 	dev = &rte_eth_devices[port_id];
 
 	/* implemented by the driver */
-	if (dev->dev_ops->xstats_reset != NULL)
-		return eth_err(port_id, (*dev->dev_ops->xstats_reset)(dev));
+	if (dev->dev_ops->xstats_reset != NULL) {
+		int ret = eth_err(port_id, (*dev->dev_ops->xstats_reset)(dev));
+
+		rte_eth_trace_xstats_reset(port_id, ret);
+
+		return ret;
+	}
 
 	/* fallback to default */
 	return rte_eth_stats_reset(port_id);
@@ -3268,24 +3516,39 @@ int
 rte_eth_dev_set_tx_queue_stats_mapping(uint16_t port_id, uint16_t tx_queue_id,
 		uint8_t stat_idx)
 {
-	return eth_err(port_id, eth_dev_set_queue_stats_mapping(port_id,
+	int ret;
+
+	ret = eth_err(port_id, eth_dev_set_queue_stats_mapping(port_id,
 						tx_queue_id,
 						stat_idx, STAT_QMAP_TX));
+
+	rte_ethdev_trace_set_tx_queue_stats_mapping(port_id, tx_queue_id,
+						    stat_idx, ret);
+
+	return ret;
 }
 
 int
 rte_eth_dev_set_rx_queue_stats_mapping(uint16_t port_id, uint16_t rx_queue_id,
 		uint8_t stat_idx)
 {
-	return eth_err(port_id, eth_dev_set_queue_stats_mapping(port_id,
+	int ret;
+
+	ret = eth_err(port_id, eth_dev_set_queue_stats_mapping(port_id,
 						rx_queue_id,
 						stat_idx, STAT_QMAP_RX));
+
+	rte_ethdev_trace_set_rx_queue_stats_mapping(port_id, rx_queue_id,
+						    stat_idx, ret);
+
+	return ret;
 }
 
 int
 rte_eth_dev_fw_version_get(uint16_t port_id, char *fw_version, size_t fw_size)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -3299,8 +3562,12 @@ rte_eth_dev_fw_version_get(uint16_t port_id, char *fw_version, size_t fw_size)
 
 	if (*dev->dev_ops->fw_version_get == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->fw_version_get)(dev,
+	ret = eth_err(port_id, (*dev->dev_ops->fw_version_get)(dev,
 							fw_version, fw_size));
+
+	rte_ethdev_trace_fw_version_get(port_id, fw_version, fw_size, ret);
+
+	return ret;
 }
 
 int
@@ -3360,6 +3627,8 @@ rte_eth_dev_info_get(uint16_t port_id, struct rte_eth_dev_info *dev_info)
 
 	dev_info->dev_flags = &dev->data->dev_flags;
 
+	rte_ethdev_trace_info_get(port_id, dev_info);
+
 	return 0;
 }
 
@@ -3380,6 +3649,8 @@ rte_eth_dev_conf_get(uint16_t port_id, struct rte_eth_conf *dev_conf)
 
 	memcpy(dev_conf, &dev->data->dev_conf, sizeof(struct rte_eth_conf));
 
+	rte_ethdev_trace_conf_get(port_id, dev_conf);
+
 	return 0;
 }
 
@@ -3410,8 +3681,12 @@ rte_eth_dev_get_supported_ptypes(uint16_t port_id, uint32_t ptype_mask,
 
 	for (i = 0, j = 0; all_ptypes[i] != RTE_PTYPE_UNKNOWN; ++i)
 		if (all_ptypes[i] & ptype_mask) {
-			if (j < num)
+			if (j < num) {
 				ptypes[j] = all_ptypes[i];
+
+				rte_ethdev_trace_get_supported_ptypes(port_id,
+						j, num, ptypes[j]);
+			}
 			j++;
 		}
 
@@ -3489,6 +3764,10 @@ rte_eth_dev_set_ptypes(uint16_t port_id, uint32_t ptype_mask,
 		if (ptype_mask & all_ptypes[i]) {
 			if (j < num - 1) {
 				set_ptypes[j] = all_ptypes[i];
+
+				rte_ethdev_trace_set_ptypes(port_id, j, num,
+						set_ptypes[j]);
+
 				j++;
 				continue;
 			}
@@ -3530,6 +3809,8 @@ rte_eth_macaddrs_get(uint16_t port_id, struct rte_ether_addr *ma,
 	num = RTE_MIN(dev_info.max_mac_addrs, num);
 	memcpy(ma, dev->data->mac_addrs, num * sizeof(ma[0]));
 
+	rte_eth_trace_macaddrs_get(port_id, num);
+
 	return num;
 }
 
@@ -3550,6 +3831,8 @@ rte_eth_macaddr_get(uint16_t port_id, struct rte_ether_addr *mac_addr)
 
 	rte_ether_addr_copy(&dev->data->mac_addrs[0], mac_addr);
 
+	rte_eth_trace_macaddr_get(port_id, mac_addr);
+
 	return 0;
 }
 
@@ -3568,6 +3851,9 @@ rte_eth_dev_get_mtu(uint16_t port_id, uint16_t *mtu)
 	}
 
 	*mtu = dev->data->mtu;
+
+	rte_ethdev_trace_get_mtu(port_id, *mtu);
+
 	return 0;
 }
 
@@ -3610,7 +3896,11 @@ rte_eth_dev_set_mtu(uint16_t port_id, uint16_t mtu)
 	if (ret == 0)
 		dev->data->mtu = mtu;
 
-	return eth_err(port_id, ret);
+	ret = eth_err(port_id, ret);
+
+	rte_ethdev_trace_set_mtu(port_id, mtu, ret);
+
+	return ret;
 }
 
 int
@@ -3653,7 +3943,11 @@ rte_eth_dev_vlan_filter(uint16_t port_id, uint16_t vlan_id, int on)
 			vfc->ids[vidx] &= ~RTE_BIT64(vbit);
 	}
 
-	return eth_err(port_id, ret);
+	ret = eth_err(port_id, ret);
+
+	rte_ethdev_trace_vlan_filter(port_id, vlan_id, on, ret);
+
+	return ret;
 }
 
 int
@@ -3674,6 +3968,8 @@ rte_eth_dev_set_vlan_strip_on_queue(uint16_t port_id, uint16_t rx_queue_id,
 		return -ENOTSUP;
 	(*dev->dev_ops->vlan_strip_queue_set)(dev, rx_queue_id, on);
 
+	rte_ethdev_trace_set_vlan_strip_on_queue(port_id, rx_queue_id, on);
+
 	return 0;
 }
 
@@ -3683,14 +3979,19 @@ rte_eth_dev_set_vlan_ether_type(uint16_t port_id,
 				uint16_t tpid)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
 
 	if (*dev->dev_ops->vlan_tpid_set == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->vlan_tpid_set)(dev, vlan_type,
-							       tpid));
+	ret = eth_err(port_id, (*dev->dev_ops->vlan_tpid_set)(dev, vlan_type,
+							      tpid));
+
+	rte_ethdev_trace_set_vlan_ether_type(port_id, vlan_type, tpid, ret);
+
+	return ret;
 }
 
 int
@@ -3782,7 +4083,11 @@ rte_eth_dev_set_vlan_offload(uint16_t port_id, int offload_mask)
 		dev->data->dev_conf.rxmode.offloads = orig_offloads;
 	}
 
-	return eth_err(port_id, ret);
+	ret = eth_err(port_id, ret);
+
+	rte_ethdev_trace_set_vlan_offload(port_id, offload_mask, ret);
+
+	return ret;
 }
 
 int
@@ -3808,6 +4113,8 @@ rte_eth_dev_get_vlan_offload(uint16_t port_id)
 	if (*dev_offloads & RTE_ETH_RX_OFFLOAD_QINQ_STRIP)
 		ret |= RTE_ETH_QINQ_STRIP_OFFLOAD;
 
+	rte_ethdev_trace_get_vlan_offload(port_id, ret);
+
 	return ret;
 }
 
@@ -3815,19 +4122,25 @@ int
 rte_eth_dev_set_vlan_pvid(uint16_t port_id, uint16_t pvid, int on)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
 
 	if (*dev->dev_ops->vlan_pvid_set == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->vlan_pvid_set)(dev, pvid, on));
+	ret = eth_err(port_id, (*dev->dev_ops->vlan_pvid_set)(dev, pvid, on));
+
+	rte_ethdev_trace_set_vlan_pvid(port_id, pvid, on, ret);
+
+	return ret;
 }
 
 int
 rte_eth_dev_flow_ctrl_get(uint16_t port_id, struct rte_eth_fc_conf *fc_conf)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -3842,13 +4155,18 @@ rte_eth_dev_flow_ctrl_get(uint16_t port_id, struct rte_eth_fc_conf *fc_conf)
 	if (*dev->dev_ops->flow_ctrl_get == NULL)
 		return -ENOTSUP;
 	memset(fc_conf, 0, sizeof(*fc_conf));
-	return eth_err(port_id, (*dev->dev_ops->flow_ctrl_get)(dev, fc_conf));
+	ret = eth_err(port_id, (*dev->dev_ops->flow_ctrl_get)(dev, fc_conf));
+
+	rte_ethdev_trace_flow_ctrl_get(port_id, fc_conf, ret);
+
+	return ret;
 }
 
 int
 rte_eth_dev_flow_ctrl_set(uint16_t port_id, struct rte_eth_fc_conf *fc_conf)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -3867,7 +4185,11 @@ rte_eth_dev_flow_ctrl_set(uint16_t port_id, struct rte_eth_fc_conf *fc_conf)
 
 	if (*dev->dev_ops->flow_ctrl_set == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->flow_ctrl_set)(dev, fc_conf));
+	ret = eth_err(port_id, (*dev->dev_ops->flow_ctrl_set)(dev, fc_conf));
+
+	rte_ethdev_trace_flow_ctrl_set(port_id, fc_conf, ret);
+
+	return ret;
 }
 
 int
@@ -3875,6 +4197,7 @@ rte_eth_dev_priority_flow_ctrl_set(uint16_t port_id,
 				   struct rte_eth_pfc_conf *pfc_conf)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -3892,10 +4215,14 @@ rte_eth_dev_priority_flow_ctrl_set(uint16_t port_id,
 	}
 
 	/* High water, low water validation are device specific */
-	if  (*dev->dev_ops->priority_flow_ctrl_set)
-		return eth_err(port_id, (*dev->dev_ops->priority_flow_ctrl_set)
-					(dev, pfc_conf));
-	return -ENOTSUP;
+	if  (*dev->dev_ops->priority_flow_ctrl_set == NULL)
+		return -ENOTSUP;
+	ret = eth_err(port_id, (*dev->dev_ops->priority_flow_ctrl_set)
+			       (dev, pfc_conf));
+
+	rte_ethdev_trace_priority_flow_ctrl_set(port_id, pfc_conf, ret);
+
+	return ret;
 }
 
 static int
@@ -3953,6 +4280,7 @@ rte_eth_dev_priority_flow_ctrl_queue_info_get(uint16_t port_id,
 		struct rte_eth_pfc_queue_info *pfc_queue_info)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -3963,10 +4291,15 @@ rte_eth_dev_priority_flow_ctrl_queue_info_get(uint16_t port_id,
 		return -EINVAL;
 	}
 
-	if (*dev->dev_ops->priority_flow_ctrl_queue_info_get)
-		return eth_err(port_id, (*dev->dev_ops->priority_flow_ctrl_queue_info_get)
+	if (*dev->dev_ops->priority_flow_ctrl_queue_info_get == NULL)
+		return -ENOTSUP;
+	ret = eth_err(port_id, (*dev->dev_ops->priority_flow_ctrl_queue_info_get)
 			(dev, pfc_queue_info));
-	return -ENOTSUP;
+
+	rte_ethdev_trace_priority_flow_ctrl_queue_info_get(port_id,
+						pfc_queue_info, ret);
+
+	return ret;
 }
 
 int
@@ -4034,11 +4367,15 @@ rte_eth_dev_priority_flow_ctrl_queue_configure(uint16_t port_id,
 			return ret;
 	}
 
-	if (*dev->dev_ops->priority_flow_ctrl_queue_config)
-		return eth_err(port_id,
-			       (*dev->dev_ops->priority_flow_ctrl_queue_config)(
-				dev, pfc_queue_conf));
-	return -ENOTSUP;
+	if (*dev->dev_ops->priority_flow_ctrl_queue_config == NULL)
+		return -ENOTSUP;
+	ret = eth_err(port_id, (*dev->dev_ops->priority_flow_ctrl_queue_config)
+			(dev, pfc_queue_conf));
+
+	rte_ethdev_trace_priority_flow_ctrl_queue_configure(port_id,
+						pfc_queue_conf, ret);
+
+	return ret;
 }
 
 static int
@@ -4129,8 +4466,12 @@ rte_eth_dev_rss_reta_update(uint16_t port_id,
 
 	if (*dev->dev_ops->reta_update == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->reta_update)(dev, reta_conf,
-							     reta_size));
+	ret = eth_err(port_id, (*dev->dev_ops->reta_update)(dev, reta_conf,
+							    reta_size));
+
+	rte_ethdev_trace_rss_reta_update(port_id, reta_conf, reta_size, ret);
+
+	return ret;
 }
 
 int
@@ -4158,8 +4499,12 @@ rte_eth_dev_rss_reta_query(uint16_t port_id,
 
 	if (*dev->dev_ops->reta_query == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->reta_query)(dev, reta_conf,
-							    reta_size));
+	ret = eth_err(port_id, (*dev->dev_ops->reta_query)(dev, reta_conf,
+							   reta_size));
+
+	rte_ethdev_trace_rss_reta_query(port_id, reta_conf, reta_size, ret);
+
+	return ret;
 }
 
 int
@@ -4203,8 +4548,12 @@ rte_eth_dev_rss_hash_update(uint16_t port_id,
 
 	if (*dev->dev_ops->rss_hash_update == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->rss_hash_update)(dev,
-								 rss_conf));
+	ret = eth_err(port_id, (*dev->dev_ops->rss_hash_update)(dev,
+								rss_conf));
+
+	rte_ethdev_trace_rss_hash_update(port_id, rss_conf, ret);
+
+	return ret;
 }
 
 int
@@ -4212,6 +4561,7 @@ rte_eth_dev_rss_hash_conf_get(uint16_t port_id,
 			      struct rte_eth_rss_conf *rss_conf)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -4225,8 +4575,12 @@ rte_eth_dev_rss_hash_conf_get(uint16_t port_id,
 
 	if (*dev->dev_ops->rss_hash_conf_get == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->rss_hash_conf_get)(dev,
-								   rss_conf));
+	ret = eth_err(port_id, (*dev->dev_ops->rss_hash_conf_get)(dev,
+								  rss_conf));
+
+	rte_ethdev_trace_rss_hash_conf_get(port_id, rss_conf, ret);
+
+	return ret;
 }
 
 int
@@ -4234,6 +4588,7 @@ rte_eth_dev_udp_tunnel_port_add(uint16_t port_id,
 				struct rte_eth_udp_tunnel *udp_tunnel)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -4252,8 +4607,12 @@ rte_eth_dev_udp_tunnel_port_add(uint16_t port_id,
 
 	if (*dev->dev_ops->udp_tunnel_port_add == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->udp_tunnel_port_add)(dev,
+	ret = eth_err(port_id, (*dev->dev_ops->udp_tunnel_port_add)(dev,
 								udp_tunnel));
+
+	rte_ethdev_trace_udp_tunnel_port_add(port_id, udp_tunnel, ret);
+
+	return ret;
 }
 
 int
@@ -4261,6 +4620,7 @@ rte_eth_dev_udp_tunnel_port_delete(uint16_t port_id,
 				   struct rte_eth_udp_tunnel *udp_tunnel)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -4279,34 +4639,48 @@ rte_eth_dev_udp_tunnel_port_delete(uint16_t port_id,
 
 	if (*dev->dev_ops->udp_tunnel_port_del == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->udp_tunnel_port_del)(dev,
+	ret = eth_err(port_id, (*dev->dev_ops->udp_tunnel_port_del)(dev,
 								udp_tunnel));
+
+	rte_ethdev_trace_udp_tunnel_port_delete(port_id, udp_tunnel, ret);
+
+	return ret;
 }
 
 int
 rte_eth_led_on(uint16_t port_id)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
 
 	if (*dev->dev_ops->dev_led_on == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->dev_led_on)(dev));
+	ret = eth_err(port_id, (*dev->dev_ops->dev_led_on)(dev));
+
+	rte_eth_trace_led_on(port_id, ret);
+
+	return ret;
 }
 
 int
 rte_eth_led_off(uint16_t port_id)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
 
 	if (*dev->dev_ops->dev_led_off == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->dev_led_off)(dev));
+	ret = eth_err(port_id, (*dev->dev_ops->dev_led_off)(dev));
+
+	rte_eth_trace_led_off(port_id, ret);
+
+	return ret;
 }
 
 int
@@ -4331,6 +4705,8 @@ rte_eth_fec_get_capability(uint16_t port_id,
 		return -ENOTSUP;
 	ret = (*dev->dev_ops->fec_get_capability)(dev, speed_fec_capa, num);
 
+	rte_eth_trace_fec_get_capability(port_id, speed_fec_capa, num, ret);
+
 	return ret;
 }
 
@@ -4338,6 +4714,7 @@ int
 rte_eth_fec_get(uint16_t port_id, uint32_t *fec_capa)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -4351,20 +4728,29 @@ rte_eth_fec_get(uint16_t port_id, uint32_t *fec_capa)
 
 	if (*dev->dev_ops->fec_get == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->fec_get)(dev, fec_capa));
+	ret = eth_err(port_id, (*dev->dev_ops->fec_get)(dev, fec_capa));
+
+	rte_eth_trace_fec_get(port_id, fec_capa, ret);
+
+	return ret;
 }
 
 int
 rte_eth_fec_set(uint16_t port_id, uint32_t fec_capa)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
 
 	if (*dev->dev_ops->fec_set == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->fec_set)(dev, fec_capa));
+	ret = eth_err(port_id, (*dev->dev_ops->fec_set)(dev, fec_capa));
+
+	rte_eth_trace_fec_set(port_id, fec_capa, ret);
+
+	return ret;
 }
 
 /*
@@ -4452,7 +4838,11 @@ rte_eth_dev_mac_addr_add(uint16_t port_id, struct rte_ether_addr *addr,
 		dev->data->mac_pool_sel[index] |= RTE_BIT64(pool);
 	}
 
-	return eth_err(port_id, ret);
+	ret = eth_err(port_id, ret);
+
+	rte_ethdev_trace_mac_addr_add(port_id, addr, pool, ret);
+
+	return ret;
 }
 
 int
@@ -4492,6 +4882,8 @@ rte_eth_dev_mac_addr_remove(uint16_t port_id, struct rte_ether_addr *addr)
 	/* reset pool bitmap */
 	dev->data->mac_pool_sel[index] = 0;
 
+	rte_ethdev_trace_mac_addr_remove(port_id, addr);
+
 	return 0;
 }
 
@@ -4524,6 +4916,8 @@ rte_eth_dev_default_mac_addr_set(uint16_t port_id, struct rte_ether_addr *addr)
 	/* Update default address in NIC data structure */
 	rte_ether_addr_copy(addr, &dev->data->mac_addrs[0]);
 
+	rte_ethdev_trace_default_mac_addr_set(port_id, addr);
+
 	return 0;
 }
 
@@ -4614,21 +5008,29 @@ rte_eth_dev_uc_hash_table_set(uint16_t port_id, struct rte_ether_addr *addr,
 					&dev->data->hash_mac_addrs[index]);
 	}
 
-	return eth_err(port_id, ret);
+	ret = eth_err(port_id, ret);
+
+	rte_ethdev_trace_uc_hash_table_set(port_id, on, ret);
+
+	return ret;
 }
 
 int
 rte_eth_dev_uc_all_hash_table_set(uint16_t port_id, uint8_t on)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
 
 	if (*dev->dev_ops->uc_all_hash_table_set == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->uc_all_hash_table_set)(dev,
-								       on));
+	ret = eth_err(port_id, (*dev->dev_ops->uc_all_hash_table_set)(dev, on));
+
+	rte_ethdev_trace_uc_all_hash_table_set(port_id, on, ret);
+
+	return ret;
 }
 
 int rte_eth_set_queue_rate_limit(uint16_t port_id, uint16_t queue_idx,
@@ -4664,14 +5066,19 @@ int rte_eth_set_queue_rate_limit(uint16_t port_id, uint16_t queue_idx,
 
 	if (*dev->dev_ops->set_queue_rate_limit == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->set_queue_rate_limit)(dev,
+	ret = eth_err(port_id, (*dev->dev_ops->set_queue_rate_limit)(dev,
 							queue_idx, tx_rate));
+
+	rte_eth_trace_set_queue_rate_limit(port_id, queue_idx, tx_rate, ret);
+
+	return ret;
 }
 
 int rte_eth_rx_avail_thresh_set(uint16_t port_id, uint16_t queue_id,
 			       uint8_t avail_thresh)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -4691,14 +5098,19 @@ int rte_eth_rx_avail_thresh_set(uint16_t port_id, uint16_t queue_id,
 	}
 	if (*dev->dev_ops->rx_queue_avail_thresh_set == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->rx_queue_avail_thresh_set)(dev,
+	ret = eth_err(port_id, (*dev->dev_ops->rx_queue_avail_thresh_set)(dev,
 							     queue_id, avail_thresh));
+
+	rte_eth_trace_rx_avail_thresh_set(port_id, queue_id, avail_thresh, ret);
+
+	return ret;
 }
 
 int rte_eth_rx_avail_thresh_query(uint16_t port_id, uint16_t *queue_id,
 				 uint8_t *avail_thresh)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -4710,8 +5122,12 @@ int rte_eth_rx_avail_thresh_query(uint16_t port_id, uint16_t *queue_id,
 
 	if (*dev->dev_ops->rx_queue_avail_thresh_query == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->rx_queue_avail_thresh_query)(dev,
+	ret = eth_err(port_id, (*dev->dev_ops->rx_queue_avail_thresh_query)(dev,
 							     queue_id, avail_thresh));
+
+	rte_eth_trace_rx_avail_thresh_query(port_id, *queue_id, ret);
+
+	return ret;
 }
 
 RTE_INIT(eth_dev_init_fp_ops)
@@ -4793,6 +5209,9 @@ rte_eth_dev_callback_register(uint16_t port_id,
 	} while (++next_port <= last_port);
 
 	rte_spinlock_unlock(&eth_dev_cb_lock);
+
+	rte_ethdev_trace_callback_register(port_id, event, cb_fn, cb_arg);
+
 	return 0;
 }
 
@@ -4854,6 +5273,10 @@ rte_eth_dev_callback_unregister(uint16_t port_id,
 	} while (++next_port <= last_port);
 
 	rte_spinlock_unlock(&eth_dev_cb_lock);
+
+	rte_ethdev_trace_callback_unregister(port_id, event, cb_fn, cb_arg,
+					     ret);
+
 	return ret;
 }
 
@@ -4883,6 +5306,9 @@ rte_eth_dev_rx_intr_ctl(uint16_t port_id, int epfd, int op, void *data)
 	for (qid = 0; qid < dev->data->nb_rx_queues; qid++) {
 		vec = rte_intr_vec_list_index_get(intr_handle, qid);
 		rc = rte_intr_rx_ctl(intr_handle, epfd, op, vec, data);
+
+		rte_ethdev_trace_rx_intr_ctl(port_id, qid, epfd, op, data, rc);
+
 		if (rc && rc != -EEXIST) {
 			RTE_ETHDEV_LOG(ERR,
 				"p %u q %u Rx ctl error op %d epfd %d vec %u\n",
@@ -4926,6 +5352,8 @@ rte_eth_dev_rx_intr_ctl_q_get_fd(uint16_t port_id, uint16_t queue_id)
 		(vec - RTE_INTR_VEC_RXTX_OFFSET) : vec;
 	fd = rte_intr_efds_index_get(intr_handle, efd_idx);
 
+	rte_ethdev_trace_rx_intr_ctl_q_get_fd(port_id, queue_id, fd);
+
 	return fd;
 }
 
@@ -4959,6 +5387,9 @@ rte_eth_dev_rx_intr_ctl_q(uint16_t port_id, uint16_t queue_id,
 
 	vec = rte_intr_vec_list_index_get(intr_handle, queue_id);
 	rc = rte_intr_rx_ctl(intr_handle, epfd, op, vec, data);
+
+	rte_ethdev_trace_rx_intr_ctl_q(port_id, queue_id, epfd, op, data, rc);
+
 	if (rc && rc != -EEXIST) {
 		RTE_ETHDEV_LOG(ERR,
 			"p %u q %u Rx ctl error op %d epfd %d vec %u\n",
@@ -4985,7 +5416,11 @@ rte_eth_dev_rx_intr_enable(uint16_t port_id,
 
 	if (*dev->dev_ops->rx_queue_intr_enable == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->rx_queue_intr_enable)(dev, queue_id));
+	ret = eth_err(port_id, (*dev->dev_ops->rx_queue_intr_enable)(dev, queue_id));
+
+	rte_ethdev_trace_rx_intr_enable(port_id, queue_id, ret);
+
+	return ret;
 }
 
 int
@@ -5004,7 +5439,11 @@ rte_eth_dev_rx_intr_disable(uint16_t port_id,
 
 	if (*dev->dev_ops->rx_queue_intr_disable == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->rx_queue_intr_disable)(dev, queue_id));
+	ret = eth_err(port_id, (*dev->dev_ops->rx_queue_intr_disable)(dev, queue_id));
+
+	rte_ethdev_trace_rx_intr_disable(port_id, queue_id, ret);
+
+	return ret;
 }
 
 
@@ -5062,6 +5501,8 @@ rte_eth_add_rx_callback(uint16_t port_id, uint16_t queue_id,
 	}
 	rte_spinlock_unlock(&eth_dev_rx_cb_lock);
 
+	rte_eth_trace_add_rx_callback(port_id, queue_id, fn, user_param, cb);
+
 	return cb;
 }
 
@@ -5101,6 +5542,9 @@ rte_eth_add_first_rx_callback(uint16_t port_id, uint16_t queue_id,
 		cb, __ATOMIC_RELEASE);
 	rte_spinlock_unlock(&eth_dev_rx_cb_lock);
 
+	rte_eth_trace_add_first_rx_callback(port_id, queue_id, fn, user_param,
+					    cb);
+
 	return cb;
 }
 
@@ -5160,6 +5604,8 @@ rte_eth_add_tx_callback(uint16_t port_id, uint16_t queue_id,
 	}
 	rte_spinlock_unlock(&eth_dev_tx_cb_lock);
 
+	rte_eth_trace_add_tx_callback(port_id, queue_id, fn, user_param, cb);
+
 	return cb;
 }
 
@@ -5194,6 +5640,8 @@ rte_eth_remove_rx_callback(uint16_t port_id, uint16_t queue_id,
 	}
 	rte_spinlock_unlock(&eth_dev_rx_cb_lock);
 
+	rte_eth_trace_remove_rx_callback(port_id, queue_id, user_cb, ret);
+
 	return ret;
 }
 
@@ -5228,6 +5676,8 @@ rte_eth_remove_tx_callback(uint16_t port_id, uint16_t queue_id,
 	}
 	rte_spinlock_unlock(&eth_dev_tx_cb_lock);
 
+	rte_eth_trace_remove_tx_callback(port_id, queue_id, user_cb, ret);
+
 	return ret;
 }
 
@@ -5274,6 +5724,8 @@ rte_eth_rx_queue_info_get(uint16_t port_id, uint16_t queue_id,
 	dev->dev_ops->rxq_info_get(dev, queue_id, qinfo);
 	qinfo->queue_state = dev->data->rx_queue_state[queue_id];
 
+	rte_eth_trace_rx_queue_info_get(port_id, queue_id, qinfo);
+
 	return 0;
 }
 
@@ -5320,6 +5772,8 @@ rte_eth_tx_queue_info_get(uint16_t port_id, uint16_t queue_id,
 	dev->dev_ops->txq_info_get(dev, queue_id, qinfo);
 	qinfo->queue_state = dev->data->tx_queue_state[queue_id];
 
+	rte_eth_trace_tx_queue_info_get(port_id, queue_id, qinfo);
+
 	return 0;
 }
 
@@ -5328,6 +5782,7 @@ rte_eth_rx_burst_mode_get(uint16_t port_id, uint16_t queue_id,
 			  struct rte_eth_burst_mode *mode)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -5347,8 +5802,12 @@ rte_eth_rx_burst_mode_get(uint16_t port_id, uint16_t queue_id,
 	if (*dev->dev_ops->rx_burst_mode_get == NULL)
 		return -ENOTSUP;
 	memset(mode, 0, sizeof(*mode));
-	return eth_err(port_id,
-		       dev->dev_ops->rx_burst_mode_get(dev, queue_id, mode));
+	ret = eth_err(port_id,
+		      dev->dev_ops->rx_burst_mode_get(dev, queue_id, mode));
+
+	rte_eth_trace_rx_burst_mode_get(port_id, queue_id, mode, ret);
+
+	return ret;
 }
 
 int
@@ -5356,6 +5815,7 @@ rte_eth_tx_burst_mode_get(uint16_t port_id, uint16_t queue_id,
 			  struct rte_eth_burst_mode *mode)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -5375,8 +5835,12 @@ rte_eth_tx_burst_mode_get(uint16_t port_id, uint16_t queue_id,
 	if (*dev->dev_ops->tx_burst_mode_get == NULL)
 		return -ENOTSUP;
 	memset(mode, 0, sizeof(*mode));
-	return eth_err(port_id,
-		       dev->dev_ops->tx_burst_mode_get(dev, queue_id, mode));
+	ret = eth_err(port_id,
+		      dev->dev_ops->tx_burst_mode_get(dev, queue_id, mode));
+
+	rte_eth_trace_tx_burst_mode_get(port_id, queue_id, mode, ret);
+
+	return ret;
 }
 
 int
@@ -5384,6 +5848,7 @@ rte_eth_get_monitor_addr(uint16_t port_id, uint16_t queue_id,
 		struct rte_power_monitor_cond *pmc)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -5402,8 +5867,12 @@ rte_eth_get_monitor_addr(uint16_t port_id, uint16_t queue_id,
 
 	if (*dev->dev_ops->get_monitor_addr == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id,
+	ret = eth_err(port_id,
 		dev->dev_ops->get_monitor_addr(dev->data->rx_queues[queue_id], pmc));
+
+	rte_eth_trace_get_monitor_addr(port_id, queue_id, pmc, ret);
+
+	return ret;
 }
 
 int
@@ -5412,40 +5881,56 @@ rte_eth_dev_set_mc_addr_list(uint16_t port_id,
 			     uint32_t nb_mc_addr)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
 
 	if (*dev->dev_ops->set_mc_addr_list == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, dev->dev_ops->set_mc_addr_list(dev,
+	ret = eth_err(port_id, dev->dev_ops->set_mc_addr_list(dev,
 						mc_addr_set, nb_mc_addr));
+
+	rte_ethdev_trace_set_mc_addr_list(port_id, mc_addr_set, nb_mc_addr,
+					  ret);
+
+	return ret;
 }
 
 int
 rte_eth_timesync_enable(uint16_t port_id)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
 
 	if (*dev->dev_ops->timesync_enable == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->timesync_enable)(dev));
+	ret = eth_err(port_id, (*dev->dev_ops->timesync_enable)(dev));
+
+	rte_eth_trace_timesync_enable(port_id, ret);
+
+	return ret;
 }
 
 int
 rte_eth_timesync_disable(uint16_t port_id)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
 
 	if (*dev->dev_ops->timesync_disable == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->timesync_disable)(dev));
+	ret = eth_err(port_id, (*dev->dev_ops->timesync_disable)(dev));
+
+	rte_eth_trace_timesync_disable(port_id, ret);
+
+	return ret;
 }
 
 int
@@ -5453,6 +5938,7 @@ rte_eth_timesync_read_rx_timestamp(uint16_t port_id, struct timespec *timestamp,
 				   uint32_t flags)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -5466,8 +5952,14 @@ rte_eth_timesync_read_rx_timestamp(uint16_t port_id, struct timespec *timestamp,
 
 	if (*dev->dev_ops->timesync_read_rx_timestamp == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->timesync_read_rx_timestamp)
-				(dev, timestamp, flags));
+
+	ret = eth_err(port_id, (*dev->dev_ops->timesync_read_rx_timestamp)
+			       (dev, timestamp, flags));
+
+	rte_eth_trace_timesync_read_rx_timestamp(port_id, timestamp, flags,
+						 ret);
+
+	return ret;
 }
 
 int
@@ -5475,6 +5967,7 @@ rte_eth_timesync_read_tx_timestamp(uint16_t port_id,
 				   struct timespec *timestamp)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -5488,27 +5981,39 @@ rte_eth_timesync_read_tx_timestamp(uint16_t port_id,
 
 	if (*dev->dev_ops->timesync_read_tx_timestamp == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->timesync_read_tx_timestamp)
-				(dev, timestamp));
+
+	ret = eth_err(port_id, (*dev->dev_ops->timesync_read_tx_timestamp)
+			       (dev, timestamp));
+
+	rte_eth_trace_timesync_read_tx_timestamp(port_id, timestamp, ret);
+
+	return ret;
+
 }
 
 int
 rte_eth_timesync_adjust_time(uint16_t port_id, int64_t delta)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
 
 	if (*dev->dev_ops->timesync_adjust_time == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->timesync_adjust_time)(dev, delta));
+	ret = eth_err(port_id, (*dev->dev_ops->timesync_adjust_time)(dev, delta));
+
+	rte_eth_trace_timesync_adjust_time(port_id, delta, ret);
+
+	return ret;
 }
 
 int
 rte_eth_timesync_read_time(uint16_t port_id, struct timespec *timestamp)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -5522,14 +6027,19 @@ rte_eth_timesync_read_time(uint16_t port_id, struct timespec *timestamp)
 
 	if (*dev->dev_ops->timesync_read_time == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->timesync_read_time)(dev,
+	ret = eth_err(port_id, (*dev->dev_ops->timesync_read_time)(dev,
 								timestamp));
+
+	rte_eth_trace_timesync_read_time(port_id, timestamp, ret);
+
+	return ret;
 }
 
 int
 rte_eth_timesync_write_time(uint16_t port_id, const struct timespec *timestamp)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -5543,14 +6053,19 @@ rte_eth_timesync_write_time(uint16_t port_id, const struct timespec *timestamp)
 
 	if (*dev->dev_ops->timesync_write_time == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->timesync_write_time)(dev,
+	ret = eth_err(port_id, (*dev->dev_ops->timesync_write_time)(dev,
 								timestamp));
+
+	rte_eth_trace_timesync_write_time(port_id, timestamp, ret);
+
+	return ret;
 }
 
 int
 rte_eth_read_clock(uint16_t port_id, uint64_t *clock)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -5563,13 +6078,18 @@ rte_eth_read_clock(uint16_t port_id, uint64_t *clock)
 
 	if (*dev->dev_ops->read_clock == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->read_clock)(dev, clock));
+	ret = eth_err(port_id, (*dev->dev_ops->read_clock)(dev, clock));
+
+	rte_eth_trace_read_clock(port_id, clock, ret);
+
+	return ret;
 }
 
 int
 rte_eth_dev_get_reg_info(uint16_t port_id, struct rte_dev_reg_info *info)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -5583,26 +6103,36 @@ rte_eth_dev_get_reg_info(uint16_t port_id, struct rte_dev_reg_info *info)
 
 	if (*dev->dev_ops->get_reg == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->get_reg)(dev, info));
+	ret = eth_err(port_id, (*dev->dev_ops->get_reg)(dev, info));
+
+	rte_ethdev_trace_get_reg_info(port_id, info, ret);
+
+	return ret;
 }
 
 int
 rte_eth_dev_get_eeprom_length(uint16_t port_id)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
 
 	if (*dev->dev_ops->get_eeprom_length == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->get_eeprom_length)(dev));
+	ret = eth_err(port_id, (*dev->dev_ops->get_eeprom_length)(dev));
+
+	rte_ethdev_trace_get_eeprom_length(port_id, ret);
+
+	return ret;
 }
 
 int
 rte_eth_dev_get_eeprom(uint16_t port_id, struct rte_dev_eeprom_info *info)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -5616,13 +6146,18 @@ rte_eth_dev_get_eeprom(uint16_t port_id, struct rte_dev_eeprom_info *info)
 
 	if (*dev->dev_ops->get_eeprom == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->get_eeprom)(dev, info));
+	ret = eth_err(port_id, (*dev->dev_ops->get_eeprom)(dev, info));
+
+	rte_ethdev_trace_get_eeprom(port_id, info, ret);
+
+	return ret;
 }
 
 int
 rte_eth_dev_set_eeprom(uint16_t port_id, struct rte_dev_eeprom_info *info)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -5636,7 +6171,11 @@ rte_eth_dev_set_eeprom(uint16_t port_id, struct rte_dev_eeprom_info *info)
 
 	if (*dev->dev_ops->set_eeprom == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->set_eeprom)(dev, info));
+	ret = eth_err(port_id, (*dev->dev_ops->set_eeprom)(dev, info));
+
+	rte_ethdev_trace_set_eeprom(port_id, info, ret);
+
+	return ret;
 }
 
 int
@@ -5644,6 +6183,7 @@ rte_eth_dev_get_module_info(uint16_t port_id,
 			    struct rte_eth_dev_module_info *modinfo)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -5657,7 +6197,11 @@ rte_eth_dev_get_module_info(uint16_t port_id,
 
 	if (*dev->dev_ops->get_module_info == NULL)
 		return -ENOTSUP;
-	return (*dev->dev_ops->get_module_info)(dev, modinfo);
+	ret = (*dev->dev_ops->get_module_info)(dev, modinfo);
+
+	rte_ethdev_trace_get_module_info(port_id, modinfo, ret);
+
+	return ret;
 }
 
 int
@@ -5665,6 +6209,7 @@ rte_eth_dev_get_module_eeprom(uint16_t port_id,
 			      struct rte_dev_eeprom_info *info)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -5692,7 +6237,11 @@ rte_eth_dev_get_module_eeprom(uint16_t port_id,
 
 	if (*dev->dev_ops->get_module_eeprom == NULL)
 		return -ENOTSUP;
-	return (*dev->dev_ops->get_module_eeprom)(dev, info);
+	ret = (*dev->dev_ops->get_module_eeprom)(dev, info);
+
+	rte_ethdev_trace_get_module_eeprom(port_id, info, ret);
+
+	return ret;
 }
 
 int
@@ -5700,6 +6249,7 @@ rte_eth_dev_get_dcb_info(uint16_t port_id,
 			     struct rte_eth_dcb_info *dcb_info)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -5715,7 +6265,11 @@ rte_eth_dev_get_dcb_info(uint16_t port_id,
 
 	if (*dev->dev_ops->get_dcb_info == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->get_dcb_info)(dev, dcb_info));
+	ret = eth_err(port_id, (*dev->dev_ops->get_dcb_info)(dev, dcb_info));
+
+	rte_ethdev_trace_get_dcb_info(port_id, dcb_info, ret);
+
+	return ret;
 }
 
 static void
@@ -5751,6 +6305,8 @@ rte_eth_dev_adjust_nb_rx_tx_desc(uint16_t port_id,
 	if (nb_tx_desc != NULL)
 		eth_dev_adjust_nb_desc(nb_tx_desc, &dev_info.tx_desc_lim);
 
+	rte_ethdev_trace_adjust_nb_rx_tx_desc(port_id);
+
 	return 0;
 }
 
@@ -5759,6 +6315,7 @@ rte_eth_dev_hairpin_capability_get(uint16_t port_id,
 				   struct rte_eth_hairpin_cap *cap)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -5773,13 +6330,18 @@ rte_eth_dev_hairpin_capability_get(uint16_t port_id,
 	if (*dev->dev_ops->hairpin_cap_get == NULL)
 		return -ENOTSUP;
 	memset(cap, 0, sizeof(*cap));
-	return eth_err(port_id, (*dev->dev_ops->hairpin_cap_get)(dev, cap));
+	ret = eth_err(port_id, (*dev->dev_ops->hairpin_cap_get)(dev, cap));
+
+	rte_ethdev_trace_hairpin_capability_get(port_id, cap, ret);
+
+	return ret;
 }
 
 int
 rte_eth_dev_pool_ops_supported(uint16_t port_id, const char *pool)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -5794,7 +6356,11 @@ rte_eth_dev_pool_ops_supported(uint16_t port_id, const char *pool)
 	if (*dev->dev_ops->pool_ops_supported == NULL)
 		return 1; /* all pools are supported */
 
-	return (*dev->dev_ops->pool_ops_supported)(dev, pool);
+	ret = (*dev->dev_ops->pool_ops_supported)(dev, pool);
+
+	rte_ethdev_trace_pool_ops_supported(port_id, pool, ret);
+
+	return ret;
 }
 
 static int
@@ -6084,19 +6650,25 @@ rte_eth_representor_info_get(uint16_t port_id,
 			     struct rte_eth_representor_info *info)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
 
 	if (*dev->dev_ops->representor_info_get == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id, (*dev->dev_ops->representor_info_get)(dev, info));
+	ret = eth_err(port_id, (*dev->dev_ops->representor_info_get)(dev, info));
+
+	rte_eth_trace_representor_info_get(port_id, info, ret);
+
+	return ret;
 }
 
 int
 rte_eth_rx_metadata_negotiate(uint16_t port_id, uint64_t *features)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -6115,8 +6687,12 @@ rte_eth_rx_metadata_negotiate(uint16_t port_id, uint64_t *features)
 
 	if (*dev->dev_ops->rx_metadata_negotiate == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id,
-		       (*dev->dev_ops->rx_metadata_negotiate)(dev, features));
+	ret = eth_err(port_id,
+		      (*dev->dev_ops->rx_metadata_negotiate)(dev, features));
+
+	rte_eth_trace_rx_metadata_negotiate(port_id, *features, ret);
+
+	return ret;
 }
 
 int
@@ -6124,6 +6700,7 @@ rte_eth_ip_reassembly_capability_get(uint16_t port_id,
 		struct rte_eth_ip_reassembly_params *reassembly_capa)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -6145,8 +6722,13 @@ rte_eth_ip_reassembly_capability_get(uint16_t port_id,
 		return -ENOTSUP;
 	memset(reassembly_capa, 0, sizeof(struct rte_eth_ip_reassembly_params));
 
-	return eth_err(port_id, (*dev->dev_ops->ip_reassembly_capability_get)
+	ret = eth_err(port_id, (*dev->dev_ops->ip_reassembly_capability_get)
 					(dev, reassembly_capa));
+
+	rte_eth_trace_ip_reassembly_capability_get(port_id, reassembly_capa,
+						   ret);
+
+	return ret;
 }
 
 int
@@ -6154,6 +6736,7 @@ rte_eth_ip_reassembly_conf_get(uint16_t port_id,
 		struct rte_eth_ip_reassembly_params *conf)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -6174,8 +6757,12 @@ rte_eth_ip_reassembly_conf_get(uint16_t port_id,
 	if (*dev->dev_ops->ip_reassembly_conf_get == NULL)
 		return -ENOTSUP;
 	memset(conf, 0, sizeof(struct rte_eth_ip_reassembly_params));
-	return eth_err(port_id,
-		       (*dev->dev_ops->ip_reassembly_conf_get)(dev, conf));
+	ret = eth_err(port_id,
+		      (*dev->dev_ops->ip_reassembly_conf_get)(dev, conf));
+
+	rte_eth_trace_ip_reassembly_conf_get(port_id, conf, ret);
+
+	return ret;
 }
 
 int
@@ -6183,6 +6770,7 @@ rte_eth_ip_reassembly_conf_set(uint16_t port_id,
 		const struct rte_eth_ip_reassembly_params *conf)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -6211,8 +6799,12 @@ rte_eth_ip_reassembly_conf_set(uint16_t port_id,
 
 	if (*dev->dev_ops->ip_reassembly_conf_set == NULL)
 		return -ENOTSUP;
-	return eth_err(port_id,
-		       (*dev->dev_ops->ip_reassembly_conf_set)(dev, conf));
+	ret = eth_err(port_id,
+		      (*dev->dev_ops->ip_reassembly_conf_set)(dev, conf));
+
+	rte_eth_trace_ip_reassembly_conf_set(port_id, conf, ret);
+
+	return ret;
 }
 
 int
@@ -6310,8 +6902,12 @@ rte_eth_buffer_split_get_supported_hdr_ptypes(uint16_t port_id, uint32_t *ptypes
 		return 0;
 
 	for (i = 0, j = 0; all_types[i] != RTE_PTYPE_UNKNOWN; ++i) {
-		if (j < num)
+		if (j < num) {
 			ptypes[j] = all_types[i];
+
+			rte_eth_trace_buffer_split_get_supported_hdr_ptypes(
+							port_id, j, ptypes[j]);
+		}
 		j++;
 	}
 
diff --git a/lib/ethdev/rte_ethdev_cman.c b/lib/ethdev/rte_ethdev_cman.c
index 4a1bdd7bd0c74..a9c4637521c16 100644
--- a/lib/ethdev/rte_ethdev_cman.c
+++ b/lib/ethdev/rte_ethdev_cman.c
@@ -8,12 +8,14 @@
 #include "rte_ethdev.h"
 #include "ethdev_driver.h"
 #include "ethdev_private.h"
+#include "ethdev_trace.h"
 
 /* Get congestion management information for a port */
 int
 rte_eth_cman_info_get(uint16_t port_id, struct rte_eth_cman_info *info)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -29,7 +31,11 @@ rte_eth_cman_info_get(uint16_t port_id, struct rte_eth_cman_info *info)
 	}
 
 	memset(info, 0, sizeof(struct rte_eth_cman_info));
-	return eth_err(port_id, (*dev->dev_ops->cman_info_get)(dev, info));
+	ret = eth_err(port_id, (*dev->dev_ops->cman_info_get)(dev, info));
+
+	rte_eth_trace_cman_info_get(port_id, info, ret);
+
+	return ret;
 }
 
 /* Initialize congestion management structure with default values */
@@ -37,6 +43,7 @@ int
 rte_eth_cman_config_init(uint16_t port_id, struct rte_eth_cman_config *config)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -52,7 +59,11 @@ rte_eth_cman_config_init(uint16_t port_id, struct rte_eth_cman_config *config)
 	}
 
 	memset(config, 0, sizeof(struct rte_eth_cman_config));
-	return eth_err(port_id, (*dev->dev_ops->cman_config_init)(dev, config));
+	ret = eth_err(port_id, (*dev->dev_ops->cman_config_init)(dev, config));
+
+	rte_eth_trace_cman_config_init(port_id, config, ret);
+
+	return ret;
 }
 
 /* Configure congestion management on a port */
@@ -60,6 +71,7 @@ int
 rte_eth_cman_config_set(uint16_t port_id, const struct rte_eth_cman_config *config)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -74,7 +86,11 @@ rte_eth_cman_config_set(uint16_t port_id, const struct rte_eth_cman_config *conf
 		return -ENOTSUP;
 	}
 
-	return eth_err(port_id, (*dev->dev_ops->cman_config_set)(dev, config));
+	ret = eth_err(port_id, (*dev->dev_ops->cman_config_set)(dev, config));
+
+	rte_eth_trace_cman_config_set(port_id, config, ret);
+
+	return ret;
 }
 
 /* Retrieve congestion management configuration of a port */
@@ -82,6 +98,7 @@ int
 rte_eth_cman_config_get(uint16_t port_id, struct rte_eth_cman_config *config)
 {
 	struct rte_eth_dev *dev;
+	int ret;
 
 	RTE_ETH_VALID_PORTID_OR_ERR_RET(port_id, -ENODEV);
 	dev = &rte_eth_devices[port_id];
@@ -97,5 +114,9 @@ rte_eth_cman_config_get(uint16_t port_id, struct rte_eth_cman_config *config)
 	}
 
 	memset(config, 0, sizeof(struct rte_eth_cman_config));
-	return eth_err(port_id, (*dev->dev_ops->cman_config_get)(dev, config));
+	ret = eth_err(port_id, (*dev->dev_ops->cman_config_get)(dev, config));
+
+	rte_eth_trace_cman_config_get(port_id, config, ret);
+
+	return ret;
 }
diff --git a/lib/ethdev/rte_ethdev_trace.h b/lib/ethdev/rte_ethdev_trace.h
deleted file mode 100644
index 1491c815c3121..0000000000000
--- a/lib/ethdev/rte_ethdev_trace.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/* SPDX-License-Identifier: BSD-3-Clause
- * Copyright(C) 2020 Marvell International Ltd.
- */
-
-#ifndef _RTE_ETHDEV_TRACE_H_
-#define _RTE_ETHDEV_TRACE_H_
-
-/**
- * @file
- *
- * API for ethdev trace support
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <rte_trace_point.h>
-
-#include "rte_ethdev.h"
-
-RTE_TRACE_POINT(
-	rte_ethdev_trace_configure,
-	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t nb_rx_q,
-		uint16_t nb_tx_q, const struct rte_eth_conf *dev_conf, int rc),
-	rte_trace_point_emit_u16(port_id);
-	rte_trace_point_emit_u16(nb_rx_q);
-	rte_trace_point_emit_u16(nb_tx_q);
-	rte_trace_point_emit_u32(dev_conf->link_speeds);
-	rte_trace_point_emit_u32(dev_conf->rxmode.mq_mode);
-	rte_trace_point_emit_u32(dev_conf->rxmode.mtu);
-	rte_trace_point_emit_u64(dev_conf->rxmode.offloads);
-	rte_trace_point_emit_u32(dev_conf->txmode.mq_mode);
-	rte_trace_point_emit_u64(dev_conf->txmode.offloads);
-	rte_trace_point_emit_u32(dev_conf->lpbk_mode);
-	rte_trace_point_emit_int(rc);
-)
-
-RTE_TRACE_POINT(
-	rte_ethdev_trace_rxq_setup,
-	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t rx_queue_id,
-		uint16_t nb_rx_desc, void *mp,
-		const struct rte_eth_rxconf *rx_conf, int rc),
-	rte_trace_point_emit_u16(port_id);
-	rte_trace_point_emit_u16(rx_queue_id);
-	rte_trace_point_emit_u16(nb_rx_desc);
-	rte_trace_point_emit_ptr(mp);
-	rte_trace_point_emit_u8(rx_conf->rx_thresh.pthresh);
-	rte_trace_point_emit_u8(rx_conf->rx_thresh.hthresh);
-	rte_trace_point_emit_u8(rx_conf->rx_thresh.wthresh);
-	rte_trace_point_emit_u8(rx_conf->rx_drop_en);
-	rte_trace_point_emit_u8(rx_conf->rx_deferred_start);
-	rte_trace_point_emit_u64(rx_conf->offloads);
-	rte_trace_point_emit_int(rc);
-)
-
-RTE_TRACE_POINT(
-	rte_ethdev_trace_txq_setup,
-	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t tx_queue_id,
-		uint16_t nb_tx_desc, const struct rte_eth_txconf *tx_conf),
-	rte_trace_point_emit_u16(port_id);
-	rte_trace_point_emit_u16(tx_queue_id);
-	rte_trace_point_emit_u16(nb_tx_desc);
-	rte_trace_point_emit_u8(tx_conf->tx_thresh.pthresh);
-	rte_trace_point_emit_u8(tx_conf->tx_thresh.hthresh);
-	rte_trace_point_emit_u8(tx_conf->tx_thresh.wthresh);
-	rte_trace_point_emit_u8(tx_conf->tx_deferred_start);
-	rte_trace_point_emit_u16(tx_conf->tx_free_thresh);
-	rte_trace_point_emit_u64(tx_conf->offloads);
-)
-
-RTE_TRACE_POINT(
-	rte_ethdev_trace_start,
-	RTE_TRACE_POINT_ARGS(uint16_t port_id),
-	rte_trace_point_emit_u16(port_id);
-)
-
-RTE_TRACE_POINT(
-	rte_ethdev_trace_stop,
-	RTE_TRACE_POINT_ARGS(uint16_t port_id, int ret),
-	rte_trace_point_emit_u16(port_id);
-	rte_trace_point_emit_int(ret);
-)
-
-RTE_TRACE_POINT(
-	rte_ethdev_trace_close,
-	RTE_TRACE_POINT_ARGS(uint16_t port_id),
-	rte_trace_point_emit_u16(port_id);
-)
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _RTE_ETHDEV_TRACE_H_ */
diff --git a/lib/ethdev/rte_ethdev_trace_fp.h b/lib/ethdev/rte_ethdev_trace_fp.h
index 40084d1929b33..186271c9ff4e4 100644
--- a/lib/ethdev/rte_ethdev_trace_fp.h
+++ b/lib/ethdev/rte_ethdev_trace_fp.h
@@ -37,6 +37,42 @@ RTE_TRACE_POINT_FP(
 	rte_trace_point_emit_u16(nb_pkts);
 )
 
+RTE_TRACE_POINT_FP(
+	rte_eth_trace_call_rx_callbacks,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id,
+		void **rx_pkts, uint16_t nb_rx, uint16_t nb_pkts),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_ptr(rx_pkts);
+	rte_trace_point_emit_u16(nb_rx);
+	rte_trace_point_emit_u16(nb_pkts);
+)
+
+RTE_TRACE_POINT_FP(
+	rte_eth_trace_call_tx_callbacks,
+	RTE_TRACE_POINT_ARGS(uint16_t port_id, uint16_t queue_id,
+		void **tx_pkts, uint16_t nb_pkts),
+	rte_trace_point_emit_u16(port_id);
+	rte_trace_point_emit_u16(queue_id);
+	rte_trace_point_emit_ptr(tx_pkts);
+	rte_trace_point_emit_u16(nb_pkts);
+)
+
+RTE_TRACE_POINT_FP(
+	rte_eth_trace_tx_buffer_drop_callback,
+	RTE_TRACE_POINT_ARGS(void **pkts, uint16_t unsent),
+	rte_trace_point_emit_ptr(pkts);
+	rte_trace_point_emit_u16(unsent);
+)
+
+RTE_TRACE_POINT_FP(
+	rte_eth_trace_tx_buffer_count_callback,
+	RTE_TRACE_POINT_ARGS(void **pkts, uint16_t unsent, uint64_t count),
+	rte_trace_point_emit_ptr(pkts);
+	rte_trace_point_emit_u16(unsent);
+	rte_trace_point_emit_u64(count);
+)
+
 #ifdef __cplusplus
 }
 #endif
-- 
2.25.1

