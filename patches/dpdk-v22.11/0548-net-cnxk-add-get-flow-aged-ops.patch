From 943a6ac07e8eaa1f3742f8bc986a097613383d2f Mon Sep 17 00:00:00 2001
From: Ankur Dwivedi <adwivedi@marvell.com>
Date: Fri, 30 Jun 2023 16:05:06 +0530
Subject: [PATCH 548/955] net/cnxk: add get flow aged ops

Adds get flow aged ops in CNXK driver. Also adds the devargs to get the
poll frequency of control thread.

Signed-off-by: Ankur Dwivedi <adwivedi@marvell.com>
Reviewed-by: Kiran Kumar Kokkilagadda <kirankumark@marvell.com>
Tested-by: Jerin Jacob Kollanukkaran <jerinj@marvell.com>
Change-Id: I84905b8eac7c92a6ec9e307402e08eaf2765735f
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/107814
Reviewed-by: Jerin Jacob Kollanukkaran <jerinj@marvell.com>
---
 doc/guides/nics/cnxk.rst               | 12 +++++++
 doc/guides/nics/features/cnxk.ini      |  1 +
 doc/guides/nics/features/cnxk_vf.ini   |  1 +
 drivers/net/cnxk/cnxk_ethdev_devargs.c | 21 +++++++++++-
 drivers/net/cnxk/cnxk_flow.c           | 45 ++++++++++++++++++++++++++
 5 files changed, 79 insertions(+), 1 deletion(-)

diff --git a/doc/guides/nics/cnxk.rst b/doc/guides/nics/cnxk.rst
index 9e7dff07f48c7..42a81f7ce8442 100644
--- a/doc/guides/nics/cnxk.rst
+++ b/doc/guides/nics/cnxk.rst
@@ -598,6 +598,18 @@ Runtime Config Options for inline device
    With the above configuration, driver would poll for soft expiry events every
    1000 usec.
 
+- ``NPC MCAM Aging poll frequency in seconds`` (default ``10``)
+
+   Poll frequency for aging control thread can be specified by
+   ``aging_poll_freq`` ``devargs`` parameter.
+
+   For example::
+
+      -a 0002:01:00.2,aging_poll_freq=50
+
+   With the above configuration, driver would poll for aging flows every 50
+   seconds.
+
 Debugging Options
 -----------------
 
diff --git a/doc/guides/nics/features/cnxk.ini b/doc/guides/nics/features/cnxk.ini
index 7947c044bbab2..bf5e826bd8d00 100644
--- a/doc/guides/nics/features/cnxk.ini
+++ b/doc/guides/nics/features/cnxk.ini
@@ -79,6 +79,7 @@ vxlan                = Y
 vxlan_gpe            = Y
 
 [rte_flow actions]
+age                  = Y
 count                = Y
 drop                 = Y
 flag                 = Y
diff --git a/doc/guides/nics/features/cnxk_vf.ini b/doc/guides/nics/features/cnxk_vf.ini
index 873e1dcc0a3b4..62ff121170d80 100644
--- a/doc/guides/nics/features/cnxk_vf.ini
+++ b/doc/guides/nics/features/cnxk_vf.ini
@@ -70,6 +70,7 @@ vxlan                = Y
 vxlan_gpe            = Y
 
 [rte_flow actions]
+age                  = Y
 count                = Y
 drop                 = Y
 flag                 = Y
diff --git a/drivers/net/cnxk/cnxk_ethdev_devargs.c b/drivers/net/cnxk/cnxk_ethdev_devargs.c
index e1a0845ece6cf..8e862be933346 100644
--- a/drivers/net/cnxk/cnxk_ethdev_devargs.c
+++ b/drivers/net/cnxk/cnxk_ethdev_devargs.c
@@ -245,6 +245,19 @@ parse_sdp_channel_mask(const char *key, const char *value, void *extra_args)
 	return 0;
 }
 
+static int
+parse_val_u16(const char *key, const char *value, void *extra_args)
+{
+	RTE_SET_USED(key);
+	uint16_t val;
+
+	val = atoi(value);
+
+	*(uint16_t *)extra_args = val;
+
+	return 0;
+}
+
 #define CNXK_RSS_RETA_SIZE	"reta_size"
 #define CNXK_SCL_ENABLE		"scalar_enable"
 #define CNXK_TX_COMPL_ENA       "tx_compl_ena"
@@ -265,10 +278,12 @@ parse_sdp_channel_mask(const char *key, const char *value, void *extra_args)
 #define CNXK_CUSTOM_SA_ACT	"custom_sa_act"
 #define CNXK_SQB_SLACK		"sqb_slack"
 #define CNXK_NIX_META_BUF_SZ	"meta_buf_sz"
+#define CNXK_FLOW_AGING_POLL_FREQ	"aging_poll_freq"
 
 int
 cnxk_ethdev_parse_devargs(struct rte_devargs *devargs, struct cnxk_eth_dev *dev)
 {
+	uint16_t aging_thread_poll_freq = ROC_NPC_AGE_POLL_FREQ_MIN;
 	uint16_t reta_sz = ROC_NIX_RSS_RETA_SZ_64;
 	uint16_t sqb_count = CNXK_NIX_TX_MAX_SQB;
 	struct flow_pre_l2_size_info pre_l2_info;
@@ -338,6 +353,8 @@ cnxk_ethdev_parse_devargs(struct rte_devargs *devargs, struct cnxk_eth_dev *dev)
 	rte_kvargs_process(kvlist, CNXK_SQB_SLACK, &parse_sqb_count,
 			   &sqb_slack);
 	rte_kvargs_process(kvlist, CNXK_NIX_META_BUF_SZ, &parse_meta_bufsize, &meta_buf_sz);
+	rte_kvargs_process(kvlist, CNXK_FLOW_AGING_POLL_FREQ, &parse_val_u16,
+			   &aging_thread_poll_freq);
 	rte_kvargs_free(kvlist);
 
 null_devargs:
@@ -369,6 +386,7 @@ cnxk_ethdev_parse_devargs(struct rte_devargs *devargs, struct cnxk_eth_dev *dev)
 	dev->npc.pre_l2_size_offset = pre_l2_info.pre_l2_size_off;
 	dev->npc.pre_l2_size_offset_mask = pre_l2_info.pre_l2_size_off_mask;
 	dev->npc.pre_l2_size_shift_dir = pre_l2_info.pre_l2_size_shift_dir;
+	dev->npc.flow_age.aging_poll_freq = aging_thread_poll_freq;
 	return 0;
 exit:
 	return -EINVAL;
@@ -390,4 +408,5 @@ RTE_PMD_REGISTER_PARAM_STRING(net_cnxk,
 			      CNXK_NO_INL_DEV "=0"
 			      CNXK_SDP_CHANNEL_MASK "=<1-4095>/<1-4095>"
 			      CNXK_CUSTOM_SA_ACT "=1"
-			      CNXK_SQB_SLACK "=<12-512>");
+			      CNXK_SQB_SLACK "=<12-512>"
+			      CNXK_FLOW_AGING_POLL_FREQ "=<10-65535>");
diff --git a/drivers/net/cnxk/cnxk_flow.c b/drivers/net/cnxk/cnxk_flow.c
index 3b8348ae9c422..9d69dd90e34ac 100644
--- a/drivers/net/cnxk/cnxk_flow.c
+++ b/drivers/net/cnxk/cnxk_flow.c
@@ -230,6 +230,10 @@ cnxk_map_actions(struct rte_eth_dev *eth_dev, const struct rte_flow_attr *attr,
 			in_actions[i].type = ROC_NPC_ACTION_TYPE_METER;
 			in_actions[i].conf = actions->conf;
 			break;
+		case RTE_FLOW_ACTION_TYPE_AGE:
+			in_actions[i].type = ROC_NPC_ACTION_TYPE_AGE;
+			in_actions[i].conf = actions->conf;
+			break;
 		default:
 			plt_npc_dbg("Action is not supported = %d",
 				    actions->type);
@@ -480,10 +484,51 @@ cnxk_flow_dev_dump(struct rte_eth_dev *eth_dev, struct rte_flow *flow,
 	return 0;
 }
 
+static int
+cnxk_flow_get_aged_flows(struct rte_eth_dev *eth_dev, void **context,
+			 uint32_t nb_contexts, struct rte_flow_error *err)
+{
+	struct cnxk_eth_dev *dev = cnxk_eth_pmd_priv(eth_dev);
+	struct roc_npc *roc_npc = &dev->npc;
+	struct roc_npc_flow_age *flow_age;
+	uint32_t start_id;
+	uint32_t end_id;
+	int cnt = 0;
+	uint32_t sn;
+	uint32_t i;
+
+	RTE_SET_USED(err);
+
+	flow_age = &roc_npc->flow_age;
+
+	do {
+		sn = plt_seqcount_read_begin(&flow_age->seq_cnt);
+
+		if (nb_contexts == 0)
+			cnt = flow_age->aged_flows_cnt;
+		else {
+			start_id = flow_age->start_id;
+			end_id = flow_age->end_id;
+			for (i = start_id; i <= end_id; i++) {
+				if ((int)nb_contexts == cnt)
+					break;
+				if (plt_bitmap_get(flow_age->aged_flows, i)) {
+					context[cnt] =
+						roc_npc_aged_flow_ctx_get(roc_npc, i);
+					cnt++;
+				}
+			}
+		}
+	} while (plt_seqcount_read_retry(&flow_age->seq_cnt, sn));
+
+	return cnt;
+}
+
 struct rte_flow_ops cnxk_flow_ops = {
 	.validate = cnxk_flow_validate,
 	.flush = cnxk_flow_flush,
 	.query = cnxk_flow_query,
 	.isolate = cnxk_flow_isolate,
 	.dev_dump = cnxk_flow_dev_dump,
+	.get_aged_flows = cnxk_flow_get_aged_flows,
 };
-- 
2.25.1

