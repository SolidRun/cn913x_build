From 0cabc130cb0a090f434edac1da6d6bc602c8b1dc Mon Sep 17 00:00:00 2001
From: Anoob Joseph <anoobj@marvell.com>
Date: Tue, 18 Apr 2023 10:21:19 +0000
Subject: [PATCH 376/955] crypto/cnxk: increase max segments

Increase max segments to allow max values supported by
hardware/microcode. For SG_VER2, max number of descriptors supported
would be 45. For SG_VER1, maximum number of total components would be
100.

Signed-off-by: Anoob Joseph <anoobj@marvell.com>
Change-Id: Ie65ae008ecf16ee993b5b2326be4918399c2ec9c
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/102111
Base-Builds: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
---
 drivers/common/cnxk/roc_cpt_sg.h |  4 +-
 drivers/crypto/cnxk/cnxk_se.h    | 90 ++++++++++++++++++++++++--------
 2 files changed, 72 insertions(+), 22 deletions(-)

diff --git a/drivers/common/cnxk/roc_cpt_sg.h b/drivers/common/cnxk/roc_cpt_sg.h
index 8a97e1aa5b74b..c12187144fd14 100644
--- a/drivers/common/cnxk/roc_cpt_sg.h
+++ b/drivers/common/cnxk/roc_cpt_sg.h
@@ -7,11 +7,13 @@
 
 #define ROC_DMA_MODE_SG (1 << 7)
 
-#define ROC_MAX_SG_IN_OUT_CNT 32
+#define ROC_MAX_SG_IN_OUT_CNT 128
 #define ROC_MAX_SG_CNT	      (ROC_MAX_SG_IN_OUT_CNT / 2)
 
 #define ROC_SG_LIST_HDR_SIZE (8u)
 #define ROC_SG_ENTRY_SIZE    sizeof(struct roc_sglist_comp)
+#define ROC_SG_MAX_COMP	     25
+#define ROC_SG_MAX_DLEN_SIZE (ROC_SG_LIST_HDR_SIZE + (ROC_SG_MAX_COMP * ROC_SG_ENTRY_SIZE))
 
 struct roc_sglist_comp {
 	union {
diff --git a/drivers/crypto/cnxk/cnxk_se.h b/drivers/crypto/cnxk/cnxk_se.h
index 8715493cae391..784b9141373c9 100644
--- a/drivers/crypto/cnxk/cnxk_se.h
+++ b/drivers/crypto/cnxk/cnxk_se.h
@@ -225,10 +225,10 @@ sg_inst_prep(struct roc_se_fc_params *params, struct cpt_inst_s *inst, uint64_t
 	uint32_t mac_len = 0, aad_len = 0;
 	struct roc_se_ctx *se_ctx;
 	uint32_t i, g_size_bytes;
+	int zsk_flags, ret = 0;
 	uint64_t *offset_vaddr;
 	uint32_t s_size_bytes;
 	uint8_t *in_buffer;
-	int zsk_flags;
 	uint32_t size;
 	uint8_t *iv_d;
 
@@ -395,8 +395,13 @@ sg_inst_prep(struct roc_se_fc_params *params, struct cpt_inst_s *inst, uint64_t
 	/* This is DPTR len in case of SG mode */
 	inst->w4.s.dlen = size;
 
+	if (unlikely(size > ROC_SG_MAX_DLEN_SIZE)) {
+		plt_dp_err("Exceeds max supported components. Reduce segments");
+		ret = -1;
+	}
+
 	inst->dptr = (uint64_t)in_buffer;
-	return 0;
+	return ret;
 }
 
 static __rte_always_inline int
@@ -409,12 +414,13 @@ sg2_inst_prep(struct roc_se_fc_params *params, struct cpt_inst_s *inst, uint64_t
 	void *m_vaddr = params->meta_buf.vaddr;
 	struct roc_se_buf_ptr *aad_buf = NULL;
 	uint32_t mac_len = 0, aad_len = 0;
+	uint16_t scatter_sz, gather_sz;
 	union cpt_inst_w5 cpt_inst_w5;
 	union cpt_inst_w6 cpt_inst_w6;
 	struct roc_se_ctx *se_ctx;
 	uint32_t i, g_size_bytes;
 	uint64_t *offset_vaddr;
-	int zsk_flags;
+	int zsk_flags, ret = 0;
 	uint32_t size;
 	uint8_t *iv_d;
 
@@ -435,6 +441,9 @@ sg2_inst_prep(struct roc_se_fc_params *params, struct cpt_inst_s *inst, uint64_t
 
 	inst->w4.s.opcode_major |= (uint64_t)ROC_DMA_MODE_SG;
 
+	/* This is DPTR len in case of SG mode */
+	inst->w4.s.dlen = inputlen + ROC_SE_OFF_CTRL_LEN;
+
 	/* iv offset is 0 */
 	*offset_vaddr = offset_ctrl;
 
@@ -505,9 +514,9 @@ sg2_inst_prep(struct roc_se_fc_params *params, struct cpt_inst_s *inst, uint64_t
 		}
 	}
 
-	cpt_inst_w5.s.gather_sz = ((i + 2) / 3);
+	gather_sz = (i + 2) / 3;
+	g_size_bytes = gather_sz * sizeof(struct roc_sg2list_comp);
 
-	g_size_bytes = ((i + 2) / 3) * sizeof(struct roc_sg2list_comp);
 	/*
 	 * Output Scatter List
 	 */
@@ -573,17 +582,23 @@ sg2_inst_prep(struct roc_se_fc_params *params, struct cpt_inst_s *inst, uint64_t
 		}
 	}
 
-	cpt_inst_w6.s.scatter_sz = ((i + 2) / 3);
+	scatter_sz = (i + 2) / 3;
 
-	/* This is DPTR len in case of SG mode */
-	inst->w4.s.dlen = inputlen + ROC_SE_OFF_CTRL_LEN;
+	cpt_inst_w5.s.gather_sz = gather_sz;
+	cpt_inst_w6.s.scatter_sz = scatter_sz;
 
 	cpt_inst_w5.s.dptr = (uint64_t)gather_comp;
 	cpt_inst_w6.s.rptr = (uint64_t)scatter_comp;
 
 	inst->w5.u64 = cpt_inst_w5.u64;
 	inst->w6.u64 = cpt_inst_w6.u64;
-	return 0;
+
+	if (unlikely((scatter_sz >> 4) || (gather_sz >> 4))) {
+		plt_dp_err("Exceeds max supported components. Reduce segments");
+		ret = -1;
+	}
+
+	return ret;
 }
 
 static __rte_always_inline int
@@ -599,6 +614,7 @@ cpt_digest_gen_sg_ver1_prep(uint32_t flags, uint64_t d_lens, struct roc_se_fc_pa
 	struct roc_se_ctx *ctx;
 	uint8_t *in_buffer;
 	uint32_t size, i;
+	int ret = 0;
 
 	ctx = params->ctx;
 
@@ -692,22 +708,27 @@ cpt_digest_gen_sg_ver1_prep(uint32_t flags, uint64_t d_lens, struct roc_se_fc_pa
 
 	size = g_size_bytes + s_size_bytes + ROC_SG_LIST_HDR_SIZE;
 
+	if (unlikely(size > ROC_SG_MAX_DLEN_SIZE)) {
+		plt_dp_err("Exceeds max supported components. Reduce segments");
+		ret = -1;
+	}
+
 	/* This is DPTR len in case of SG mode */
 	cpt_inst_w4.s.dlen = size;
 
 	inst->dptr = (uint64_t)in_buffer;
 	inst->w4.u64 = cpt_inst_w4.u64;
 
-	return 0;
+	return ret;
 }
 
 static __rte_always_inline int
 cpt_digest_gen_sg_ver2_prep(uint32_t flags, uint64_t d_lens, struct roc_se_fc_params *params,
 			    struct cpt_inst_s *inst)
 {
+	uint16_t data_len, mac_len, key_len, scatter_sz, gather_sz;
 	struct roc_sg2list_comp *gather_comp, *scatter_comp;
 	void *m_vaddr = params->meta_buf.vaddr;
-	uint16_t data_len, mac_len, key_len;
 	union cpt_inst_w4 cpt_inst_w4;
 	union cpt_inst_w5 cpt_inst_w5;
 	union cpt_inst_w6 cpt_inst_w6;
@@ -715,6 +736,7 @@ cpt_digest_gen_sg_ver2_prep(uint32_t flags, uint64_t d_lens, struct roc_se_fc_pa
 	struct roc_se_ctx *ctx;
 	uint32_t g_size_bytes;
 	uint32_t size, i;
+	int ret = 0;
 
 	ctx = params->ctx;
 
@@ -768,9 +790,9 @@ cpt_digest_gen_sg_ver2_prep(uint32_t flags, uint64_t d_lens, struct roc_se_fc_pa
 		plt_dp_err("Insufficient dst IOV size, short by %dB", size);
 		return -1;
 	}
-	cpt_inst_w5.s.gather_sz = ((i + 2) / 3);
 
-	g_size_bytes = ((i + 2) / 3) * sizeof(struct roc_sg2list_comp);
+	gather_sz = (i + 2) / 3;
+	g_size_bytes = gather_sz * sizeof(struct roc_sg2list_comp);
 
 	/*
 	 * Output Gather list
@@ -797,7 +819,10 @@ cpt_digest_gen_sg_ver2_prep(uint32_t flags, uint64_t d_lens, struct roc_se_fc_pa
 		}
 	}
 
-	cpt_inst_w6.s.scatter_sz = ((i + 2) / 3);
+	scatter_sz = (i + 2) / 3;
+
+	cpt_inst_w5.s.gather_sz = gather_sz;
+	cpt_inst_w6.s.scatter_sz = scatter_sz;
 
 	cpt_inst_w5.s.dptr = (uint64_t)gather_comp;
 	cpt_inst_w6.s.rptr = (uint64_t)scatter_comp;
@@ -807,7 +832,12 @@ cpt_digest_gen_sg_ver2_prep(uint32_t flags, uint64_t d_lens, struct roc_se_fc_pa
 
 	inst->w4.u64 = cpt_inst_w4.u64;
 
-	return 0;
+	if (unlikely((scatter_sz >> 4) || (gather_sz >> 4))) {
+		plt_dp_err("Exceeds max supported components. Reduce segments");
+		ret = -1;
+	}
+
+	return ret;
 }
 
 static inline int
@@ -824,6 +854,7 @@ pdcp_chain_sg1_prep(struct roc_se_fc_params *params, struct roc_se_ctx *cpt_ctx,
 	uint8_t *iv_d, *in_buffer;
 	uint64_t *offset_vaddr;
 	uint32_t size;
+	int ret = 0;
 
 	/* save space for IV */
 	offset_vaddr = m_vaddr;
@@ -904,13 +935,18 @@ pdcp_chain_sg1_prep(struct roc_se_fc_params *params, struct roc_se_ctx *cpt_ctx,
 
 	size = g_size_bytes + s_size_bytes + ROC_SG_LIST_HDR_SIZE;
 
+	if (unlikely(size > ROC_SG_MAX_DLEN_SIZE)) {
+		plt_dp_err("Exceeds max supported components. Reduce segments");
+		ret = -1;
+	}
+
 	/* This is DPTR len in case of SG mode */
 	w4.s.dlen = size;
 	inst->w4.u64 = w4.u64;
 
 	inst->dptr = (uint64_t)in_buffer;
 
-	return 0;
+	return ret;
 }
 
 static inline int
@@ -922,6 +958,7 @@ pdcp_chain_sg2_prep(struct roc_se_fc_params *params, struct roc_se_ctx *cpt_ctx,
 {
 	struct roc_sg2list_comp *gather_comp, *scatter_comp;
 	void *m_vaddr = params->meta_buf.vaddr;
+	uint16_t scatter_sz, gather_sz;
 	const uint32_t mac_len = 4;
 	uint32_t i, g_size_bytes;
 	uint64_t *offset_vaddr;
@@ -929,6 +966,7 @@ pdcp_chain_sg2_prep(struct roc_se_fc_params *params, struct roc_se_ctx *cpt_ctx,
 	union cpt_inst_w6 w6;
 	uint8_t *iv_d;
 	uint32_t size;
+	int ret = 0;
 
 	/* save space for IV */
 	offset_vaddr = m_vaddr;
@@ -968,9 +1006,9 @@ pdcp_chain_sg2_prep(struct roc_se_fc_params *params, struct roc_se_ctx *cpt_ctx,
 			return -1;
 		}
 	}
-	w5.s.gather_sz = ((i + 2) / 3);
-	w5.s.dptr = (uint64_t)gather_comp;
-	g_size_bytes = ((i + 2) / 3) * sizeof(struct roc_sg2list_comp);
+
+	gather_sz = (i + 2) / 3;
+	g_size_bytes = gather_sz * sizeof(struct roc_sg2list_comp);
 
 	/*
 	 * Output Scatter List
@@ -1001,14 +1039,24 @@ pdcp_chain_sg2_prep(struct roc_se_fc_params *params, struct roc_se_ctx *cpt_ctx,
 		}
 	}
 
-	w6.s.scatter_sz = ((i + 2) / 3);
+	scatter_sz = (i + 2) / 3;
+
+	w5.s.gather_sz = gather_sz;
+	w6.s.scatter_sz = scatter_sz;
+
+	w5.s.dptr = (uint64_t)gather_comp;
 	w6.s.rptr = (uint64_t)scatter_comp;
 
 	inst->w4.u64 = w4.u64;
 	inst->w5.u64 = w5.u64;
 	inst->w6.u64 = w6.u64;
 
-	return 0;
+	if (unlikely((scatter_sz >> 4) || (gather_sz >> 4))) {
+		plt_dp_err("Exceeds max supported components. Reduce segments");
+		ret = -1;
+	}
+
+	return ret;
 }
 
 static __rte_always_inline int
-- 
2.25.1

