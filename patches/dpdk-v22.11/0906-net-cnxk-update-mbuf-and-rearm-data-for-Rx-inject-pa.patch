From b04f7d250c9e3876cbec0660b0369288e92c0818 Mon Sep 17 00:00:00 2001
From: Rakesh Kudurumalla <rkudurumalla@marvell.com>
Date: Wed, 10 Jul 2024 14:27:01 +0530
Subject: [PATCH 906/955] net/cnxk: update mbuf and rearm data for Rx inject
 packets

When nix receives second pass packets injected to CPT
next segments of primary mbuf are accessed directly using
mbuf next pointer since we do not know at what offset mbuf
is available.To achieve this we do no update mbut next pointer
to NULL for Rx injected packets.

Signed-off-by: Rakesh Kudurumalla <rkudurumalla@marvell.com>
Change-Id: Ib6000b18fb09827d64cb7aa7d0e097e820944752
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/131044
Base-Builds: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Reviewed-by: Rahul Bhansali <rbhansali@marvell.com>
Reviewed-by: Nithin Kumar Dabilpuram <ndabilpuram@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/131858
Reviewed-by: Anoob Joseph <anoobj@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/133106
---
 drivers/net/cnxk/cn10k_rx.h | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/drivers/net/cnxk/cn10k_rx.h b/drivers/net/cnxk/cn10k_rx.h
index 9dde2bea57ac3..990dfbee3e643 100644
--- a/drivers/net/cnxk/cn10k_rx.h
+++ b/drivers/net/cnxk/cn10k_rx.h
@@ -709,6 +709,7 @@ nix_cqe_xtract_mseg(const union nix_rx_parse_u *rx, struct rte_mbuf *mbuf,
 	uint16_t later_skip = 0;
 	struct rte_mbuf *head;
 	const rte_iova_t *eol;
+	bool rx_inj = false;
 	uint64_t cq_w5 = 0;
 	uint16_t ihl = 0;
 	uint64_t fsz = 0;
@@ -729,7 +730,9 @@ nix_cqe_xtract_mseg(const union nix_rx_parse_u *rx, struct rte_mbuf *mbuf,
 		/* Rx Inject packet must have Match ID 0xFFFF and for this
 		 * wqe will get from address stored at mbuf+1 location
 		 */
-		if ((flags & NIX_RX_REAS_F) && hdr->w0.match_id == 0xFFFFU)
+		rx_inj = ((flags & NIX_RX_REAS_F) && ((hdr->w0.match_id == 0xFFFFU) ||
+					       (hdr->w0.cookie == 0xFFFFFFFFU)));
+		if (rx_inj)
 			wqe = (const uint64_t *)*((uint64_t *)(mbuf + 1));
 		else
 			wqe = (const uint64_t *)(mbuf + 1);
@@ -786,7 +789,8 @@ nix_cqe_xtract_mseg(const union nix_rx_parse_u *rx, struct rte_mbuf *mbuf,
 	later_skip = (uintptr_t)mbuf->buf_addr - (uintptr_t)mbuf;
 
 	while (nb_segs) {
-		mbuf->next = (struct rte_mbuf *)(*iova_list - later_skip);
+		if (!(flags & NIX_RX_REAS_F) || !rx_inj)
+			mbuf->next = (struct rte_mbuf *)(*iova_list - later_skip);
 		mbuf = mbuf->next;
 
 		RTE_MEMPOOL_CHECK_COOKIES(mbuf->pool, (void **)&mbuf, 1, 1);
@@ -804,7 +808,8 @@ nix_cqe_xtract_mseg(const union nix_rx_parse_u *rx, struct rte_mbuf *mbuf,
 		mbuf->data_len = sg_len;
 		sg = sg >> 16;
 		p = (uintptr_t)&mbuf->rearm_data;
-		*(uint64_t *)p = rearm & ~0xFFFF;
+		if (!(flags & NIX_RX_REAS_F) || !rx_inj)
+			*(uint64_t *)p = rearm & ~0xFFFF;
 		nb_segs--;
 		iova_list++;
 
@@ -1259,7 +1264,6 @@ cn10k_nix_rx_inj_prepare_mseg(struct rte_mbuf *m, uint64_t *cmd)
 			slist++;
 		}
 		m_next = m->next;
-		m->next = NULL;
 		m = m_next;
 	} while (nb_segs);
 
-- 
2.25.1

