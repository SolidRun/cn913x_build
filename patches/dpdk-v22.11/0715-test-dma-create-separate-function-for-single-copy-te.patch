From 26ae49028f1b86c1eaa57a753079245c1713b71f Mon Sep 17 00:00:00 2001
From: Bruce Richardson <bruce.richardson@intel.com>
Date: Thu, 16 Feb 2023 11:09:18 +0000
Subject: [PATCH 715/955] test/dma: create separate function for single copy
 test

The copy tests for dmadev had separate blocks in the test function for
single copy and burst copies. Separate out the single-copy block to its
own function so that it can be re-used if necessary.

Signed-off-by: Bruce Richardson <bruce.richardson@intel.com>
Acked-by: Kevin Laatz <kevin.laatz@intel.com>
Acked-by: Chengwen Feng <fengchengwen@huawei.com>
Change-Id: I885efce4b08af522329d95f47f54b12fc504c8db
---
 app/test/test_dmadev.c | 120 ++++++++++++++++++++++-------------------
 1 file changed, 64 insertions(+), 56 deletions(-)

diff --git a/app/test/test_dmadev.c b/app/test/test_dmadev.c
index 665c4d2206732..28c703bf551b0 100644
--- a/app/test/test_dmadev.c
+++ b/app/test/test_dmadev.c
@@ -201,77 +201,85 @@ do_multi_copies(int16_t dev_id, uint16_t vchan,
 }
 
 static int
-test_enqueue_copies(int16_t dev_id, uint16_t vchan)
+test_single_copy(int16_t dev_id, uint16_t vchan)
 {
-	enum rte_dma_status_code status;
-	unsigned int i;
+	uint16_t i;
 	uint16_t id;
+	enum rte_dma_status_code status;
+	struct rte_mbuf *src, *dst;
+	char *src_data, *dst_data;
 
-	/* test doing a single copy */
-	do {
-		struct rte_mbuf *src, *dst;
-		char *src_data, *dst_data;
+	src = rte_pktmbuf_alloc(pool);
+	dst = rte_pktmbuf_alloc(pool);
+	src_data = rte_pktmbuf_mtod(src, char *);
+	dst_data = rte_pktmbuf_mtod(dst, char *);
 
-		src = rte_pktmbuf_alloc(pool);
-		dst = rte_pktmbuf_alloc(pool);
-		src_data = rte_pktmbuf_mtod(src, char *);
-		dst_data = rte_pktmbuf_mtod(dst, char *);
+	for (i = 0; i < COPY_LEN; i++)
+		src_data[i] = rte_rand() & 0xFF;
 
-		for (i = 0; i < COPY_LEN; i++)
-			src_data[i] = rte_rand() & 0xFF;
+	id = rte_dma_copy(dev_id, vchan, rte_pktmbuf_iova(src), rte_pktmbuf_iova(dst),
+			COPY_LEN, RTE_DMA_OP_FLAG_SUBMIT);
+	if (id != id_count)
+		ERR_RETURN("Error with rte_dma_copy, got %u, expected %u\n",
+				id, id_count);
 
-		id = rte_dma_copy(dev_id, vchan, rte_pktmbuf_iova(src), rte_pktmbuf_iova(dst),
-				COPY_LEN, RTE_DMA_OP_FLAG_SUBMIT);
-		if (id != id_count)
-			ERR_RETURN("Error with rte_dma_copy, got %u, expected %u\n",
-					id, id_count);
+	/* give time for copy to finish, then check it was done */
+	await_hw(dev_id, vchan);
 
-		/* give time for copy to finish, then check it was done */
-		await_hw(dev_id, vchan);
+	for (i = 0; i < COPY_LEN; i++)
+		if (dst_data[i] != src_data[i])
+			ERR_RETURN("Data mismatch at char %u [Got %02x not %02x]\n", i,
+					dst_data[i], src_data[i]);
 
-		for (i = 0; i < COPY_LEN; i++)
-			if (dst_data[i] != src_data[i])
-				ERR_RETURN("Data mismatch at char %u [Got %02x not %02x]\n", i,
-						dst_data[i], src_data[i]);
-
-		/* now check completion works */
-		id = ~id;
-		if (rte_dma_completed(dev_id, vchan, 1, &id, NULL) != 1)
-			ERR_RETURN("Error with rte_dma_completed\n");
-
-		if (id != id_count)
-			ERR_RETURN("Error:incorrect job id received, %u [expected %u]\n",
-					id, id_count);
-
-		/* check for completed and id when no job done */
-		id = ~id;
-		if (rte_dma_completed(dev_id, vchan, 1, &id, NULL) != 0)
-			ERR_RETURN("Error with rte_dma_completed when no job done\n");
-		if (id != id_count)
-			ERR_RETURN("Error:incorrect job id received when no job done, %u [expected %u]\n",
-					id, id_count);
-
-		/* check for completed_status and id when no job done */
-		id = ~id;
-		if (rte_dma_completed_status(dev_id, vchan, 1, &id, &status) != 0)
-			ERR_RETURN("Error with rte_dma_completed_status when no job done\n");
-		if (id != id_count)
-			ERR_RETURN("Error:incorrect job id received when no job done, %u [expected %u]\n",
-					id, id_count);
+	/* now check completion works */
+	id = ~id;
+	if (rte_dma_completed(dev_id, vchan, 1, &id, NULL) != 1)
+		ERR_RETURN("Error with rte_dma_completed\n");
 
-		rte_pktmbuf_free(src);
-		rte_pktmbuf_free(dst);
+	if (id != id_count)
+		ERR_RETURN("Error:incorrect job id received, %u [expected %u]\n",
+				id, id_count);
+
+	/* check for completed and id when no job done */
+	id = ~id;
+	if (rte_dma_completed(dev_id, vchan, 1, &id, NULL) != 0)
+		ERR_RETURN("Error with rte_dma_completed when no job done\n");
+	if (id != id_count)
+		ERR_RETURN("Error:incorrect job id received when no job done, %u [expected %u]\n",
+				id, id_count);
+
+	/* check for completed_status and id when no job done */
+	id = ~id;
+	if (rte_dma_completed_status(dev_id, vchan, 1, &id, &status) != 0)
+		ERR_RETURN("Error with rte_dma_completed_status when no job done\n");
+	if (id != id_count)
+		ERR_RETURN("Error:incorrect job id received when no job done, %u [expected %u]\n",
+				id, id_count);
+
+	rte_pktmbuf_free(src);
+	rte_pktmbuf_free(dst);
 
-		/* now check completion returns nothing more */
-		if (rte_dma_completed(dev_id, 0, 1, NULL, NULL) != 0)
-			ERR_RETURN("Error with rte_dma_completed in empty check\n");
+	/* now check completion returns nothing more */
+	if (rte_dma_completed(dev_id, 0, 1, NULL, NULL) != 0)
+		ERR_RETURN("Error with rte_dma_completed in empty check\n");
 
-		id_count++;
+	id_count++;
 
-	} while (0);
+	return 0;
+}
+
+static int
+test_enqueue_copies(int16_t dev_id, uint16_t vchan)
+{
+	unsigned int i;
+
+	/* test doing a single copy */
+	if (test_single_copy(dev_id, vchan) < 0)
+		return -1;
 
 	/* test doing a multiple single copies */
 	do {
+		uint16_t id;
 		const uint16_t max_ops = 4;
 		struct rte_mbuf *src, *dst;
 		char *src_data, *dst_data;
-- 
2.25.1

