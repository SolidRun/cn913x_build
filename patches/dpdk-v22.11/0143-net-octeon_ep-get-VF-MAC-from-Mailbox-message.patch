From 9f7ab95003d0e954ee8db5b5180907957fb72cb5 Mon Sep 17 00:00:00 2001
From: Sathesh Edara <sedara@marvell.com>
Date: Mon, 2 Jan 2023 06:24:08 -0800
Subject: [PATCH 143/955] net/octeon_ep: get VF MAC from Mailbox message

add support in DPDK to get VF Mac address from
Mailbox message.The VF should query its MAC
address from PF using mailbox message and use
that MAC address instead of using a random mac
address.If it does not obtain a mac address from
PF, it should use a random mac address.

Signed-off-by: Sathesh Edara <sedara@marvell.com>
Change-Id: I83e594798e18822ce4eba3340a12dd4459d6f9e3
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/93515
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Reviewed-by: Veerasenareddy Burru <vburru@marvell.com>
---
 drivers/net/octeon_ep/otx_ep_ethdev.c | 70 +++++++++++++++++++--------
 1 file changed, 51 insertions(+), 19 deletions(-)

diff --git a/drivers/net/octeon_ep/otx_ep_ethdev.c b/drivers/net/octeon_ep/otx_ep_ethdev.c
index eeafcfed64810..3a50117a418f7 100644
--- a/drivers/net/octeon_ep/otx_ep_ethdev.c
+++ b/drivers/net/octeon_ep/otx_ep_ethdev.c
@@ -17,9 +17,6 @@
 
 #define OTX_EP_DEV(_eth_dev) \
 	((struct otx_ep_device *)(_eth_dev)->data->dev_private)
-int
-otx_ep_dev_get_mac_addr(struct rte_eth_dev *eth_dev,
-			struct rte_ether_addr *mac_addr);
 
 static const struct rte_eth_desc_lim otx_ep_rx_desc_lim = {
 	.nb_max		= OTX_EP_MAX_OQ_DESCRIPTORS,
@@ -337,18 +334,21 @@ otx_ep_dev_set_default_mac_addr(struct rte_eth_dev *eth_dev,
 	for (i = 0; i < RTE_ETHER_ADDR_LEN; i++)
 		cmd.s_set_mac.mac_addr[i] = mac_addr->addr_bytes[i];
 	ret = otx_ep_send_mbox_cmd(otx_epvf, cmd, &rsp);
-	if (ret)
+	if (ret) {
+		otx_ep_err("%s Sending Mbox message fails ret val:%d\n", __func__, ret);
 		return ret;
-	if (rsp.s_set_mac.type != OTX_VF_MBOX_TYPE_RSP_ACK)
+	}
+	if (rsp.s_set_mac.type != OTX_VF_MBOX_TYPE_RSP_ACK) {
+		otx_ep_err("%s Received NACK Mbox message\n", __func__);
 		return -EINVAL;
-	otx_ep_dbg("mac addr  set  success addr %02x:%02x:%02x:%02x:%02x:%02x\n",
-		  mac_addr->addr_bytes[0], mac_addr->addr_bytes[1], mac_addr->addr_bytes[2],
-		  mac_addr->addr_bytes[3], mac_addr->addr_bytes[4], mac_addr->addr_bytes[5]);
-	rte_ether_addr_copy(eth_dev->data->mac_addrs, mac_addr);
+	}
+	otx_ep_dbg("%s VF MAC " RTE_ETHER_ADDR_PRT_FMT "\n",
+		    __func__, RTE_ETHER_ADDR_BYTES(mac_addr));
+	rte_ether_addr_copy(mac_addr, eth_dev->data->mac_addrs);
 	return 0;
 }
 
-int
+static int
 otx_ep_dev_get_mac_addr(struct rte_eth_dev *eth_dev,
 			struct rte_ether_addr *mac_addr)
 {
@@ -360,16 +360,18 @@ otx_ep_dev_get_mac_addr(struct rte_eth_dev *eth_dev,
 	cmd.u64 = 0;
 	cmd.s_set_mac.opcode = OTX_VF_MBOX_CMD_GET_MAC_ADDR;
 	ret = otx_ep_send_mbox_cmd(otx_epvf, cmd, &rsp);
-	if (ret)
+	if (ret) {
+		otx_ep_err("%s Sending Mbox message fails ret val:%d\n", __func__, ret);
 		return ret;
-	if (rsp.s_set_mac.type != OTX_VF_MBOX_TYPE_RSP_ACK)
+	}
+	if (rsp.s_set_mac.type != OTX_VF_MBOX_TYPE_RSP_ACK) {
+		otx_ep_err("%s Received NACK Mbox message\n", __func__);
 		return -EINVAL;
+	}
 	for (i = 0; i < RTE_ETHER_ADDR_LEN; i++)
 		mac_addr->addr_bytes[i] = rsp.s_set_mac.mac_addr[i];
-	otx_ep_dbg("mac addr  get  success addr %02x:%02x:%02x:%02x:%02x:%02x\n",
-		  mac_addr->addr_bytes[0], mac_addr->addr_bytes[1],
-		  mac_addr->addr_bytes[2], mac_addr->addr_bytes[3],
-		  mac_addr->addr_bytes[4], mac_addr->addr_bytes[5]);
+	otx_ep_dbg("%s VF MAC " RTE_ETHER_ADDR_PRT_FMT "\n",
+		    __func__, RTE_ETHER_ADDR_BYTES(mac_addr));
 	return 0;
 }
 
@@ -897,6 +899,37 @@ otx_ep_parse_parameters(struct rte_eth_dev *dev)
 	return ret;
 }
 
+static int otx_ep_eth_dev_query_set_vf_mac(struct rte_eth_dev *eth_dev,
+					   struct rte_ether_addr *mac_addr)
+{
+	int ret_val;
+
+	memset(mac_addr, 0, sizeof(struct rte_ether_addr));
+	ret_val = otx_ep_dev_get_mac_addr(eth_dev, mac_addr);
+	if (!ret_val) {
+		if (!rte_is_valid_assigned_ether_addr(mac_addr)) {
+			otx_ep_dbg("PF doesn't have valid VF MAC addr" RTE_ETHER_ADDR_PRT_FMT "\n",
+				    RTE_ETHER_ADDR_BYTES(mac_addr));
+			rte_eth_random_addr(mac_addr->addr_bytes);
+			otx_ep_dbg("%s VF setting Random MAC address" RTE_ETHER_ADDR_PRT_FMT "\n",
+				    __func__, RTE_ETHER_ADDR_BYTES(mac_addr));
+			ret_val = otx_ep_dev_set_default_mac_addr(eth_dev, mac_addr);
+			if (ret_val) {
+				otx_ep_err("%s Setting VF MAC " RTE_ETHER_ADDR_PRT_FMT "fails\n",
+					     __func__, RTE_ETHER_ADDR_BYTES(mac_addr));
+				return ret_val;
+			}
+		}
+		otx_ep_dbg("VF received valid MAC addr from PF" RTE_ETHER_ADDR_PRT_FMT "\n",
+			    RTE_ETHER_ADDR_BYTES(mac_addr));
+	} else {
+		otx_ep_err("%s Getting VF MAC from PF via Mbox fails with ret_val: %d\n",
+			    __func__, ret_val);
+		return ret_val;
+	}
+	return 0;
+}
+
 static int
 otx_ep_eth_dev_init(struct rte_eth_dev *eth_dev)
 {
@@ -921,8 +954,6 @@ otx_ep_eth_dev_init(struct rte_eth_dev *eth_dev)
 		eth_dev->dev_ops = NULL;
 		return -ENOMEM;
 	}
-	rte_eth_random_addr(vf_mac_addr.addr_bytes);
-	rte_ether_addr_copy(&vf_mac_addr, eth_dev->data->mac_addrs);
 	otx_epvf->hw_addr = pdev->mem_resource[0].addr;
 	otx_epvf->pdev = pdev;
 
@@ -952,11 +983,12 @@ otx_ep_eth_dev_init(struct rte_eth_dev *eth_dev)
 		otx_ep_err("Invalid chip id\n");
 		return -EINVAL;
 	}
-	if (otx_ep_dev_set_default_mac_addr(eth_dev,
+	if (otx_ep_eth_dev_query_set_vf_mac(eth_dev,
 				(struct rte_ether_addr *)&vf_mac_addr)) {
 		otx_ep_err("set mac addr failed\n");
 		return -ENODEV;
 	}
+	rte_ether_addr_copy(&vf_mac_addr, eth_dev->data->mac_addrs);
 	return 0;
 }
 
-- 
2.25.1

