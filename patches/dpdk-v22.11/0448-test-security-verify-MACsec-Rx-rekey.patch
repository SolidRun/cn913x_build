From a2209282e41ebb010c08246f896fb68a6ff4b2c3 Mon Sep 17 00:00:00 2001
From: Ankur Dwivedi <adwivedi@marvell.com>
Date: Tue, 9 May 2023 21:07:01 +0530
Subject: [PATCH 448/955] test/security: verify MACsec Rx rekey

This patch enables the Rx rekey test case for MACSEC.

Signed-off-by: Ankur Dwivedi <adwivedi@marvell.com>
Change-Id: If54923265385b5a968f69314419f4b59f6f9d581
---
 app/test/test_security_inline_macsec.c | 50 +++++++++++++++++++++++++-
 1 file changed, 49 insertions(+), 1 deletion(-)

diff --git a/app/test/test_security_inline_macsec.c b/app/test/test_security_inline_macsec.c
index e4a719daf8414..697d812077120 100644
--- a/app/test/test_security_inline_macsec.c
+++ b/app/test/test_security_inline_macsec.c
@@ -907,8 +907,14 @@ test_macsec(const struct mcs_test_vector *td[], enum mcs_op op, const struct mcs
 		if (op == MCS_DECAP || op == MCS_ENCAP_DECAP ||
 				op == MCS_VERIFY_ONLY || op == MCS_AUTH_VERIFY) {
 			for (an = 0; an < RTE_SECURITY_MACSEC_NUM_AN; an++) {
+				if (opts->rekey_en && an ==
+						(opts->rekey_td->secure_pkt.data[tci_off] &
+						RTE_MACSEC_AN_MASK))
+					fill_macsec_sa_conf(opts->rekey_td, &sa_conf,
+						RTE_SECURITY_MACSEC_DIR_RX, an, tci_off);
+				else
 				/* For simplicity, using same SA conf for all AN */
-				fill_macsec_sa_conf(td[i], &sa_conf,
+					fill_macsec_sa_conf(td[i], &sa_conf,
 						RTE_SECURITY_MACSEC_DIR_RX, an, tci_off);
 				id = rte_security_macsec_sa_create(ctx, &sa_conf);
 				if (id < 0) {
@@ -1055,6 +1061,9 @@ test_macsec(const struct mcs_test_vector *td[], enum mcs_op op, const struct mcs
 			}
 			tx_sa_id[0][0] = (uint16_t)id;
 			break;
+		case RTE_ETH_EVENT_MACSEC_RX_SA_PN_SOFT_EXP:
+			printf("Received RTE_ETH_EVENT_MACSEC_RX_SA_PN_SOFT_EXP event\n");
+			break;
 		default:
 			printf("Received unsupported event\n");
 		}
@@ -1952,6 +1961,41 @@ test_inline_macsec_rekey_tx(const void *data __rte_unused)
 	return all_err;
 }
 
+static int
+test_inline_macsec_rekey_rx(const void *data __rte_unused)
+{
+	const struct mcs_test_vector *cur_td;
+	struct mcs_test_opts opts = {0};
+	int err, all_err = 0;
+	int i, size;
+
+	opts.val_frames = RTE_SECURITY_MACSEC_VALIDATE_STRICT;
+	opts.protect_frames = true;
+	opts.sa_in_use = 1;
+	opts.nb_td = 1;
+	opts.sectag_insert_mode = 1;
+	opts.mtu = RTE_ETHER_MTU;
+	opts.rekey_en = 1;
+
+	size = (sizeof(list_mcs_rekey_vectors) / sizeof((list_mcs_rekey_vectors)[0]));
+	for (i = 0; i < size; i++) {
+		cur_td = &list_mcs_rekey_vectors[i];
+		opts.rekey_td = &list_mcs_rekey_vectors[++i];
+		err = test_macsec(&cur_td, MCS_DECAP, &opts);
+		if (err) {
+			printf("Rx rekey test case %d failed\n", i);
+			err = -1;
+		} else {
+			printf("Rx rekey test case %d passed\n", i);
+			err = 0;
+		}
+		all_err += err;
+	}
+
+	printf("\n%s: Success: %d, Failure: %d\n", __func__, size + all_err, -all_err);
+	return all_err;
+}
+
 static int
 ut_setup_inline_macsec(void)
 {
@@ -2185,6 +2229,10 @@ static struct unit_test_suite inline_macsec_testsuite  = {
 			"MACsec re-key Tx",
 			ut_setup_inline_macsec, ut_teardown_inline_macsec,
 			test_inline_macsec_rekey_tx),
+		TEST_CASE_NAMED_ST(
+			"MACsec re-key Rx",
+			ut_setup_inline_macsec, ut_teardown_inline_macsec,
+			test_inline_macsec_rekey_rx),
 
 		TEST_CASES_END() /**< NULL terminate unit test array */
 	},
-- 
2.25.1

