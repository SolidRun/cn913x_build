From 4ce46329b264fa84791db3db16561df1d2a7d9fc Mon Sep 17 00:00:00 2001
From: Vamsi Attunuru <vattunuru@marvell.com>
Date: Wed, 18 Oct 2023 01:54:55 -0700
Subject: [PATCH 661/955] net/octeon_ep: clean up receive routine

Patch improves Rx routine and pkt count update routines,
packet count update routines need to drain inflight ISM
memory updates while decrementing the packet count register,
else ISM memory would provide invalid packet counts to the
driver.

Signed-off-by: Vamsi Attunuru <vattunuru@marvell.com>
Change-Id: Icec152bd80fa5443e65829f97ebd609866ac11e9
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/114167
Base-Builds: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Reviewed-by: Jerin Jacob Kollanukkaran <jerinj@marvell.com>
---
 drivers/net/octeon_ep/otx_ep_rxtx.c | 70 ++++++++++++-----------------
 1 file changed, 29 insertions(+), 41 deletions(-)

diff --git a/drivers/net/octeon_ep/otx_ep_rxtx.c b/drivers/net/octeon_ep/otx_ep_rxtx.c
index d23fbec0820d4..18203cb679222 100644
--- a/drivers/net/octeon_ep/otx_ep_rxtx.c
+++ b/drivers/net/octeon_ep/otx_ep_rxtx.c
@@ -442,7 +442,14 @@ otx_vf_update_read_index(struct otx_ep_instr_queue *iq)
 		 * when count above halfway to saturation.
 		 */
 		rte_write32(val, iq->inst_cnt_reg);
-		*iq->inst_cnt_ism = 0;
+		rte_mb();
+
+		rte_write64(OTX2_SDP_REQUEST_ISM, iq->inst_cnt_reg);
+		while (__atomic_load_n(iq->inst_cnt_ism, __ATOMIC_RELAXED) >= val) {
+			rte_write64(OTX2_SDP_REQUEST_ISM, iq->inst_cnt_reg);
+			rte_mb();
+		}
+
 		iq->inst_cnt_ism_prev = 0;
 	}
 	rte_write64(OTX2_SDP_REQUEST_ISM, iq->inst_cnt_reg);
@@ -760,7 +767,7 @@ otx_ep_droq_refill(struct otx_ep_droq *droq)
 		/* If a buffer could not be allocated, no point in
 		 * continuing
 		 */
-		if (unlikely(buf == NULL)) {
+		if (unlikely(!buf)) {
 			droq->stats.rx_alloc_failure++;
 			break;
 		}
@@ -781,8 +788,7 @@ otx_ep_droq_refill(struct otx_ep_droq *droq)
 }
 
 static struct rte_mbuf *
-otx_ep_droq_read_packet(struct otx_ep_device *otx_ep,
-			struct otx_ep_droq *droq, int next_fetch)
+otx_ep_droq_read_packet(struct otx_ep_device *otx_ep, struct otx_ep_droq *droq, int next_fetch)
 {
 	volatile struct otx_ep_droq_info *info;
 	struct rte_mbuf *mbuf_next = NULL;
@@ -808,15 +814,10 @@ otx_ep_droq_read_packet(struct otx_ep_device *otx_ep,
 			rte_delay_us_block(50);
 		}
 		if (!retry && !info->length) {
-			otx_ep_dbg("OCTEON DROQ[%d]: read_idx: %d; Retry failed !!\n",
+			otx_ep_err("OCTEON DROQ[%d]: read_idx: %d; Retry failed !!\n",
 				   droq->q_no, droq->read_idx);
 			/* May be zero length packet; drop it */
-			rte_pktmbuf_free(mbuf);
-			droq->recv_buf_list[droq->read_idx] = NULL;
-			droq->read_idx = otx_ep_incr_index(droq->read_idx, 1,
-							   droq->nb_desc);
-			droq->refill_count++;
-			return NULL;
+			assert(0);
 		}
 	}
 
@@ -831,16 +832,12 @@ otx_ep_droq_read_packet(struct otx_ep_device *otx_ep,
 	total_pkt_len = info->length + OTX_EP_INFO_SIZE;
 	if (total_pkt_len <= droq->buffer_size) {
 		mbuf->data_off += OTX_EP_INFO_SIZE;
-		/* otx_ep_dbg("OQ: pkt_len[%ld], buffer_size %d\n",
-		 * (long)info->length, droq->buffer_size);
-		 */
 		pkt_len = (uint32_t)info->length;
 		mbuf->pkt_len  = pkt_len;
 		mbuf->data_len  = pkt_len;
 		mbuf->port = otx_ep->port_id;
 		droq->recv_buf_list[droq->read_idx] = NULL;
-		droq->read_idx = otx_ep_incr_index(droq->read_idx, 1,
-						   droq->nb_desc);
+		droq->read_idx = otx_ep_incr_index(droq->read_idx, 1, droq->nb_desc);
 		droq->refill_count++;
 	} else {
 		struct rte_mbuf *first_buf = NULL;
@@ -853,28 +850,23 @@ otx_ep_droq_read_packet(struct otx_ep_device *otx_ep,
 		while (pkt_len < total_pkt_len) {
 			int cpy_len = 0;
 
-			cpy_len = ((pkt_len + droq->buffer_size) >
-					total_pkt_len)
-					? ((uint32_t)total_pkt_len -
-						pkt_len)
+			cpy_len = ((pkt_len + droq->buffer_size) > total_pkt_len)
+					? ((uint32_t)total_pkt_len - pkt_len)
 					: droq->buffer_size;
 
 			mbuf = droq->recv_buf_list[droq->read_idx];
 			droq->recv_buf_list[droq->read_idx] = NULL;
 
-			if (likely(mbuf != NULL)) {
+			if (likely(mbuf)) {
 				/* Note the first seg */
 				if (!pkt_len)
 					first_buf = mbuf;
 
 				mbuf->port = otx_ep->port_id;
 				if (!pkt_len) {
-					mbuf->data_off +=
-						OTX_EP_INFO_SIZE;
-					mbuf->pkt_len =
-						cpy_len - OTX_EP_INFO_SIZE;
-					mbuf->data_len =
-						cpy_len - OTX_EP_INFO_SIZE;
+					mbuf->data_off += OTX_EP_INFO_SIZE;
+					mbuf->pkt_len = cpy_len - OTX_EP_INFO_SIZE;
+					mbuf->data_len = cpy_len - OTX_EP_INFO_SIZE;
 				} else {
 					mbuf->pkt_len = cpy_len;
 					mbuf->data_len = cpy_len;
@@ -895,8 +887,7 @@ otx_ep_droq_read_packet(struct otx_ep_device *otx_ep,
 			}
 
 			pkt_len += cpy_len;
-			droq->read_idx = otx_ep_incr_index(droq->read_idx, 1,
-							   droq->nb_desc);
+			droq->read_idx = otx_ep_incr_index(droq->read_idx, 1, droq->nb_desc);
 			droq->refill_count++;
 		}
 		mbuf = first_buf;
@@ -916,11 +907,7 @@ otx_ep_check_droq_pkts(struct otx_ep_droq *droq)
 	 * This adds an extra local variable, but almost halves the
 	 * number of PCIe writes.
 	 */
-#ifdef OTX_DROQ_USE_ISM
 	val = *droq->pkts_sent_ism;
-#else
-	val = rte_read32(droq->pkts_sent_reg);
-#endif
 	new_pkts = val - droq->pkts_sent_ism_prev;
 	droq->pkts_sent_ism_prev = val;
 
@@ -930,14 +917,17 @@ otx_ep_check_droq_pkts(struct otx_ep_droq *droq)
 		 * when count above halfway to saturation.
 		 */
 		rte_write32(val, droq->pkts_sent_reg);
-#ifdef OTX_DROQ_USE_ISM
-		*droq->pkts_sent_ism = 0;
-#endif
+		rte_mb();
+
+		rte_write64(OTX2_SDP_REQUEST_ISM, droq->pkts_sent_reg);
+		while (__atomic_load_n(droq->pkts_sent_ism, __ATOMIC_RELAXED) >= val) {
+			rte_write64(OTX2_SDP_REQUEST_ISM, droq->pkts_sent_reg);
+			rte_mb();
+		}
+
 		droq->pkts_sent_ism_prev = 0;
 	}
-#ifdef OTX_DROQ_USE_ISM
 	rte_write64(OTX2_SDP_REQUEST_ISM, droq->pkts_sent_reg);
-#endif
 	droq->pkts_pending += new_pkts;
 
 	return new_pkts;
@@ -956,9 +946,7 @@ otx_ep_rx_pkts_to_process(struct otx_ep_droq *droq, uint16_t nb_pkts)
  * returns number of requests completed
  */
 uint16_t
-otx_ep_recv_pkts(void *rx_queue,
-		  struct rte_mbuf **rx_pkts,
-		  uint16_t nb_pkts)
+otx_ep_recv_pkts(void *rx_queue, struct rte_mbuf **rx_pkts, uint16_t nb_pkts)
 {
 	struct otx_ep_droq *droq = rx_queue;
 	struct otx_ep_device *otx_ep;
-- 
2.25.1

