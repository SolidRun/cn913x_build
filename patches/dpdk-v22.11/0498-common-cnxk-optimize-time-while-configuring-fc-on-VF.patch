From 5014d085e77356c37fb68ce5e1967b45a7c732cd Mon Sep 17 00:00:00 2001
From: Rakesh Kudurumalla <rkudurumalla@marvell.com>
Date: Tue, 16 May 2023 14:48:50 +0530
Subject: [PATCH 498/955] common/cnxk: optimize time while configuring fc on VF

PFC configuration function is taking 8 ms due
to mailbox communication to check whether sso is
connected to RQ and whether back pressure is enabled
on each aura. To optimize this time we are updating
aura attributes in nixlf and sso_ena parameter
in RQ during write configuration and the same updated
value is accessed while configuring flow control,
reducing time to 6 ms.

Change-Id: I0354ab70ebb874da7887fc0838183c6e288cfea7
Signed-off-by: Rakesh Kudurumalla <rkudurumalla@marvell.com>
---
 drivers/common/cnxk/roc_nix_fc.c   | 47 +++++++-----------------------
 drivers/common/cnxk/roc_npa.c      | 16 +++++++++-
 drivers/common/cnxk/roc_npa_priv.h |  6 ++++
 3 files changed, 32 insertions(+), 37 deletions(-)

diff --git a/drivers/common/cnxk/roc_nix_fc.c b/drivers/common/cnxk/roc_nix_fc.c
index 1f5ef960dad46..355d49c91b9ec 100644
--- a/drivers/common/cnxk/roc_nix_fc.c
+++ b/drivers/common/cnxk/roc_nix_fc.c
@@ -285,15 +285,11 @@ nix_fc_rq_config_set(struct roc_nix *roc_nix, struct roc_nix_fc_cfg *fc_cfg)
 	struct roc_nix_fc_cfg tmp;
 	uint64_t pool_drop_pct;
 	struct roc_nix_rq *rq;
-	int sso_ena = 0, rc;
+	int rc;
 
 	rq = nix->rqs[fc_cfg->rq_cfg.rq];
-	/* Check whether RQ is connected to SSO or not */
-	sso_ena = roc_nix_rq_is_sso_enable(roc_nix, fc_cfg->rq_cfg.rq);
-	if (sso_ena < 0)
-		return -EINVAL;
 
-	if (sso_ena) {
+	if (rq->sso_ena) {
 		pool_drop_pct = fc_cfg->rq_cfg.pool_drop_pct;
 		/* Use default value for zero pct */
 		if (fc_cfg->rq_cfg.enable && !pool_drop_pct)
@@ -486,12 +482,10 @@ roc_nix_fc_npa_bp_cfg(struct roc_nix *roc_nix, uint64_t pool_id, uint8_t ena, ui
 	uint32_t aura_id = roc_npa_aura_handle_to_aura(pool_id);
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
 	struct npa_lf *lf = idev_npa_obj_get();
-	struct npa_aq_enq_req *req;
-	struct npa_aq_enq_rsp *rsp;
+	struct npa_aura_attr *aura_attr = &lf->aura_attr[aura_id];
 	uint8_t bp_thresh, bp_intf;
-	struct mbox *mbox;
 	uint16_t bpid;
-	int rc, i;
+	int i;
 
 	if (roc_nix_is_sdp(roc_nix))
 		return;
@@ -499,30 +493,12 @@ roc_nix_fc_npa_bp_cfg(struct roc_nix *roc_nix, uint64_t pool_id, uint8_t ena, ui
 	if (!lf)
 		return;
 
-	mbox = lf->mbox;
-	req = mbox_alloc_msg_npa_aq_enq(mbox_get(mbox));
-	if (req == NULL) {
-		mbox_put(mbox);
-		return;
-	}
-
-	req->aura_id = aura_id;
-	req->ctype = NPA_AQ_CTYPE_AURA;
-	req->op = NPA_AQ_INSTOP_READ;
-
-	rc = mbox_process_msg(mbox, (void *)&rsp);
-	mbox_put(mbox);
-	if (rc) {
-		plt_nix_dbg("Failed to read context of aura 0x%" PRIx64, pool_id);
-		return;
-	}
-
 	bp_intf = 1 << nix->is_nix1;
-	bp_thresh = NIX_RQ_AURA_THRESH(drop_percent, rsp->aura.limit >> rsp->aura.shift);
+	bp_thresh = NIX_RQ_AURA_THRESH(drop_percent, aura_attr->limit >> aura_attr->shift);
 
-	bpid = (rsp->aura.bp_ena & 0x1) ? rsp->aura.nix0_bpid : rsp->aura.nix1_bpid;
+	bpid = (aura_attr->bp_ena & 0x1) ? aura_attr->nix0_bpid : aura_attr->nix1_bpid;
 	/* BP is already enabled. */
-	if (rsp->aura.bp_ena && ena) {
+	if (aura_attr->bp_ena && ena) {
 		/* Disable BP if BPIDs don't match and couldn't add new BPID. */
 		if (bpid != nix->bpid[tc]) {
 			uint16_t bpid_new = NIX_BPID_INVALID;
@@ -537,7 +513,7 @@ roc_nix_fc_npa_bp_cfg(struct roc_nix *roc_nix, uint64_t pool_id, uint8_t ena, ui
 					plt_err("Enabling backpressue failed on aura 0x%" PRIx64,
 						pool_id);
 			} else {
-				lf->aura_attr[aura_id].ref_count++;
+				aura_attr->ref_count++;
 				plt_info("Ignoring port=%u tc=%u config on shared aura 0x%" PRIx64,
 					 roc_nix->port_id, tc, pool_id);
 			}
@@ -547,14 +523,14 @@ roc_nix_fc_npa_bp_cfg(struct roc_nix *roc_nix, uint64_t pool_id, uint8_t ena, ui
 	}
 
 	/* BP was previously enabled but now disabled skip. */
-	if (rsp->aura.bp && ena)
+	if (aura_attr->bp && ena)
 		return;
 
 	if (ena) {
 		if (roc_npa_aura_bp_configure(pool_id, nix->bpid[tc], bp_intf, bp_thresh, true))
 			plt_err("Enabling backpressue failed on aura 0x%" PRIx64, pool_id);
 		else
-			lf->aura_attr[aura_id].ref_count++;
+			aura_attr->ref_count++;
 	} else {
 		bool found = !!force;
 
@@ -564,8 +540,7 @@ roc_nix_fc_npa_bp_cfg(struct roc_nix *roc_nix, uint64_t pool_id, uint8_t ena, ui
 				found = true;
 		if (!found)
 			return;
-		else if ((lf->aura_attr[aura_id].ref_count > 0) &&
-			 --lf->aura_attr[aura_id].ref_count)
+		else if ((aura_attr->ref_count > 0) && --(aura_attr->ref_count))
 			return;
 
 		if (roc_npa_aura_bp_configure(pool_id, 0, 0, 0, false))
diff --git a/drivers/common/cnxk/roc_npa.c b/drivers/common/cnxk/roc_npa.c
index 3f436221a88f2..dd2ec21eed871 100644
--- a/drivers/common/cnxk/roc_npa.c
+++ b/drivers/common/cnxk/roc_npa.c
@@ -534,6 +534,8 @@ npa_aura_pool_pair_alloc(struct npa_lf *lf, const uint32_t block_size,
 	if (rc)
 		goto stack_mem_free;
 
+	lf->aura_attr[aura_id].shift = aura->shift;
+	lf->aura_attr[aura_id].limit = aura->limit;
 	*aura_handle = roc_npa_aura_handle_gen(aura_id, lf->base);
 	/* Update aura count */
 	roc_npa_aura_op_cnt_set(*aura_handle, 0, block_count);
@@ -656,6 +658,8 @@ npa_aura_alloc(struct npa_lf *lf, const uint32_t block_count, int pool_id,
 	if (rc)
 		return rc;
 
+	lf->aura_attr[aura_id].shift = aura->shift;
+	lf->aura_attr[aura_id].limit = aura->limit;
 	*aura_handle = roc_npa_aura_handle_gen(aura_id, lf->base);
 
 	return 0;
@@ -734,6 +738,9 @@ roc_npa_aura_limit_modify(uint64_t aura_handle, uint16_t aura_limit)
 	aura_req->aura.limit = aura_limit;
 	aura_req->aura_mask.limit = ~(aura_req->aura_mask.limit);
 	rc = mbox_process(mbox);
+	if (rc)
+		goto exit;
+	lf->aura_attr[aura_req->aura_id].limit = aura_req->aura.limit;
 exit:
 	mbox_put(mbox);
 	return rc;
@@ -930,7 +937,14 @@ roc_npa_aura_bp_configure(uint64_t aura_handle, uint16_t bpid, uint8_t bp_intf,
 	req->aura.bp_ena = bp_intf;
 	req->aura_mask.bp_ena = ~(req->aura_mask.bp_ena);
 
-	mbox_process(mbox);
+	rc = mbox_process(mbox);
+	if (rc)
+		goto fail;
+
+	lf->aura_attr[aura_id].nix0_bpid = req->aura.nix0_bpid;
+	lf->aura_attr[aura_id].nix1_bpid = req->aura.nix1_bpid;
+	lf->aura_attr[aura_id].bp_ena = req->aura.bp_ena;
+	lf->aura_attr[aura_id].bp = req->aura.bp;
 fail:
 	mbox_put(mbox);
 	return rc;
diff --git a/drivers/common/cnxk/roc_npa_priv.h b/drivers/common/cnxk/roc_npa_priv.h
index 704d93d5dce78..060df9ab04932 100644
--- a/drivers/common/cnxk/roc_npa_priv.h
+++ b/drivers/common/cnxk/roc_npa_priv.h
@@ -50,6 +50,12 @@ struct npa_aura_lim {
 struct npa_aura_attr {
 	int buf_type[ROC_NPA_BUF_TYPE_END];
 	uint16_t ref_count;
+	uint64_t nix0_bpid;
+	uint64_t nix1_bpid;
+	uint64_t shift;
+	uint64_t limit;
+	uint8_t bp_ena;
+	uint8_t bp;
 };
 
 struct dev;
-- 
2.25.1

