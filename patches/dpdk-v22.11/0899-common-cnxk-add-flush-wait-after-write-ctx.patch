From 38f1a770a29ce2d4b4d8c49fbd48d44d59f3f7c7 Mon Sep 17 00:00:00 2001
From: Nithin Dabilpuram <ndabilpuram@marvell.com>
Date: Wed, 12 Jun 2024 13:03:48 +0530
Subject: [PATCH 899/955] common/cnxk: add flush wait after write ctx

Also fix the CPT HW word size for outbound SA.

Change-Id: I75a91d6d6fb5aa766e708cdfe8208b16f0a5de16
Signed-off-by: Nithin Dabilpuram <ndabilpuram@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/129460
Base-Builds: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Reviewed-by: Jerin Jacob <jerinj@marvell.com>
---
 drivers/common/cnxk/roc_ie_ot.c   | 1 +
 drivers/common/cnxk/roc_nix_inl.c | 8 ++++++++
 2 files changed, 9 insertions(+)

diff --git a/drivers/common/cnxk/roc_ie_ot.c b/drivers/common/cnxk/roc_ie_ot.c
index 465b2bc1fb952..1b436dba7266e 100644
--- a/drivers/common/cnxk/roc_ie_ot.c
+++ b/drivers/common/cnxk/roc_ie_ot.c
@@ -38,5 +38,6 @@ roc_ot_ipsec_outb_sa_init(struct roc_ot_ipsec_outb_sa *sa)
 	offset = offsetof(struct roc_ot_ipsec_outb_sa, ctx);
 	sa->w0.s.ctx_push_size = (offset / ROC_CTX_UNIT_8B) + 1;
 	sa->w0.s.ctx_size = ROC_IE_OT_CTX_ILEN;
+	sa->w0.s.ctx_hdr_size = ROC_IE_OT_SA_CTX_HDR_SIZE;
 	sa->w0.s.aop_valid = 1;
 }
diff --git a/drivers/common/cnxk/roc_nix_inl.c b/drivers/common/cnxk/roc_nix_inl.c
index a984ac56d9eb0..d0328921a72d2 100644
--- a/drivers/common/cnxk/roc_nix_inl.c
+++ b/drivers/common/cnxk/roc_nix_inl.c
@@ -1748,6 +1748,7 @@ roc_nix_inl_ctx_write(struct roc_nix *roc_nix, void *sa_dptr, void *sa_cptr,
 	struct nix_inl_dev *inl_dev = NULL;
 	struct roc_cpt_lf *outb_lf = NULL;
 	union cpt_lf_ctx_flush flush;
+	union cpt_lf_ctx_err err;
 	bool get_inl_lf = true;
 	uintptr_t rbase;
 	struct nix *nix;
@@ -1789,6 +1790,13 @@ roc_nix_inl_ctx_write(struct roc_nix *roc_nix, void *sa_dptr, void *sa_cptr,
 		flush.s.cptr = ((uintptr_t)sa_cptr) >> 7;
 		plt_write64(flush.u, rbase + CPT_LF_CTX_FLUSH);
 
+		plt_atomic_thread_fence(__ATOMIC_ACQ_REL);
+
+		/* Read a CSR to ensure that the FLUSH operation is complete */
+		err.u = plt_read64(rbase + CPT_LF_CTX_ERR);
+
+		if (err.s.flush_st_flt)
+			plt_warn("CTX flush could not complete");
 		return 0;
 	}
 	plt_nix_dbg("Could not get CPT LF for CTX write");
-- 
2.25.1

