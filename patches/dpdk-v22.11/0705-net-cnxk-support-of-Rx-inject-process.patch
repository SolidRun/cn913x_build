From 1ba9f33e18e58fb31f6d88c5e31c62f29434b717 Mon Sep 17 00:00:00 2001
From: Rahul Bhansali <rbhansali@marvell.com>
Date: Tue, 17 Oct 2023 14:42:03 +0530
Subject: [PATCH 705/955] net/cnxk: support of Rx inject process

Crypto lookaside Rx Inject case will be identified if CPT
parse header cookie contains 0xFFFFFFFF. This will be handled
under reassembly flag and inner mbuf data offset will not be
updated.

Signed-off-by: Rahul Bhansali <rbhansali@marvell.com>
Change-Id: I3a2c0faf7012be5976a84190e6e7d03514ed1b7e
---
 drivers/net/cnxk/cn10k_rx.h | 41 +++++++++++++++++++++++++++++--------
 1 file changed, 32 insertions(+), 9 deletions(-)

diff --git a/drivers/net/cnxk/cn10k_rx.h b/drivers/net/cnxk/cn10k_rx.h
index 7bb4c86d75c53..e3301da8b08a3 100644
--- a/drivers/net/cnxk/cn10k_rx.h
+++ b/drivers/net/cnxk/cn10k_rx.h
@@ -487,8 +487,14 @@ nix_sec_meta_to_mbuf_sc(uint64_t cq_w1, uint64_t cq_w5, const uint64_t sa_base,
 	inb_sa = roc_nix_inl_ot_ipsec_inb_sa(sa_base, sa_idx);
 	inb_priv = roc_nix_inl_ot_ipsec_inb_sa_sw_rsvd(inb_sa);
 
-	/* Update dynamic field with userdata */
-	*rte_security_dynfield(inner) = (uint64_t)inb_priv->userdata;
+	if (flags & NIX_RX_REAS_F && sa_idx == 0xFFFFFFFF)
+		*(uint64_t *)(&inner->rearm_data) = (mbuf_init & ~(BIT_ULL(16) - 1)) |
+						    inner->data_off;
+	else {
+		/* Update dynamic field with userdata */
+		*rte_security_dynfield(inner) = (uint64_t)inb_priv->userdata;
+		*(uint64_t *)(&inner->rearm_data) = mbuf_init;
+	}
 
 	/* Get ucc from cpt parse header */
 	ucc = hdr->w3.hw_ccode;
@@ -502,7 +508,6 @@ nix_sec_meta_to_mbuf_sc(uint64_t cq_w1, uint64_t cq_w5, const uint64_t sa_base,
 
 	inner->pkt_len = len;
 	inner->data_len = len;
-	*(uint64_t *)(&inner->rearm_data) = mbuf_init;
 
 	inner->ol_flags = ((CPT_COMP_HWGOOD_MASK & (1U << ucc)) ?
 			   RTE_MBUF_F_RX_SEC_OFFLOAD :
@@ -567,12 +572,17 @@ nix_sec_meta_to_mbuf(uint64_t cq_w1, uint64_t cq_w5, uintptr_t inb_sa,
 	*ol_flags &= ~(RTE_MBUF_F_RX_L4_CKSUM_MASK |
 		       RTE_MBUF_F_RX_IP_CKSUM_MASK);
 
-	/* Get SPI from CPT_PARSE_S's cookie(already swapped) */
-	inb_priv = roc_nix_inl_ot_ipsec_inb_sa_sw_rsvd((void *)inb_sa);
 
-	/* Update dynamic field with userdata */
-	*rte_security_dynfield(inner) = (uint64_t)inb_priv->userdata;
+	if (flags & NIX_RX_REAS_F && !inb_sa ) {
+		/* Clear and update original lower 16 bit of data offset */
+		*rearm = (*rearm & ~(BIT_ULL(16) - 1)) | inner->data_off;
+	} else {
+		/* Get SPI from CPT_PARSE_S's cookie(already swapped) */
+		inb_priv = roc_nix_inl_ot_ipsec_inb_sa_sw_rsvd((void *)inb_sa);
+		/* Update dynamic field with userdata */
+		*rte_security_dynfield(inner) = (uint64_t)inb_priv->userdata;
 
+	}
 	/* Mark inner mbuf as get */
 	if (!(flags & NIX_RX_REAS_F) ||
 	    hdr->w0.pkt_fmt != ROC_IE_OT_SA_PKT_FMT_FULL)
@@ -604,8 +614,10 @@ nix_sec_meta_to_mbuf(uint64_t cq_w1, uint64_t cq_w5, uintptr_t inb_sa,
 			*rearm = vsetq_lane_u64(mbuf_init, *rearm, 0);
 		} else {
 			/* Reassembly failure */
-			nix_sec_attach_frags(hdr, inner, inb_priv, mbuf_init);
-			*ol_flags |= inner->ol_flags;
+			if (inb_sa) {
+				nix_sec_attach_frags(hdr, inner, inb_priv, mbuf_init);
+				*ol_flags |= inner->ol_flags;
+			}
 		}
 	} else if (flags & NIX_RX_REAS_F) {
 		/* Without fragmentation but may have to handle OOP session */
@@ -1558,6 +1570,7 @@ cn10k_nix_recv_pkts_vector(void *args, struct rte_mbuf **mbufs, uint16_t pkts,
 			uint64x2_t inner0, inner1, inner2, inner3;
 			uint64x2_t wqe01, wqe23, sa01, sa23;
 			uint16x4_t lens, l2lens, ltypes;
+			uint64x2_t mask01, mask23;
 			uint8x8_t ucc;
 
 			cpth0 = (uintptr_t)mbuf0 + d_off;
@@ -1587,6 +1600,11 @@ cn10k_nix_recv_pkts_vector(void *args, struct rte_mbuf **mbufs, uint16_t pkts,
 
 			sa01 = vshrq_n_u64(sa01, 32);
 			sa23 = vshrq_n_u64(sa23, 32);
+
+			/* Crypto Look-aside Rx Inject case */
+			mask01 = vceqq_u64(sa01, vdupq_n_u64(0xFFFFFFFF));
+			mask23 = vceqq_u64(sa23, vdupq_n_u64(0xFFFFFFFF));
+
 			sa01 = vshlq_n_u64(sa01,
 					   ROC_NIX_INL_OT_IPSEC_INB_SA_SZ_LOG2);
 			sa23 = vshlq_n_u64(sa23,
@@ -1594,6 +1612,11 @@ cn10k_nix_recv_pkts_vector(void *args, struct rte_mbuf **mbufs, uint16_t pkts,
 			sa01 = vaddq_u64(sa01, vdupq_n_u64(sa_base));
 			sa23 = vaddq_u64(sa23, vdupq_n_u64(sa_base));
 
+			if (flags & NIX_RX_REAS_F) {
+				sa01 = vbicq_u64(sa01, mask01);
+				sa23 = vbicq_u64(sa23, mask23);
+			}
+
 			const uint8x16x2_t tbl = {{
 				{
 					/* ROC_IE_OT_UCC_SUCCESS_PKT_IP_BADCSUM */
-- 
2.25.1

