From ab4fed830e5eade5ed754e920747859b81441e4e Mon Sep 17 00:00:00 2001
From: Rakesh Kudurumalla <rkudurumalla@marvell.com>
Date: Fri, 11 Nov 2022 13:45:03 +0530
Subject: [PATCH 057/955] common/cnxk: add mbox locking

this patch adds mbox locking using spinlock
to have different subsystems sharing same mbox

ci: skip_checkformat

Signed-off-by: Rakesh Kudurumalla <rkudurumalla@marvell.com>
Change-Id: I45cf3629bf3d67371a7d5965e66e8068a5ea09d3
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/91385
Reviewed-by: Jerin Jacob Kollanukkaran <jerinj@marvell.com>
Tested-by: Jerin Jacob Kollanukkaran <jerinj@marvell.com>
---
 drivers/common/cnxk/cnxk_telemetry_npa.c |  24 +-
 drivers/common/cnxk/roc_cpt.c            | 195 +++++++++++-----
 drivers/common/cnxk/roc_cpt_debug.c      |  40 +++-
 drivers/common/cnxk/roc_dev.c            |  19 +-
 drivers/common/cnxk/roc_mbox.c           |  11 +-
 drivers/common/cnxk/roc_mbox_priv.h      |  15 ++
 drivers/common/cnxk/roc_nix.c            |  78 +++++--
 drivers/common/cnxk/roc_nix_bpf.c        | 278 +++++++++++++++--------
 drivers/common/cnxk/roc_nix_debug.c      |  40 ++--
 drivers/common/cnxk/roc_nix_fc.c         | 137 ++++++-----
 drivers/common/cnxk/roc_nix_inl.c        |  16 +-
 drivers/common/cnxk/roc_nix_inl_dev.c    |  83 +++++--
 drivers/common/cnxk/roc_nix_mac.c        | 202 ++++++++++------
 drivers/common/cnxk/roc_nix_mcast.c      |  57 +++--
 drivers/common/cnxk/roc_nix_npc.c        |  69 ++++--
 drivers/common/cnxk/roc_nix_ops.c        | 185 +++++++++------
 drivers/common/cnxk/roc_nix_ptp.c        |  77 ++++---
 drivers/common/cnxk/roc_nix_queue.c      | 237 +++++++++++++------
 drivers/common/cnxk/roc_nix_rss.c        |  64 ++++--
 drivers/common/cnxk/roc_nix_stats.c      |  77 +++++--
 drivers/common/cnxk/roc_nix_tm.c         | 108 ++++++---
 drivers/common/cnxk/roc_nix_tm_mark.c    |  26 ++-
 drivers/common/cnxk/roc_nix_tm_ops.c     | 107 ++++++---
 drivers/common/cnxk/roc_nix_tm_utils.c   |  13 +-
 drivers/common/cnxk/roc_nix_vlan.c       | 103 ++++++---
 drivers/common/cnxk/roc_npa.c            | 185 ++++++++++-----
 drivers/common/cnxk/roc_npa_debug.c      |  28 ++-
 drivers/common/cnxk/roc_npc.c            |  66 ++++--
 drivers/common/cnxk/roc_npc_mcam.c       | 116 ++++++----
 drivers/common/cnxk/roc_npc_mcam_dump.c  |   5 +-
 drivers/common/cnxk/roc_npc_utils.c      |  46 ++--
 drivers/common/cnxk/roc_sso.c            | 186 ++++++++++-----
 drivers/common/cnxk/roc_tim.c            |  82 ++++---
 33 files changed, 1993 insertions(+), 982 deletions(-)

diff --git a/drivers/common/cnxk/cnxk_telemetry_npa.c b/drivers/common/cnxk/cnxk_telemetry_npa.c
index b6ae108b10b83..4287eaf968cdf 100644
--- a/drivers/common/cnxk/cnxk_telemetry_npa.c
+++ b/drivers/common/cnxk/cnxk_telemetry_npa.c
@@ -62,10 +62,11 @@ cnxk_tel_npa_aura(int aura_id, struct plt_tel_data *d)
 	if (plt_bitmap_get(lf->npa_bmp, aura_id))
 		return -1;
 
-	req = mbox_alloc_msg_npa_aq_enq(lf->mbox);
+	req = mbox_alloc_msg_npa_aq_enq(mbox_get(lf->mbox));
 	if (!req) {
 		plt_err("Failed to alloc aq enq for npa");
-		return -1;
+		rc = -1;
+		goto exit;
 	}
 
 	req->aura_id = aura_id;
@@ -75,7 +76,7 @@ cnxk_tel_npa_aura(int aura_id, struct plt_tel_data *d)
 	rc = mbox_process_msg(lf->mbox, (void *)&rsp);
 	if (rc) {
 		plt_err("Failed to get pool(%d) context", aura_id);
-		return rc;
+		goto exit;
 	}
 
 	aura = &rsp->aura;
@@ -110,7 +111,10 @@ cnxk_tel_npa_aura(int aura_id, struct plt_tel_data *d)
 	CNXK_TEL_DICT_INT(d, aura, err_qint_idx, w5_);
 	CNXK_TEL_DICT_U64(d, aura, thresh, w6_);
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(lf->mbox);
+	return rc;
 }
 
 static int
@@ -129,10 +133,11 @@ cnxk_tel_npa_pool(int pool_id, struct plt_tel_data *d)
 	if (plt_bitmap_get(lf->npa_bmp, pool_id))
 		return -1;
 
-	req = mbox_alloc_msg_npa_aq_enq(lf->mbox);
+	req = mbox_alloc_msg_npa_aq_enq(mbox_get(lf->mbox));
 	if (!req) {
 		plt_err("Failed to alloc aq enq for npa");
-		return -1;
+		rc = -1;
+		goto exit;
 	}
 
 	req->aura_id = pool_id;
@@ -142,7 +147,7 @@ cnxk_tel_npa_pool(int pool_id, struct plt_tel_data *d)
 	rc = mbox_process_msg(lf->mbox, (void *)&rsp);
 	if (rc) {
 		plt_err("Failed to get pool(%d) context", pool_id);
-		return rc;
+		goto exit;
 	}
 
 	pool = &rsp->pool;
@@ -176,7 +181,10 @@ cnxk_tel_npa_pool(int pool_id, struct plt_tel_data *d)
 	CNXK_TEL_DICT_INT(d, pool, thresh_qint_idx, w8_);
 	CNXK_TEL_DICT_INT(d, pool, err_qint_idx, w8_);
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(lf->mbox);
+	return rc;
 }
 
 static int
diff --git a/drivers/common/cnxk/roc_cpt.c b/drivers/common/cnxk/roc_cpt.c
index ea9712904b490..8569564536f1a 100644
--- a/drivers/common/cnxk/roc_cpt.c
+++ b/drivers/common/cnxk/roc_cpt.c
@@ -225,11 +225,14 @@ cpt_lf_outb_cfg(struct dev *dev, uint16_t sso_pf_func, uint16_t nix_pf_func,
 		uint8_t lf_id, bool ena)
 {
 	struct cpt_inline_ipsec_cfg_msg *req;
-	struct mbox *mbox = dev->mbox;
+	struct mbox *mbox = mbox_get(dev->mbox);
+	int rc;
 
 	req = mbox_alloc_msg_cpt_inline_ipsec_cfg(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	req->dir = CPT_INLINE_OUTBOUND;
 	req->slot = lf_id;
@@ -241,7 +244,10 @@ cpt_lf_outb_cfg(struct dev *dev, uint16_t sso_pf_func, uint16_t nix_pf_func,
 		req->enable = 0;
 	}
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -266,13 +272,20 @@ roc_cpt_inline_ipsec_inb_cfg_read(struct roc_cpt *roc_cpt,
 {
 	struct cpt *cpt = roc_cpt_to_cpt_priv(roc_cpt);
 	struct dev *dev = &cpt->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct msg_req *req;
+	int rc;
 
-	req = mbox_alloc_msg_nix_read_inline_ipsec_cfg(dev->mbox);
-	if (req == NULL)
-		return -EIO;
+	req = mbox_alloc_msg_nix_read_inline_ipsec_cfg(mbox);
+	if (req == NULL) {
+		rc = -EIO;
+		goto exit;
+	}
 
-	return mbox_process_msg(dev->mbox, (void *)&inb_cfg);
+	rc = mbox_process_msg(mbox, (void *)&inb_cfg);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -282,19 +295,25 @@ roc_cpt_inline_ipsec_inb_cfg(struct roc_cpt *roc_cpt, uint16_t param1,
 	struct cpt *cpt = roc_cpt_to_cpt_priv(roc_cpt);
 	struct cpt_rx_inline_lf_cfg_msg *req;
 	struct mbox *mbox;
+	int rc;
 
-	mbox = cpt->dev.mbox;
+	mbox = mbox_get(cpt->dev.mbox);
 
 	req = mbox_alloc_msg_cpt_rx_inline_lf_cfg(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	req->sso_pf_func = idev_sso_pffunc_get();
 	req->param1 = param1;
 	req->param2 = param2;
 	req->opcode = opcode;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -303,10 +322,14 @@ roc_cpt_rxc_time_cfg(struct roc_cpt *roc_cpt, struct roc_cpt_rxc_time_cfg *cfg)
 	struct cpt *cpt = roc_cpt_to_cpt_priv(roc_cpt);
 	struct cpt_rxc_time_cfg_req *req;
 	struct dev *dev = &cpt->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
+	int rc;
 
-	req = mbox_alloc_msg_cpt_rxc_time_cfg(dev->mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	req = mbox_alloc_msg_cpt_rxc_time_cfg(mbox);
+	if (req == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	req->blkaddr = 0;
 
@@ -321,18 +344,22 @@ roc_cpt_rxc_time_cfg(struct roc_cpt *roc_cpt, struct roc_cpt_rxc_time_cfg *cfg)
 	req->active_limit = cfg->active_limit;
 	req->active_thres = cfg->active_thres;
 
-	return mbox_process(dev->mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 cpt_get_msix_offset(struct dev *dev, struct msix_offset_rsp **msix_rsp)
 {
-	struct mbox *mbox = dev->mbox;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int rc;
 
 	/* Get MSIX vector offsets */
 	mbox_alloc_msg_msix_offset(mbox);
 	rc = mbox_process_msg(mbox, (void *)msix_rsp);
+	mbox_put(mbox);
 
 	return rc;
 }
@@ -340,55 +367,74 @@ cpt_get_msix_offset(struct dev *dev, struct msix_offset_rsp **msix_rsp)
 int
 cpt_lfs_attach(struct dev *dev, uint8_t blkaddr, bool modify, uint16_t nb_lf)
 {
-	struct mbox *mbox = dev->mbox;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct rsrc_attach_req *req;
+	int rc;
 
-	if (blkaddr != RVU_BLOCK_ADDR_CPT0 && blkaddr != RVU_BLOCK_ADDR_CPT1)
-		return -EINVAL;
+	if (blkaddr != RVU_BLOCK_ADDR_CPT0 && blkaddr != RVU_BLOCK_ADDR_CPT1) {
+		rc = -EINVAL;
+		goto exit;
+	}
 
 	/* Attach CPT(lf) */
 	req = mbox_alloc_msg_attach_resources(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	req->cptlfs = nb_lf;
 	req->modify = modify;
 	req->cpt_blkaddr = blkaddr;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 cpt_lfs_detach(struct dev *dev)
 {
-	struct mbox *mbox = dev->mbox;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct rsrc_detach_req *req;
+	int rc;
 
 	req = mbox_alloc_msg_detach_resources(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc =  -ENOSPC;
+		goto exit;
+	}
 
 	req->cptlfs = 1;
 	req->partial = 1;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
 cpt_available_lfs_get(struct dev *dev, uint16_t *nb_lf)
 {
-	struct mbox *mbox = dev->mbox;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct free_rsrcs_rsp *rsp;
 	int rc;
 
 	mbox_alloc_msg_free_rsrc_cnt(mbox);
 
 	rc = mbox_process_msg(mbox, (void *)&rsp);
-	if (rc)
-		return -EIO;
+	if (rc) {
+		rc = -EIO;
+		goto exit;
+	}
 
 	*nb_lf = PLT_MAX((uint16_t)rsp->cpt, (uint16_t)rsp->cpt1);
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -396,14 +442,19 @@ cpt_lfs_alloc(struct dev *dev, uint8_t eng_grpmsk, uint8_t blkaddr,
 	      bool inl_dev_sso)
 {
 	struct cpt_lf_alloc_req_msg *req;
-	struct mbox *mbox = dev->mbox;
+	struct mbox *mbox = mbox_get(dev->mbox);
+	int rc;
 
-	if (blkaddr != RVU_BLOCK_ADDR_CPT0 && blkaddr != RVU_BLOCK_ADDR_CPT1)
-		return -EINVAL;
+	if (blkaddr != RVU_BLOCK_ADDR_CPT0 && blkaddr != RVU_BLOCK_ADDR_CPT1) {
+		rc = -EINVAL;
+		goto exit;
+	}
 
 	req = mbox_alloc_msg_cpt_lf_alloc(mbox);
-	if (!req)
-		return -ENOSPC;
+	if (!req) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	req->nix_pf_func = 0;
 	if (inl_dev_sso && nix_inl_dev_pffunc_get())
@@ -413,34 +464,49 @@ cpt_lfs_alloc(struct dev *dev, uint8_t eng_grpmsk, uint8_t blkaddr,
 	req->eng_grpmsk = eng_grpmsk;
 	req->blkaddr = blkaddr;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 cpt_lfs_free(struct dev *dev)
 {
-	mbox_alloc_msg_cpt_lf_free(dev->mbox);
+	struct mbox *mbox = mbox_get(dev->mbox);
+	int rc;
 
-	return mbox_process(dev->mbox);
+	mbox_alloc_msg_cpt_lf_free(mbox);
+
+	rc = mbox_process(mbox);
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
 cpt_hardware_caps_get(struct dev *dev, struct roc_cpt *roc_cpt)
 {
 	struct cpt_caps_rsp_msg *rsp;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int ret;
 
-	mbox_alloc_msg_cpt_caps_get(dev->mbox);
+	mbox_alloc_msg_cpt_caps_get(mbox);
 
-	ret = mbox_process_msg(dev->mbox, (void *)&rsp);
-	if (ret)
-		return -EIO;
+	ret = mbox_process_msg(mbox, (void *)&rsp);
+	if (ret) {
+		ret = -EIO;
+		goto exit;
+	}
 
 	roc_cpt->cpt_revision = rsp->cpt_revision;
 	mbox_memcpy(roc_cpt->hw_caps, rsp->eng_caps,
 		    sizeof(union cpt_eng_caps) * CPT_MAX_ENG_TYPES);
 
-	return 0;
+	ret = 0;
+
+exit:
+	mbox_put(mbox);
+	return ret;
 }
 
 static uint32_t
@@ -733,14 +799,21 @@ cpt_lf_reset(struct roc_cpt_lf *lf)
 {
 	struct cpt_lf_rst_req *req;
 	struct dev *dev = lf->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
+	int rc;
 
-	req = mbox_alloc_msg_cpt_lf_reset(dev->mbox);
-	if (req == NULL)
-		return -EIO;
+	req = mbox_alloc_msg_cpt_lf_reset(mbox);
+	if (req == NULL) {
+		rc = -EIO;
+		goto exit;
+	}
 
 	req->slot = lf->lf_id;
 
-	return mbox_process(dev->mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static void
@@ -881,11 +954,14 @@ roc_cpt_eng_grp_add(struct roc_cpt *roc_cpt, enum cpt_eng_type eng_type)
 	struct dev *dev = &cpt->dev;
 	struct cpt_eng_grp_req *req;
 	struct cpt_eng_grp_rsp *rsp;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int ret;
 
-	req = mbox_alloc_msg_cpt_eng_grp_get(dev->mbox);
-	if (req == NULL)
-		return -EIO;
+	req = mbox_alloc_msg_cpt_eng_grp_get(mbox);
+	if (req == NULL) {
+		ret = -EIO;
+		goto exit;
+	}
 
 	switch (eng_type) {
 	case CPT_ENG_TYPE_AE:
@@ -893,22 +969,29 @@ roc_cpt_eng_grp_add(struct roc_cpt *roc_cpt, enum cpt_eng_type eng_type)
 	case CPT_ENG_TYPE_IE:
 		break;
 	default:
-		return -EINVAL;
+		ret = -EINVAL;
+		goto exit;
 	}
 
 	req->eng_type = eng_type;
 	ret = mbox_process_msg(dev->mbox, (void *)&rsp);
-	if (ret)
-		return -EIO;
+	if (ret) {
+		ret = -EIO;
+		goto exit;
+	}
 
 	if (rsp->eng_grp_num > 8) {
 		plt_err("Invalid CPT engine group");
-		return -ENOTSUP;
+		ret = -ENOTSUP;
+		goto exit;
 	}
 
 	roc_cpt->eng_grp[eng_type] = rsp->eng_grp_num;
 
-	return rsp->eng_grp_num;
+	ret = rsp->eng_grp_num;
+exit:
+	mbox_put(mbox);
+	return ret;
 }
 
 void
diff --git a/drivers/common/cnxk/roc_cpt_debug.c b/drivers/common/cnxk/roc_cpt_debug.c
index 5602e536af63f..dce3638507a19 100644
--- a/drivers/common/cnxk/roc_cpt_debug.c
+++ b/drivers/common/cnxk/roc_cpt_debug.c
@@ -71,11 +71,14 @@ cpt_af_reg_read(struct roc_cpt *roc_cpt, uint64_t reg, uint64_t *val)
 	struct cpt *cpt = roc_cpt_to_cpt_priv(roc_cpt);
 	struct cpt_rd_wr_reg_msg *msg;
 	struct dev *dev = &cpt->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int ret;
 
-	msg = mbox_alloc_msg_cpt_rd_wr_register(dev->mbox);
-	if (msg == NULL)
-		return -EIO;
+	msg = mbox_alloc_msg_cpt_rd_wr_register(mbox);
+	if (msg == NULL) {
+		ret = -EIO;
+		goto exit;
+	}
 
 	msg->hdr.pcifunc = dev->pf_func;
 
@@ -84,12 +87,17 @@ cpt_af_reg_read(struct roc_cpt *roc_cpt, uint64_t reg, uint64_t *val)
 	msg->ret_val = val;
 
 	ret = mbox_process_msg(dev->mbox, (void *)&msg);
-	if (ret)
-		return -EIO;
+	if (ret) {
+		ret =  -EIO;
+		goto exit;
+	}
 
 	*val = msg->val;
 
-	return 0;
+	ret = 0;
+exit:
+	mbox_put(mbox);
+	return ret;
 }
 
 static int
@@ -99,16 +107,21 @@ cpt_sts_print(struct roc_cpt *roc_cpt)
 	struct dev *dev = &cpt->dev;
 	struct cpt_sts_req *req;
 	struct cpt_sts_rsp *rsp;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int ret;
 
-	req = mbox_alloc_msg_cpt_sts_get(dev->mbox);
-	if (req == NULL)
-		return -EIO;
+	req = mbox_alloc_msg_cpt_sts_get(mbox);
+	if (req == NULL) {
+		ret = -EIO;
+		goto exit;
+	}
 
 	req->blkaddr = 0;
 	ret = mbox_process_msg(dev->mbox, (void *)&rsp);
-	if (ret)
-		return -EIO;
+	if (ret) {
+		ret = -EIO;
+		goto exit;
+	}
 
 	plt_print("    %s:\t0x%016" PRIx64, "inst_req_pc", rsp->inst_req_pc);
 	plt_print("    %s:\t0x%016" PRIx64, "inst_lat_pc", rsp->inst_lat_pc);
@@ -161,7 +174,10 @@ cpt_sts_print(struct roc_cpt *roc_cpt)
 	plt_print("    %s:\t\t0x%016" PRIx64, "cptclk_cnt", rsp->cptclk_cnt);
 	plt_print("    %s:\t\t0x%016" PRIx64, "diag", rsp->diag);
 
-	return 0;
+	ret = 0;
+exit:
+	mbox_put(mbox);
+	return ret;
 }
 
 int
diff --git a/drivers/common/cnxk/roc_dev.c b/drivers/common/cnxk/roc_dev.c
index 59128a3552800..32a6d2ca0cc65 100644
--- a/drivers/common/cnxk/roc_dev.c
+++ b/drivers/common/cnxk/roc_dev.c
@@ -135,8 +135,6 @@ af_pf_wait_msg(struct dev *dev, uint16_t vf, int num_msg)
 	/* Enable interrupts */
 	plt_write64(~0ull, dev->bar2 + RVU_PF_INT_ENA_W1S);
 
-	plt_spinlock_lock(&mdev->mbox_lock);
-
 	req_hdr = (struct mbox_hdr *)((uintptr_t)mdev->mbase + mbox->rx_start);
 	if (req_hdr->num_msgs != num_msg)
 		plt_err("Routed messages: %d received: %d", num_msg,
@@ -203,7 +201,6 @@ af_pf_wait_msg(struct dev *dev, uint16_t vf, int num_msg)
 
 		offset = mbox->rx_start + msg->next_msgoff;
 	}
-	plt_spinlock_unlock(&mdev->mbox_lock);
 
 	return req_hdr->num_msgs;
 }
@@ -225,6 +222,7 @@ vf_pf_process_msgs(struct dev *dev, uint16_t vf)
 
 	offset = mbox->rx_start + PLT_ALIGN(sizeof(*req_hdr), MBOX_MSG_ALIGN);
 
+	mbox_get(dev->mbox);
 	for (i = 0; i < req_hdr->num_msgs; i++) {
 		msg = (struct mbox_msghdr *)((uintptr_t)mdev->mbase + offset);
 		size = mbox->rx_start + msg->next_msgoff - offset;
@@ -278,6 +276,7 @@ vf_pf_process_msgs(struct dev *dev, uint16_t vf)
 		af_pf_wait_msg(dev, vf, routed);
 		mbox_reset(dev->mbox, 0);
 	}
+	mbox_put(dev->mbox);
 
 	/* Send mbox responses to VF */
 	if (mdev->num_msgs) {
@@ -1015,10 +1014,13 @@ static int
 dev_setup_shared_lmt_region(struct mbox *mbox, bool valid_iova, uint64_t iova)
 {
 	struct lmtst_tbl_setup_req *req;
+	int rc;
 
-	req = mbox_alloc_msg_lmtst_tbl_setup(mbox);
-	if (!req)
-		return -ENOSPC;
+	req = mbox_alloc_msg_lmtst_tbl_setup(mbox_get(mbox));
+	if (!req) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	/* This pcifunc is defined with primary pcifunc whose LMT address
 	 * will be shared. If call contains valid IOVA, following pcifunc
@@ -1028,7 +1030,10 @@ dev_setup_shared_lmt_region(struct mbox *mbox, bool valid_iova, uint64_t iova)
 	req->use_local_lmt_region = valid_iova;
 	req->lmt_iova = iova;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 /* Total no of lines * size of each lmtline */
diff --git a/drivers/common/cnxk/roc_mbox.c b/drivers/common/cnxk/roc_mbox.c
index 6f4ee68c5d235..7dcd188ca7e96 100644
--- a/drivers/common/cnxk/roc_mbox.c
+++ b/drivers/common/cnxk/roc_mbox.c
@@ -50,14 +50,12 @@ mbox_reset(struct mbox *mbox, int devid)
 	struct mbox_hdr *rx_hdr =
 		(struct mbox_hdr *)((uintptr_t)mdev->mbase + mbox->rx_start);
 
-	plt_spinlock_lock(&mdev->mbox_lock);
 	mdev->msg_size = 0;
 	mdev->rsp_size = 0;
 	tx_hdr->msg_size = 0;
 	tx_hdr->num_msgs = 0;
 	rx_hdr->msg_size = 0;
 	rx_hdr->num_msgs = 0;
-	plt_spinlock_unlock(&mdev->mbox_lock);
 }
 
 int
@@ -167,7 +165,6 @@ mbox_alloc_msg_rsp(struct mbox *mbox, int devid, int size, int size_rsp)
 	struct mbox_dev *mdev = &mbox->dev[devid];
 	struct mbox_msghdr *msghdr = NULL;
 
-	plt_spinlock_lock(&mdev->mbox_lock);
 	size = PLT_ALIGN(size, MBOX_MSG_ALIGN);
 	size_rsp = PLT_ALIGN(size_rsp, MBOX_MSG_ALIGN);
 	/* Check if there is space in mailbox */
@@ -191,7 +188,6 @@ mbox_alloc_msg_rsp(struct mbox *mbox, int devid, int size, int size_rsp)
 	mdev->rsp_size += size_rsp;
 	msghdr->next_msgoff = mdev->msg_size + msgs_offset();
 exit:
-	plt_spinlock_unlock(&mdev->mbox_lock);
 
 	return msghdr;
 }
@@ -409,11 +405,14 @@ send_ready_msg(struct mbox *mbox, uint16_t *pcifunc)
 	struct ready_msg_rsp *rsp;
 	int rc;
 
-	mbox_alloc_msg_ready(mbox);
+	mbox_alloc_msg_ready(mbox_get(mbox));
 
 	rc = mbox_process_msg(mbox, (void *)&rsp);
-	if (rc)
+	if (rc) {
+		mbox_put(mbox);
 		return rc;
+	}
+	mbox_put(mbox);
 
 	if (rsp->hdr.ver != MBOX_VERSION) {
 		plt_err("Incompatible MBox versions(AF: 0x%04x Client: 0x%04x)",
diff --git a/drivers/common/cnxk/roc_mbox_priv.h b/drivers/common/cnxk/roc_mbox_priv.h
index 84516fbd5f3ec..4fafca6f72cad 100644
--- a/drivers/common/cnxk/roc_mbox_priv.h
+++ b/drivers/common/cnxk/roc_mbox_priv.h
@@ -151,6 +151,21 @@ mbox_process_msg_tmo(struct mbox *mbox, void **msg, uint32_t tmo)
 	return mbox_get_rsp_tmo(mbox, 0, msg, tmo);
 }
 
+static inline struct mbox *
+mbox_get(struct mbox *mbox)
+{
+	struct mbox_dev *mdev = &mbox->dev[0];
+	plt_spinlock_lock(&mdev->mbox_lock);
+	return mbox;
+}
+
+static inline void
+mbox_put(struct mbox *mbox)
+{
+	struct mbox_dev *mdev = &mbox->dev[0];
+	plt_spinlock_unlock(&mdev->mbox_lock);
+}
+
 int send_ready_msg(struct mbox *mbox, uint16_t *pf_func /* out */);
 int reply_invalid_msg(struct mbox *mbox, int devid, uint16_t pf_func,
 		      uint16_t id);
diff --git a/drivers/common/cnxk/roc_nix.c b/drivers/common/cnxk/roc_nix.c
index 2a320cc29179b..fbf318a77d19f 100644
--- a/drivers/common/cnxk/roc_nix.c
+++ b/drivers/common/cnxk/roc_nix.c
@@ -86,11 +86,14 @@ roc_nix_lf_inl_ipsec_cfg(struct roc_nix *roc_nix, struct roc_nix_ipsec_cfg *cfg,
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
 	struct nix_inline_ipsec_lf_cfg *lf_cfg;
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
+	int rc;
 
 	lf_cfg = mbox_alloc_msg_nix_inline_ipsec_lf_cfg(mbox);
-	if (lf_cfg == NULL)
-		return -ENOSPC;
+	if (lf_cfg == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	if (enb) {
 		lf_cfg->enable = 1;
@@ -105,21 +108,30 @@ roc_nix_lf_inl_ipsec_cfg(struct roc_nix *roc_nix, struct roc_nix_ipsec_cfg *cfg,
 		lf_cfg->enable = 0;
 	}
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_cpt_ctx_cache_sync(struct roc_nix *roc_nix)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	struct msg_req *req;
+	int rc;
 
 	req = mbox_alloc_msg_cpt_ctx_cache_sync(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -147,14 +159,14 @@ roc_nix_lf_alloc(struct roc_nix *roc_nix, uint32_t nb_rxq, uint32_t nb_txq,
 		 uint64_t rx_cfg)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	struct nix_lf_alloc_req *req;
 	struct nix_lf_alloc_rsp *rsp;
 	int rc = -ENOSPC;
 
 	req = mbox_alloc_msg_nix_lf_alloc(mbox);
 	if (req == NULL)
-		return rc;
+		goto fail;
 	req->rq_cnt = nb_rxq;
 	req->sq_cnt = nb_txq;
 	if (roc_nix->tx_compl_ena)
@@ -203,11 +215,14 @@ roc_nix_lf_alloc(struct roc_nix *roc_nix, uint32_t nb_rxq, uint32_t nb_txq,
 	nix->nb_rx_queues = nb_rxq;
 	nix->nb_tx_queues = nb_txq;
 	nix->sqs = plt_zmalloc(sizeof(struct roc_nix_sq *) * nb_txq, 0);
-	if (!nix->sqs)
-		return -ENOMEM;
+	if (!nix->sqs) {
+		rc = -ENOMEM;
+		goto fail;
+	}
 
 	nix_tel_node_add(roc_nix);
 fail:
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -215,7 +230,7 @@ int
 roc_nix_lf_free(struct roc_nix *roc_nix)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	struct nix_lf_free_req *req;
 	struct ndc_sync_op *ndc_req;
 	int rc = -ENOSPC;
@@ -226,7 +241,7 @@ roc_nix_lf_free(struct roc_nix *roc_nix)
 	/* Sync NDC-NIX for LF */
 	ndc_req = mbox_alloc_msg_ndc_sync_op(mbox);
 	if (ndc_req == NULL)
-		return rc;
+		goto exit;
 	ndc_req->nix_lf_tx_sync = 1;
 	ndc_req->nix_lf_rx_sync = 1;
 	rc = mbox_process(mbox);
@@ -234,38 +249,46 @@ roc_nix_lf_free(struct roc_nix *roc_nix)
 		plt_err("Error on NDC-NIX-[TX, RX] LF sync, rc %d", rc);
 
 	req = mbox_alloc_msg_nix_lf_free(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 	/* Let AF driver free all this nix lf's
 	 * NPC entries allocated using NPC MBOX.
 	 */
 	req->flags = 0;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static inline int
 nix_lf_attach(struct dev *dev)
 {
-	struct mbox *mbox = dev->mbox;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct rsrc_attach_req *req;
 	int rc = -ENOSPC;
 
 	/* Attach NIX(lf) */
 	req = mbox_alloc_msg_attach_resources(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->modify = true;
 	req->nixlf = true;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static inline int
 nix_lf_get_msix_offset(struct dev *dev, struct nix *nix)
 {
 	struct msix_offset_rsp *msix_rsp;
-	struct mbox *mbox = dev->mbox;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int rc;
 
 	/* Get MSIX vector offsets */
@@ -274,30 +297,34 @@ nix_lf_get_msix_offset(struct dev *dev, struct nix *nix)
 	if (rc == 0)
 		nix->msixoff = msix_rsp->nix_msixoff;
 
+	mbox_put(mbox);
 	return rc;
 }
 
 static inline int
 nix_lf_detach(struct nix *nix)
 {
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	struct rsrc_detach_req *req;
 	int rc = -ENOSPC;
 
 	req = mbox_alloc_msg_detach_resources(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->partial = true;
 	req->nixlf = true;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
 roc_nix_get_hw_info(struct roc_nix *roc_nix)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	struct nix_hw_info *hw_info;
 	int rc;
 
@@ -313,6 +340,7 @@ roc_nix_get_hw_info(struct roc_nix *roc_nix)
 			roc_nix->dwrr_mtu = hw_info->rpm_dwrr_mtu;
 	}
 
+	mbox_put(mbox);
 	return rc;
 }
 
diff --git a/drivers/common/cnxk/roc_nix_bpf.c b/drivers/common/cnxk/roc_nix_bpf.c
index 55a831f8335ee..d60396289b37d 100644
--- a/drivers/common/cnxk/roc_nix_bpf.c
+++ b/drivers/common/cnxk/roc_nix_bpf.c
@@ -24,15 +24,6 @@ static uint8_t sw_to_hw_lvl_map[] = {NIX_RX_BAND_PROF_LAYER_LEAF,
 				     NIX_RX_BAND_PROF_LAYER_MIDDLE,
 				     NIX_RX_BAND_PROF_LAYER_TOP};
 
-static inline struct mbox *
-get_mbox(struct roc_nix *roc_nix)
-{
-	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct dev *dev = &nix->dev;
-
-	return dev->mbox;
-}
-
 static inline uint64_t
 meter_rate_to_nix(uint64_t value, uint64_t *exponent_p, uint64_t *mantissa_p,
 		  uint64_t *div_exp_p, uint32_t timeunit_p)
@@ -313,12 +304,16 @@ int
 roc_nix_bpf_timeunit_get(struct roc_nix *roc_nix, uint32_t *time_unit)
 {
 	struct nix_bandprof_get_hwinfo_rsp *rsp;
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct msg_req *req;
 	int rc = -ENOSPC;
 
-	if (roc_model_is_cn9k())
-		return NIX_ERR_HW_NOTSUP;
+	if (roc_model_is_cn9k()) {
+		rc = NIX_ERR_HW_NOTSUP;
+		goto exit;
+	}
 
 	req = mbox_alloc_msg_nix_bandprof_get_hwinfo(mbox);
 	if (req == NULL)
@@ -331,6 +326,7 @@ roc_nix_bpf_timeunit_get(struct roc_nix *roc_nix, uint32_t *time_unit)
 	*time_unit = rsp->policer_timeunit;
 
 exit:
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -340,16 +336,22 @@ roc_nix_bpf_count_get(struct roc_nix *roc_nix, uint8_t lvl_mask,
 {
 	uint8_t mask = lvl_mask & NIX_BPF_LEVEL_F_MASK;
 	struct nix_bandprof_get_hwinfo_rsp *rsp;
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	uint8_t leaf_idx, mid_idx, top_idx;
 	struct msg_req *req;
 	int rc = -ENOSPC;
 
-	if (roc_model_is_cn9k())
-		return NIX_ERR_HW_NOTSUP;
+	if (roc_model_is_cn9k()) {
+		rc = NIX_ERR_HW_NOTSUP;
+		goto exit;
+	}
 
-	if (!mask)
-		return NIX_ERR_PARAM;
+	if (!mask) {
+		rc = NIX_ERR_PARAM;
+		goto exit;
+	}
 
 	req = mbox_alloc_msg_nix_bandprof_get_hwinfo(mbox);
 	if (req == NULL)
@@ -373,6 +375,7 @@ roc_nix_bpf_count_get(struct roc_nix *roc_nix, uint8_t lvl_mask,
 		count[top_idx] = rsp->prof_count[sw_to_hw_lvl_map[top_idx]];
 
 exit:
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -382,33 +385,45 @@ roc_nix_bpf_alloc(struct roc_nix *roc_nix, uint8_t lvl_mask,
 		  struct roc_nix_bpf_objs *profs)
 {
 	uint8_t mask = lvl_mask & NIX_BPF_LEVEL_F_MASK;
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_bandprof_alloc_req *req;
 	struct nix_bandprof_alloc_rsp *rsp;
 	uint8_t leaf_idx, mid_idx, top_idx;
 	int rc = -ENOSPC, i;
 
-	if (roc_model_is_cn9k())
-		return NIX_ERR_HW_NOTSUP;
+	if (roc_model_is_cn9k()) {
+		rc = NIX_ERR_HW_NOTSUP;
+		goto exit;
+	}
 
-	if (!mask)
-		return NIX_ERR_PARAM;
+	if (!mask) {
+		rc = NIX_ERR_PARAM;
+		goto exit;
+	}
 
 	leaf_idx = roc_nix_bpf_level_to_idx(mask & ROC_NIX_BPF_LEVEL_F_LEAF);
 	mid_idx = roc_nix_bpf_level_to_idx(mask & ROC_NIX_BPF_LEVEL_F_MID);
 	top_idx = roc_nix_bpf_level_to_idx(mask & ROC_NIX_BPF_LEVEL_F_TOP);
 
 	if ((leaf_idx != ROC_NIX_BPF_LEVEL_IDX_INVALID) &&
-	    (per_lvl_cnt[leaf_idx] > NIX_MAX_BPF_COUNT_LEAF_LAYER))
-		return NIX_ERR_INVALID_RANGE;
+	    (per_lvl_cnt[leaf_idx] > NIX_MAX_BPF_COUNT_LEAF_LAYER)) {
+		rc = NIX_ERR_INVALID_RANGE;
+		goto exit;
+	}
 
 	if ((mid_idx != ROC_NIX_BPF_LEVEL_IDX_INVALID) &&
-	    (per_lvl_cnt[mid_idx] > NIX_MAX_BPF_COUNT_MID_LAYER))
-		return NIX_ERR_INVALID_RANGE;
+	    (per_lvl_cnt[mid_idx] > NIX_MAX_BPF_COUNT_MID_LAYER)) {
+		rc = NIX_ERR_INVALID_RANGE;
+		goto exit;
+	}
 
 	if ((top_idx != ROC_NIX_BPF_LEVEL_IDX_INVALID) &&
-	    (per_lvl_cnt[top_idx] > NIX_MAX_BPF_COUNT_TOP_LAYER))
-		return NIX_ERR_INVALID_RANGE;
+	    (per_lvl_cnt[top_idx] > NIX_MAX_BPF_COUNT_TOP_LAYER)) {
+		rc = NIX_ERR_INVALID_RANGE;
+		goto exit;
+	}
 
 	req = mbox_alloc_msg_nix_bandprof_alloc(mbox);
 	if (req == NULL)
@@ -464,6 +479,7 @@ roc_nix_bpf_alloc(struct roc_nix *roc_nix, uint8_t lvl_mask,
 	}
 
 exit:
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -471,17 +487,23 @@ int
 roc_nix_bpf_free(struct roc_nix *roc_nix, struct roc_nix_bpf_objs *profs,
 		 uint8_t num_prof)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_bandprof_free_req *req;
 	uint8_t level;
-	int i, j;
+	int i, j, rc;
 
-	if (num_prof >= NIX_RX_BAND_PROF_LAYER_MAX)
-		return NIX_ERR_INVALID_RANGE;
+	if (num_prof >= NIX_RX_BAND_PROF_LAYER_MAX) {
+		rc = NIX_ERR_INVALID_RANGE;
+		goto exit;
+	}
 
 	req = mbox_alloc_msg_nix_bandprof_free(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	for (i = 0; i < num_prof; i++) {
 		level = sw_to_hw_lvl_map[profs[i].level];
@@ -490,21 +512,32 @@ roc_nix_bpf_free(struct roc_nix *roc_nix, struct roc_nix_bpf_objs *profs,
 			req->prof_idx[level][j] = profs[i].ids[j];
 	}
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_bpf_free_all(struct roc_nix *roc_nix)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_bandprof_free_req *req;
+	int rc;
 
 	req = mbox_alloc_msg_nix_bandprof_free(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	req->free_all = true;
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -513,7 +546,9 @@ roc_nix_bpf_config(struct roc_nix *roc_nix, uint16_t id,
 		   struct roc_nix_bpf_cfg *cfg)
 {
 	uint64_t exponent_p = 0, mantissa_p = 0, div_exp_p = 0;
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = dev->mbox;
 	struct nix_cn10k_aq_enq_req *aq;
 	uint32_t policer_timeunit;
 	uint8_t level_idx;
@@ -533,9 +568,11 @@ roc_nix_bpf_config(struct roc_nix *roc_nix, uint16_t id,
 	if (level_idx == ROC_NIX_BPF_LEVEL_IDX_INVALID)
 		return NIX_ERR_PARAM;
 
-	aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-	if (aq == NULL)
-		return -ENOSPC;
+	aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox_get(mbox));
+	if (aq == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 	aq->qidx = (sw_to_hw_lvl_map[level_idx] << 14) | id;
 	aq->ctype = NIX_AQ_CTYPE_BAND_PROF;
 	aq->op = NIX_AQ_INSTOP_WRITE;
@@ -631,7 +668,8 @@ roc_nix_bpf_config(struct roc_nix *roc_nix, uint16_t id,
 		break;
 
 	default:
-		return NIX_ERR_PARAM;
+		rc = NIX_ERR_PARAM;
+		goto exit;
 	}
 
 	aq->prof.lmode = cfg->lmode;
@@ -652,7 +690,10 @@ roc_nix_bpf_config(struct roc_nix *roc_nix, uint16_t id,
 	aq->prof_mask.yc_action = ~(aq->prof_mask.yc_action);
 	aq->prof_mask.rc_action = ~(aq->prof_mask.rc_action);
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -660,19 +701,26 @@ roc_nix_bpf_ena_dis(struct roc_nix *roc_nix, uint16_t id, struct roc_nix_rq *rq,
 		    bool enable)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_cn10k_aq_enq_req *aq;
 	int rc;
 
-	if (roc_model_is_cn9k())
-		return NIX_ERR_HW_NOTSUP;
+	if (roc_model_is_cn9k()) {
+		rc = NIX_ERR_HW_NOTSUP;
+		goto exit;
+	}
 
-	if (rq->qid >= nix->nb_rx_queues)
-		return NIX_ERR_QUEUE_INVALID_RANGE;
+	if (rq->qid >= nix->nb_rx_queues) {
+		rc =  NIX_ERR_QUEUE_INVALID_RANGE;
+		goto exit;
+	}
 
 	aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-	if (aq == NULL)
-		return -ENOSPC;
+	if (aq == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 	aq->qidx = rq->qid;
 	aq->ctype = NIX_AQ_CTYPE_RQ;
 	aq->op = NIX_AQ_INSTOP_WRITE;
@@ -691,6 +739,7 @@ roc_nix_bpf_ena_dis(struct roc_nix *roc_nix, uint16_t id, struct roc_nix_rq *rq,
 	rq->bpf_id = id;
 
 exit:
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -698,22 +747,30 @@ int
 roc_nix_bpf_dump(struct roc_nix *roc_nix, uint16_t id,
 		 enum roc_nix_bpf_level_flag lvl_flag)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_cn10k_aq_enq_rsp *rsp;
 	struct nix_cn10k_aq_enq_req *aq;
 	uint8_t level_idx;
 	int rc;
 
-	if (roc_model_is_cn9k())
-		return NIX_ERR_HW_NOTSUP;
+	if (roc_model_is_cn9k()) {
+		rc = NIX_ERR_HW_NOTSUP;
+		goto exit;
+	}
 
 	level_idx = roc_nix_bpf_level_to_idx(lvl_flag);
-	if (level_idx == ROC_NIX_BPF_LEVEL_IDX_INVALID)
-		return NIX_ERR_PARAM;
+	if (level_idx == ROC_NIX_BPF_LEVEL_IDX_INVALID) {
+		rc = NIX_ERR_PARAM;
+		goto exit;
+	}
 
 	aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-	if (aq == NULL)
-		return -ENOSPC;
+	if (aq == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 	aq->qidx = (sw_to_hw_lvl_map[level_idx] << 14 | id);
 	aq->ctype = NIX_AQ_CTYPE_BAND_PROF;
 	aq->op = NIX_AQ_INSTOP_READ;
@@ -722,7 +779,8 @@ roc_nix_bpf_dump(struct roc_nix *roc_nix, uint16_t id,
 		plt_dump("============= band prof id =%d ===============", id);
 		nix_lf_bpf_dump(&rsp->prof);
 	}
-
+exit:
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -731,7 +789,9 @@ roc_nix_bpf_pre_color_tbl_setup(struct roc_nix *roc_nix, uint16_t id,
 				enum roc_nix_bpf_level_flag lvl_flag,
 				struct roc_nix_bpf_precolor *tbl)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = dev->mbox;
 	struct nix_cn10k_aq_enq_req *aq;
 	uint8_t pc_mode, tn_ena;
 	uint8_t level_idx;
@@ -797,9 +857,11 @@ roc_nix_bpf_pre_color_tbl_setup(struct roc_nix *roc_nix, uint16_t id,
 	}
 
 	/* Update corresponding bandwidth profile too */
-	aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-	if (aq == NULL)
-		return -ENOSPC;
+	aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox_get(mbox));
+	if (aq == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 	aq->qidx = (sw_to_hw_lvl_map[level_idx] << 14) | id;
 	aq->ctype = NIX_AQ_CTYPE_BAND_PROF;
 	aq->op = NIX_AQ_INSTOP_WRITE;
@@ -808,9 +870,10 @@ roc_nix_bpf_pre_color_tbl_setup(struct roc_nix *roc_nix, uint16_t id,
 	aq->prof_mask.pc_mode = ~(aq->prof_mask.pc_mode);
 	aq->prof_mask.tnl_ena = ~(aq->prof_mask.tnl_ena);
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
 
 exit:
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -819,20 +882,29 @@ roc_nix_bpf_connect(struct roc_nix *roc_nix,
 		    enum roc_nix_bpf_level_flag lvl_flag, uint16_t src_id,
 		    uint16_t dst_id)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_cn10k_aq_enq_req *aq;
 	uint8_t level_idx;
+	int rc;
 
-	if (roc_model_is_cn9k())
-		return NIX_ERR_HW_NOTSUP;
+	if (roc_model_is_cn9k()) {
+		rc = NIX_ERR_HW_NOTSUP;
+		goto exit;
+	}
 
 	level_idx = roc_nix_bpf_level_to_idx(lvl_flag);
-	if (level_idx == ROC_NIX_BPF_LEVEL_IDX_INVALID)
-		return NIX_ERR_PARAM;
+	if (level_idx == ROC_NIX_BPF_LEVEL_IDX_INVALID) {
+		rc = NIX_ERR_PARAM;
+		goto exit;
+	}
 
 	aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-	if (aq == NULL)
-		return -ENOSPC;
+	if (aq == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 	aq->qidx = (sw_to_hw_lvl_map[level_idx] << 14) | src_id;
 	aq->ctype = NIX_AQ_CTYPE_BAND_PROF;
 	aq->op = NIX_AQ_INSTOP_WRITE;
@@ -847,7 +919,10 @@ roc_nix_bpf_connect(struct roc_nix *roc_nix,
 		aq->prof_mask.band_prof_id = ~(aq->prof_mask.band_prof_id);
 	}
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -859,28 +934,36 @@ roc_nix_bpf_stats_read(struct roc_nix *roc_nix, uint16_t id, uint64_t mask,
 	uint8_t green_octs_drop, yellow_octs_drop, red_octs_drop;
 	uint8_t green_pkt_pass, green_octs_pass, green_pkt_drop;
 	uint8_t red_pkt_pass, red_octs_pass, red_pkt_drop;
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_cn10k_aq_enq_rsp *rsp;
 	struct nix_cn10k_aq_enq_req *aq;
 	uint8_t level_idx;
 	int rc;
 
-	if (roc_model_is_cn9k())
-		return NIX_ERR_HW_NOTSUP;
+	if (roc_model_is_cn9k()) {
+		rc = NIX_ERR_HW_NOTSUP;
+		goto exit;
+	}
 
 	level_idx = roc_nix_bpf_level_to_idx(lvl_flag);
-	if (level_idx == ROC_NIX_BPF_LEVEL_IDX_INVALID)
-		return NIX_ERR_PARAM;
+	if (level_idx == ROC_NIX_BPF_LEVEL_IDX_INVALID) {
+		rc = NIX_ERR_PARAM;
+		goto exit;
+	}
 
 	aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-	if (aq == NULL)
-		return -ENOSPC;
+	if (aq == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 	aq->qidx = (sw_to_hw_lvl_map[level_idx] << 14 | id);
 	aq->ctype = NIX_AQ_CTYPE_BAND_PROF;
 	aq->op = NIX_AQ_INSTOP_READ;
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	green_pkt_pass =
 		roc_nix_bpf_stats_to_idx(mask & ROC_NIX_BPF_GREEN_PKT_F_PASS);
@@ -943,27 +1026,39 @@ roc_nix_bpf_stats_read(struct roc_nix *roc_nix, uint16_t id, uint64_t mask,
 	if (red_octs_drop != ROC_NIX_BPF_STATS_MAX)
 		stats[red_octs_drop] = rsp->prof.red_octs_drop;
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_bpf_stats_reset(struct roc_nix *roc_nix, uint16_t id, uint64_t mask,
 			enum roc_nix_bpf_level_flag lvl_flag)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_cn10k_aq_enq_req *aq;
 	uint8_t level_idx;
+	int rc;
 
-	if (roc_model_is_cn9k())
-		return NIX_ERR_HW_NOTSUP;
+	if (roc_model_is_cn9k()) {
+		rc = NIX_ERR_HW_NOTSUP;
+		goto exit;
+	}
 
 	level_idx = roc_nix_bpf_level_to_idx(lvl_flag);
-	if (level_idx == ROC_NIX_BPF_LEVEL_IDX_INVALID)
-		return NIX_ERR_PARAM;
+	if (level_idx == ROC_NIX_BPF_LEVEL_IDX_INVALID) {
+		rc = NIX_ERR_PARAM;
+		goto exit;
+	}
 
 	aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-	if (aq == NULL)
-		return -ENOSPC;
+	if (aq == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 	aq->qidx = (sw_to_hw_lvl_map[level_idx] << 14 | id);
 	aq->ctype = NIX_AQ_CTYPE_BAND_PROF;
 	aq->op = NIX_AQ_INSTOP_WRITE;
@@ -1023,7 +1118,10 @@ roc_nix_bpf_stats_reset(struct roc_nix *roc_nix, uint16_t id, uint64_t mask,
 		aq->prof_mask.red_octs_drop = ~(aq->prof_mask.red_octs_drop);
 	}
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
diff --git a/drivers/common/cnxk/roc_nix_debug.c b/drivers/common/cnxk/roc_nix_debug.c
index e491060765ad2..775325115b184 100644
--- a/drivers/common/cnxk/roc_nix_debug.c
+++ b/drivers/common/cnxk/roc_nix_debug.c
@@ -332,17 +332,18 @@ roc_nix_lf_reg_dump(struct roc_nix *roc_nix, uint64_t *data)
 int
 nix_q_ctx_get(struct dev *dev, uint8_t ctype, uint16_t qid, __io void **ctx_p)
 {
-	struct mbox *mbox = dev->mbox;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int rc;
 
 	if (roc_model_is_cn9k()) {
 		struct nix_aq_enq_rsp *rsp;
 		struct nix_aq_enq_req *aq;
-		int rc;
 
 		aq = mbox_alloc_msg_nix_aq_enq(mbox);
-		if (!aq)
-			return -ENOSPC;
+		if (!aq) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		aq->qidx = qid;
 		aq->ctype = ctype;
@@ -350,7 +351,7 @@ nix_q_ctx_get(struct dev *dev, uint8_t ctype, uint16_t qid, __io void **ctx_p)
 
 		rc = mbox_process_msg(mbox, (void *)&rsp);
 		if (rc)
-			return rc;
+			goto exit;
 		if (ctype == NIX_AQ_CTYPE_RQ)
 			*ctx_p = &rsp->rq;
 		else if (ctype == NIX_AQ_CTYPE_SQ)
@@ -362,8 +363,10 @@ nix_q_ctx_get(struct dev *dev, uint8_t ctype, uint16_t qid, __io void **ctx_p)
 		struct nix_cn10k_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-		if (!aq)
-			return -ENOSPC;
+		if (!aq) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		aq->qidx = qid;
 		aq->ctype = ctype;
@@ -371,7 +374,7 @@ nix_q_ctx_get(struct dev *dev, uint8_t ctype, uint16_t qid, __io void **ctx_p)
 
 		rc = mbox_process_msg(mbox, (void *)&rsp);
 		if (rc)
-			return rc;
+			goto exit;
 
 		if (ctype == NIX_AQ_CTYPE_RQ)
 			*ctx_p = &rsp->rq;
@@ -380,7 +383,10 @@ nix_q_ctx_get(struct dev *dev, uint8_t ctype, uint16_t qid, __io void **ctx_p)
 		else
 			*ctx_p = &rsp->cq;
 	}
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static inline void
@@ -739,14 +745,18 @@ roc_nix_queues_ctx_dump(struct roc_nix *roc_nix, FILE *file)
 		}
 
 		/* Dump SQB Aura minimal info */
-		npa_aq = mbox_alloc_msg_npa_aq_enq(npa_lf->mbox);
-		if (npa_aq == NULL)
-			return -ENOSPC;
+		npa_aq = mbox_alloc_msg_npa_aq_enq(mbox_get(npa_lf->mbox));
+		if (npa_aq == NULL) {
+			rc = -ENOSPC;
+			mbox_put(npa_lf->mbox);
+			goto fail;
+		}
 		npa_aq->aura_id = sqb_aura;
 		npa_aq->ctype = NPA_AQ_CTYPE_AURA;
 		npa_aq->op = NPA_AQ_INSTOP_READ;
 
 		rc = mbox_process_msg(npa_lf->mbox, (void *)&npa_rsp);
+		mbox_put(npa_lf->mbox);
 		if (rc) {
 			plt_err("Failed to get sq's sqb_aura context");
 			continue;
@@ -1109,7 +1119,7 @@ nix_tm_dump_lvl(struct nix *nix, struct nix_tm_node_list *list, uint8_t hw_lvl)
 		if (!k)
 			continue;
 
-		req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+		req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 		req->read = 1;
 		req->lvl = node->hw_lvl;
 		req->num_regs = k;
@@ -1122,6 +1132,7 @@ nix_tm_dump_lvl(struct nix *nix, struct nix_tm_node_list *list, uint8_t hw_lvl)
 		} else {
 			nix_dump(file, "\t!!!Failed to dump registers!!!");
 		}
+		mbox_put(mbox);
 	}
 
 	if (found)
@@ -1134,7 +1145,7 @@ nix_tm_dump_lvl(struct nix *nix, struct nix_tm_node_list *list, uint8_t hw_lvl)
 		if (!k)
 			return;
 
-		req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+		req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 		req->read = 1;
 		req->lvl = NIX_TXSCH_LVL_TL1;
 		req->num_regs = k;
@@ -1147,6 +1158,7 @@ nix_tm_dump_lvl(struct nix *nix, struct nix_tm_node_list *list, uint8_t hw_lvl)
 		} else {
 			nix_dump(file, "\t!!!Failed to dump registers!!!");
 		}
+		mbox_put(mbox);
 		nix_dump(file, "\n");
 	}
 }
diff --git a/drivers/common/cnxk/roc_nix_fc.c b/drivers/common/cnxk/roc_nix_fc.c
index 033e17a4bfd0b..569fe8dc48bd8 100644
--- a/drivers/common/cnxk/roc_nix_fc.c
+++ b/drivers/common/cnxk/roc_nix_fc.c
@@ -5,15 +5,6 @@
 #include "roc_api.h"
 #include "roc_priv.h"
 
-static inline struct mbox *
-get_mbox(struct roc_nix *roc_nix)
-{
-	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct dev *dev = &nix->dev;
-
-	return dev->mbox;
-}
-
 static int
 nix_fc_rxchan_bpid_get(struct roc_nix *roc_nix, struct roc_nix_fc_cfg *fc_cfg)
 {
@@ -33,7 +24,8 @@ static int
 nix_fc_rxchan_bpid_set(struct roc_nix *roc_nix, bool enable)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_bp_cfg_req *req;
 	struct nix_bp_cfg_rsp *rsp;
 	int rc = -ENOSPC, i;
@@ -41,7 +33,7 @@ nix_fc_rxchan_bpid_set(struct roc_nix *roc_nix, bool enable)
 	if (enable) {
 		req = mbox_alloc_msg_nix_bp_enable(mbox);
 		if (req == NULL)
-			return rc;
+			goto exit;
 
 		req->chan_base = 0;
 		if (roc_nix_is_lbk(roc_nix) || roc_nix_is_sdp(roc_nix))
@@ -63,7 +55,7 @@ nix_fc_rxchan_bpid_set(struct roc_nix *roc_nix, bool enable)
 	} else {
 		req = mbox_alloc_msg_nix_bp_disable(mbox);
 		if (req == NULL)
-			return rc;
+			goto exit;
 		req->chan_base = 0;
 		req->chan_cnt = nix->chan_cnt;
 
@@ -83,7 +75,7 @@ nix_fc_rxchan_bpid_set(struct roc_nix *roc_nix, bool enable)
 	    !roc_errata_cpt_hang_on_x2p_bp()) {
 		req = mbox_alloc_msg_nix_cpt_bp_enable(mbox);
 		if (req == NULL)
-			return rc;
+			goto exit;
 		req->chan_base = 0;
 		req->chan_cnt = 1;
 		req->bpid_per_chan = 0;
@@ -94,7 +86,7 @@ nix_fc_rxchan_bpid_set(struct roc_nix *roc_nix, bool enable)
 	} else {
 		req = mbox_alloc_msg_nix_cpt_bp_disable(mbox);
 		if (req == NULL)
-			return rc;
+			goto exit;
 		req->chan_base = 0;
 		req->chan_cnt = 1;
 		req->bpid_per_chan = 0;
@@ -105,13 +97,16 @@ nix_fc_rxchan_bpid_set(struct roc_nix *roc_nix, bool enable)
 	}
 
 exit:
+	mbox_put(mbox);
 	return rc;
 }
 
 static int
 nix_fc_cq_config_get(struct roc_nix *roc_nix, struct roc_nix_fc_cfg *fc_cfg)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_aq_enq_rsp *rsp;
 	int rc;
 
@@ -119,8 +114,10 @@ nix_fc_cq_config_get(struct roc_nix *roc_nix, struct roc_nix_fc_cfg *fc_cfg)
 		struct nix_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_aq_enq(mbox);
-		if (!aq)
-			return -ENOSPC;
+		if (!aq) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		aq->qidx = fc_cfg->cq_cfg.rq;
 		aq->ctype = NIX_AQ_CTYPE_CQ;
@@ -129,8 +126,10 @@ nix_fc_cq_config_get(struct roc_nix *roc_nix, struct roc_nix_fc_cfg *fc_cfg)
 		struct nix_cn10k_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-		if (!aq)
-			return -ENOSPC;
+		if (!aq) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		aq->qidx = fc_cfg->cq_cfg.rq;
 		aq->ctype = NIX_AQ_CTYPE_CQ;
@@ -146,13 +145,16 @@ nix_fc_cq_config_get(struct roc_nix *roc_nix, struct roc_nix_fc_cfg *fc_cfg)
 	fc_cfg->type = ROC_NIX_FC_CQ_CFG;
 
 exit:
+	mbox_put(mbox);
 	return rc;
 }
 
 static int
 nix_fc_rq_config_get(struct roc_nix *roc_nix, struct roc_nix_fc_cfg *fc_cfg)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_aq_enq_rsp *rsp;
 	struct npa_aq_enq_req *npa_req;
 	struct npa_aq_enq_rsp *npa_rsp;
@@ -162,8 +164,10 @@ nix_fc_rq_config_get(struct roc_nix *roc_nix, struct roc_nix_fc_cfg *fc_cfg)
 		struct nix_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_aq_enq(mbox);
-		if (!aq)
-			return -ENOSPC;
+		if (!aq) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		aq->qidx = fc_cfg->rq_cfg.rq;
 		aq->ctype = NIX_AQ_CTYPE_RQ;
@@ -172,8 +176,10 @@ nix_fc_rq_config_get(struct roc_nix *roc_nix, struct roc_nix_fc_cfg *fc_cfg)
 		struct nix_cn10k_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-		if (!aq)
-			return -ENOSPC;
+		if (!aq) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		aq->qidx = fc_cfg->rq_cfg.rq;
 		aq->ctype = NIX_AQ_CTYPE_RQ;
@@ -185,8 +191,10 @@ nix_fc_rq_config_get(struct roc_nix *roc_nix, struct roc_nix_fc_cfg *fc_cfg)
 		goto exit;
 
 	npa_req = mbox_alloc_msg_npa_aq_enq(mbox);
-	if (!npa_req)
-		return -ENOSPC;
+	if (!npa_req) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	npa_req->aura_id = rsp->rq.lpb_aura;
 	npa_req->ctype = NPA_AQ_CTYPE_AURA;
@@ -201,6 +209,7 @@ nix_fc_rq_config_get(struct roc_nix *roc_nix, struct roc_nix_fc_cfg *fc_cfg)
 	fc_cfg->type = ROC_NIX_FC_RQ_CFG;
 
 exit:
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -208,14 +217,18 @@ static int
 nix_fc_cq_config_set(struct roc_nix *roc_nix, struct roc_nix_fc_cfg *fc_cfg)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
+	int rc;
 
 	if (roc_model_is_cn9k()) {
 		struct nix_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_aq_enq(mbox);
-		if (!aq)
-			return -ENOSPC;
+		if (!aq) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		aq->qidx = fc_cfg->cq_cfg.rq;
 		aq->ctype = NIX_AQ_CTYPE_CQ;
@@ -234,8 +247,10 @@ nix_fc_cq_config_set(struct roc_nix *roc_nix, struct roc_nix_fc_cfg *fc_cfg)
 		struct nix_cn10k_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-		if (!aq)
-			return -ENOSPC;
+		if (!aq) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		aq->qidx = fc_cfg->cq_cfg.rq;
 		aq->ctype = NIX_AQ_CTYPE_CQ;
@@ -252,7 +267,10 @@ nix_fc_cq_config_set(struct roc_nix *roc_nix, struct roc_nix_fc_cfg *fc_cfg)
 		aq->cq_mask.bp_ena = ~(aq->cq_mask.bp_ena);
 	}
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
@@ -323,7 +341,8 @@ enum roc_nix_fc_mode
 roc_nix_fc_mode_get(struct roc_nix *roc_nix)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct cgx_pause_frm_cfg *req, *rsp;
 	enum roc_nix_fc_mode mode;
 	int rc = -ENOSPC;
@@ -331,18 +350,19 @@ roc_nix_fc_mode_get(struct roc_nix *roc_nix)
 	/* Flow control on LBK link is always available */
 	if (roc_nix_is_lbk(roc_nix)) {
 		if (nix->tx_pause && nix->rx_pause)
-			return ROC_NIX_FC_FULL;
+			rc = ROC_NIX_FC_FULL;
 		else if (nix->rx_pause)
-			return ROC_NIX_FC_RX;
+			rc = ROC_NIX_FC_RX;
 		else if (nix->tx_pause)
-			return ROC_NIX_FC_TX;
+			rc = ROC_NIX_FC_TX;
 		else
-			return ROC_NIX_FC_NONE;
+			rc = ROC_NIX_FC_NONE;
+		goto exit;
 	}
 
 	req = mbox_alloc_msg_cgx_cfg_pause_frm(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->set = 0;
 
 	rc = mbox_process_msg(mbox, (void *)&rsp);
@@ -360,17 +380,19 @@ roc_nix_fc_mode_get(struct roc_nix *roc_nix)
 
 	nix->rx_pause = rsp->rx_pause;
 	nix->tx_pause = rsp->tx_pause;
-	return mode;
+	rc = mode;
 
 exit:
-	return ROC_NIX_FC_NONE;
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_fc_mode_set(struct roc_nix *roc_nix, enum roc_nix_fc_mode mode)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct cgx_pause_frm_cfg *req;
 	uint8_t tx_pause, rx_pause;
 	int rc = -ENOSPC;
@@ -382,12 +404,13 @@ roc_nix_fc_mode_set(struct roc_nix *roc_nix, enum roc_nix_fc_mode mode)
 	if (roc_nix_is_lbk(roc_nix)) {
 		nix->rx_pause = rx_pause;
 		nix->tx_pause = tx_pause;
-		return 0;
+		rc = 0;
+		goto exit;
 	}
 
 	req = mbox_alloc_msg_cgx_cfg_pause_frm(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->set = 1;
 	req->rx_pause = rx_pause;
 	req->tx_pause = tx_pause;
@@ -400,6 +423,7 @@ roc_nix_fc_mode_set(struct roc_nix *roc_nix, enum roc_nix_fc_mode mode)
 	nix->tx_pause = tx_pause;
 
 exit:
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -421,11 +445,11 @@ roc_nix_fc_npa_bp_cfg(struct roc_nix *roc_nix, uint64_t pool_id, uint8_t ena,
 
 	if (!lf)
 		return;
-	mbox = lf->mbox;
+	mbox = mbox_get(lf->mbox);
 
 	req = mbox_alloc_msg_npa_aq_enq(mbox);
 	if (req == NULL)
-		return;
+		goto exit;
 
 	req->aura_id = roc_npa_aura_handle_to_aura(pool_id);
 	req->ctype = NPA_AQ_CTYPE_AURA;
@@ -433,7 +457,7 @@ roc_nix_fc_npa_bp_cfg(struct roc_nix *roc_nix, uint64_t pool_id, uint8_t ena,
 
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return;
+		goto exit;
 
 	limit = rsp->aura.limit;
 	shift = rsp->aura.shift;
@@ -454,7 +478,7 @@ roc_nix_fc_npa_bp_cfg(struct roc_nix *roc_nix, uint64_t pool_id, uint8_t ena,
 		    !force) {
 			req = mbox_alloc_msg_npa_aq_enq(mbox);
 			if (req == NULL)
-				return;
+				goto exit;
 
 			plt_info("Disabling BP/FC on aura 0x%" PRIx64
 				 " as it shared across ports or tc",
@@ -472,16 +496,16 @@ roc_nix_fc_npa_bp_cfg(struct roc_nix *roc_nix, uint64_t pool_id, uint8_t ena,
 		if ((nix1 != nix->is_nix1) || (bpid != nix->bpid[tc]))
 			plt_info("Ignoring aura 0x%" PRIx64 "->%u bpid mapping",
 				 pool_id, nix->bpid[tc]);
-		return;
+		goto exit;
 	}
 
 	/* BP was previously enabled but now disabled skip. */
 	if (rsp->aura.bp && ena)
-		return;
+		goto exit;
 
 	req = mbox_alloc_msg_npa_aq_enq(mbox);
 	if (req == NULL)
-		return;
+		goto exit;
 
 	req->aura_id = roc_npa_aura_handle_to_aura(pool_id);
 	req->ctype = NPA_AQ_CTYPE_AURA;
@@ -506,20 +530,26 @@ roc_nix_fc_npa_bp_cfg(struct roc_nix *roc_nix, uint64_t pool_id, uint8_t ena,
 	req->aura_mask.bp_ena = ~(req->aura_mask.bp_ena);
 
 	mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return;
 }
 
 int
 roc_nix_pfc_mode_set(struct roc_nix *roc_nix, struct roc_nix_pfc_cfg *pfc_cfg)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	uint8_t tx_pause, rx_pause;
 	struct cgx_pfc_cfg *req;
 	struct cgx_pfc_rsp *rsp;
 	int rc = -ENOSPC;
 
-	if (roc_nix_is_lbk(roc_nix))
-		return NIX_ERR_OP_NOTSUP;
+	if (roc_nix_is_lbk(roc_nix)) {
+		rc =  NIX_ERR_OP_NOTSUP;
+		goto exit;
+	}
 
 	rx_pause = (pfc_cfg->mode == ROC_NIX_FC_FULL) ||
 		   (pfc_cfg->mode == ROC_NIX_FC_RX);
@@ -546,6 +576,7 @@ roc_nix_pfc_mode_set(struct roc_nix *roc_nix, struct roc_nix_pfc_cfg *pfc_cfg)
 		nix->cev &= ~BIT(pfc_cfg->tc);
 
 exit:
+	mbox_put(mbox);
 	return rc;
 }
 
diff --git a/drivers/common/cnxk/roc_nix_inl.c b/drivers/common/cnxk/roc_nix_inl.c
index cb02d08a98e07..032aaa3a0fbe3 100644
--- a/drivers/common/cnxk/roc_nix_inl.c
+++ b/drivers/common/cnxk/roc_nix_inl.c
@@ -420,19 +420,19 @@ nix_inl_rq_mask_cfg(struct roc_nix *roc_nix, bool enable)
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
 	struct nix_rq_cpt_field_mask_cfg_req *msk_req;
 	struct idev_cfg *idev = idev_get_cfg();
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	struct idev_nix_inl_cfg *inl_cfg;
 	uint64_t aura_handle;
 	int rc = -ENOSPC;
 	int i;
 
 	if (!idev)
-		return rc;
+		goto exit;
 
 	inl_cfg = &idev->inl_cfg;
 	msk_req = mbox_alloc_msg_nix_lf_inline_rq_cfg(mbox);
 	if (msk_req == NULL)
-		return rc;
+		goto exit;
 
 	for (i = 0; i < RQ_CTX_MASK_MAX; i++)
 		msk_req->rq_ctx_word_mask[i] = 0xFFFFFFFFFFFFFFFF;
@@ -477,7 +477,10 @@ nix_inl_rq_mask_cfg(struct roc_nix *roc_nix, bool enable)
 	msk_req->ipsec_cfg1.spb_cpt_sizem1 = (inl_cfg->buf_sz >> 7) - 1;
 	msk_req->ipsec_cfg1.spb_cpt_enable = enable;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 bool
@@ -851,6 +854,7 @@ roc_nix_inl_dev_rq_get(struct roc_nix_rq *rq, bool enable)
 	struct nix_inl_dev *inl_dev;
 	struct roc_nix_rq *inl_rq;
 	uint16_t inl_rq_id;
+	struct mbox *mbox;
 	struct dev *dev;
 	int rc;
 
@@ -948,20 +952,24 @@ roc_nix_inl_dev_rq_get(struct roc_nix_rq *rq, bool enable)
 	inl_rq->sso_ena = true;
 
 	/* Prepare and send RQ init mbox */
+	mbox = mbox_get(dev->mbox);
 	if (roc_model_is_cn9k())
 		rc = nix_rq_cn9k_cfg(dev, inl_rq, inl_dev->qints, false, enable);
 	else
 		rc = nix_rq_cfg(dev, inl_rq, inl_dev->qints, false, enable);
 	if (rc) {
 		plt_err("Failed to prepare aq_enq msg, rc=%d", rc);
+		mbox_put(mbox);
 		return rc;
 	}
 
 	rc = mbox_process(dev->mbox);
 	if (rc) {
 		plt_err("Failed to send aq_enq msg, rc=%d", rc);
+		mbox_put(mbox);
 		return rc;
 	}
+	mbox_put(mbox);
 
 	/* Check meta aura */
 	if (enable && nix->need_meta_aura) {
diff --git a/drivers/common/cnxk/roc_nix_inl_dev.c b/drivers/common/cnxk/roc_nix_inl_dev.c
index 0578afc3b7977..b340b92e7759d 100644
--- a/drivers/common/cnxk/roc_nix_inl_dev.c
+++ b/drivers/common/cnxk/roc_nix_inl_dev.c
@@ -111,27 +111,36 @@ nix_inl_selftest(void)
 static int
 nix_inl_cpt_ctx_cache_sync(struct nix_inl_dev *inl_dev)
 {
-	struct mbox *mbox = (&inl_dev->dev)->mbox;
+	struct mbox *mbox = mbox_get((&inl_dev->dev)->mbox);
 	struct msg_req *req;
+	int rc;
 
 	req = mbox_alloc_msg_cpt_ctx_cache_sync(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
 nix_inl_nix_ipsec_cfg(struct nix_inl_dev *inl_dev, bool ena)
 {
 	struct nix_inline_ipsec_lf_cfg *lf_cfg;
-	struct mbox *mbox = (&inl_dev->dev)->mbox;
+	struct mbox *mbox = mbox_get((&inl_dev->dev)->mbox);
 	uint64_t max_sa;
 	uint32_t sa_w;
+	int rc;
 
 	lf_cfg = mbox_alloc_msg_nix_inline_ipsec_lf_cfg(mbox);
-	if (lf_cfg == NULL)
-		return -ENOSPC;
+	if (lf_cfg == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	if (ena) {
 
@@ -156,7 +165,10 @@ nix_inl_nix_ipsec_cfg(struct nix_inl_dev *inl_dev, bool ena)
 		lf_cfg->enable = 0;
 	}
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
@@ -343,9 +355,11 @@ nix_inl_nix_setup(struct nix_inl_dev *inl_dev)
 	max_sa = plt_align32pow2(ipsec_in_max_spi - ipsec_in_min_spi + 1);
 
 	/* Alloc NIX LF needed for single RQ */
-	req = mbox_alloc_msg_nix_lf_alloc(mbox);
-	if (req == NULL)
+	req = mbox_alloc_msg_nix_lf_alloc(mbox_get(mbox));
+	if (req == NULL) {
+		mbox_put(mbox);
 		return rc;
+	}
 	/* We will have per-port RQ if it is not with channel masking */
 	req->rq_cnt = inl_dev->nb_rqs;
 	req->sq_cnt = 1;
@@ -366,6 +380,7 @@ nix_inl_nix_setup(struct nix_inl_dev *inl_dev)
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc) {
 		plt_err("Failed to alloc lf, rc=%d", rc);
+		mbox_put(mbox);
 		return rc;
 	}
 
@@ -373,16 +388,19 @@ nix_inl_nix_setup(struct nix_inl_dev *inl_dev)
 	inl_dev->lf_rx_stats = rsp->lf_rx_stats;
 	inl_dev->qints = rsp->qints;
 	inl_dev->cints = rsp->cints;
+	mbox_put(mbox);
 
 	/* Get VWQE info if supported */
 	if (roc_model_is_cn10k()) {
-		mbox_alloc_msg_nix_get_hw_info(mbox);
+		mbox_alloc_msg_nix_get_hw_info(mbox_get(mbox));
 		rc = mbox_process_msg(mbox, (void *)&hw_info);
 		if (rc) {
 			plt_err("Failed to get HW info, rc=%d", rc);
+			mbox_put(mbox);
 			goto lf_free;
 		}
 		inl_dev->vwqe_interval = hw_info->vwqe_delay;
+		mbox_put(mbox);
 	}
 
 	/* Register nix interrupts */
@@ -438,8 +456,9 @@ nix_inl_nix_setup(struct nix_inl_dev *inl_dev)
 unregister_irqs:
 	nix_inl_nix_unregister_irqs(inl_dev);
 lf_free:
-	mbox_alloc_msg_nix_lf_free(mbox);
+	mbox_alloc_msg_nix_lf_free(mbox_get(mbox));
 	rc |= mbox_process(mbox);
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -458,25 +477,33 @@ nix_inl_nix_release(struct nix_inl_dev *inl_dev)
 		plt_err("Failed to disable Inbound IPSec, rc=%d", rc);
 
 	/* Sync NDC-NIX for LF */
-	ndc_req = mbox_alloc_msg_ndc_sync_op(mbox);
-	if (ndc_req == NULL)
+	ndc_req = mbox_alloc_msg_ndc_sync_op(mbox_get(mbox));
+	if (ndc_req == NULL) {
+		mbox_put(mbox);
 		return rc;
+	}
 	ndc_req->nix_lf_rx_sync = 1;
 	rc = mbox_process(mbox);
 	if (rc)
 		plt_err("Error on NDC-NIX-RX LF sync, rc %d", rc);
+	mbox_put(mbox);
 
 	/* Unregister IRQs */
 	nix_inl_nix_unregister_irqs(inl_dev);
 
 	/* By default all associated mcam rules are deleted */
-	req = mbox_alloc_msg_nix_lf_free(mbox);
-	if (req == NULL)
+	req = mbox_alloc_msg_nix_lf_free(mbox_get(mbox));
+	if (req == NULL) {
+		mbox_put(mbox);
 		return -ENOSPC;
+	}
 
 	rc = mbox_process(mbox);
-	if (rc)
+	if (rc) {
+		mbox_put(mbox);
 		return rc;
+	}
+	mbox_put(mbox);
 
 	plt_free(inl_dev->rqs);
 	plt_free(inl_dev->inb_sa_base);
@@ -490,14 +517,14 @@ nix_inl_lf_attach(struct nix_inl_dev *inl_dev)
 {
 	struct msix_offset_rsp *msix_rsp;
 	struct dev *dev = &inl_dev->dev;
-	struct mbox *mbox = dev->mbox;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct rsrc_attach_req *req;
 	uint64_t nix_blkaddr;
 	int rc = -ENOSPC;
 
 	req = mbox_alloc_msg_attach_resources(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->modify = true;
 	/* Attach 1 NIXLF, SSO HWS and SSO HWGRP */
 	req->nixlf = true;
@@ -510,13 +537,13 @@ nix_inl_lf_attach(struct nix_inl_dev *inl_dev)
 
 	rc = mbox_process(dev->mbox);
 	if (rc)
-		return rc;
+		goto exit;
 
 	/* Get MSIX vector offsets */
 	mbox_alloc_msg_msix_offset(mbox);
 	rc = mbox_process_msg(dev->mbox, (void **)&msix_rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	inl_dev->nix_msixoff = msix_rsp->nix_msixoff;
 	inl_dev->ssow_msixoff = msix_rsp->ssow_msixoff[0];
@@ -532,27 +559,33 @@ nix_inl_lf_attach(struct nix_inl_dev *inl_dev)
 	inl_dev->sso_base = dev->bar2 + (RVU_BLOCK_ADDR_SSO << 20);
 	inl_dev->cpt_base = dev->bar2 + (RVU_BLOCK_ADDR_CPT0 << 20);
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
 nix_inl_lf_detach(struct nix_inl_dev *inl_dev)
 {
 	struct dev *dev = &inl_dev->dev;
-	struct mbox *mbox = dev->mbox;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct rsrc_detach_req *req;
 	int rc = -ENOSPC;
 
 	req = mbox_alloc_msg_detach_resources(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->partial = true;
 	req->nixlf = true;
 	req->ssow = true;
 	req->sso = true;
 	req->cptlfs = !!inl_dev->attach_cptlf;
 
-	return mbox_process(dev->mbox);
+	rc = mbox_process(dev->mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
diff --git a/drivers/common/cnxk/roc_nix_mac.c b/drivers/common/cnxk/roc_nix_mac.c
index 36259941c9893..ac30fb52d1f1f 100644
--- a/drivers/common/cnxk/roc_nix_mac.c
+++ b/drivers/common/cnxk/roc_nix_mac.c
@@ -5,82 +5,104 @@
 #include "roc_api.h"
 #include "roc_priv.h"
 
-static inline struct mbox *
-nix_to_mbox(struct nix *nix)
-{
-	struct dev *dev = &nix->dev;
-
-	return dev->mbox;
-}
-
 int
 roc_nix_mac_rxtx_start_stop(struct roc_nix *roc_nix, bool start)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = nix_to_mbox(nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
+	int rc;
 
-	if (roc_nix_is_vf_or_sdp(roc_nix))
-		return NIX_ERR_OP_NOTSUP;
+	if (roc_nix_is_vf_or_sdp(roc_nix)) {
+		rc = NIX_ERR_OP_NOTSUP;
+		goto exit;
+	}
 
 	if (start)
 		mbox_alloc_msg_cgx_start_rxtx(mbox);
 	else
 		mbox_alloc_msg_cgx_stop_rxtx(mbox);
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_mac_link_event_start_stop(struct roc_nix *roc_nix, bool start)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = nix_to_mbox(nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
+	int rc;
 
-	if (roc_nix_is_vf_or_sdp(roc_nix))
-		return NIX_ERR_OP_NOTSUP;
+	if (roc_nix_is_vf_or_sdp(roc_nix)) {
+		rc = NIX_ERR_OP_NOTSUP;
+		goto exit;
+	}
 
 	if (start)
 		mbox_alloc_msg_cgx_start_linkevents(mbox);
 	else
 		mbox_alloc_msg_cgx_stop_linkevents(mbox);
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_mac_loopback_enable(struct roc_nix *roc_nix, bool enable)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = nix_to_mbox(nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
+	int rc;
 
-	if (enable && roc_nix_is_vf_or_sdp(roc_nix))
-		return NIX_ERR_OP_NOTSUP;
+	if (enable && roc_nix_is_vf_or_sdp(roc_nix)) {
+		rc = NIX_ERR_OP_NOTSUP;
+		goto exit;
+	}
 
 	if (enable)
 		mbox_alloc_msg_cgx_intlbk_enable(mbox);
 	else
 		mbox_alloc_msg_cgx_intlbk_disable(mbox);
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_mac_addr_set(struct roc_nix *roc_nix, const uint8_t addr[])
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = nix_to_mbox(nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct cgx_mac_addr_set_or_get *req;
+	int rc;
 
-	if (roc_nix_is_vf_or_sdp(roc_nix))
-		return NIX_ERR_OP_NOTSUP;
+	if (roc_nix_is_vf_or_sdp(roc_nix)) {
+		rc = NIX_ERR_OP_NOTSUP;
+		goto exit;
+	}
 
-	if (dev_active_vfs(&nix->dev))
-		return NIX_ERR_OP_NOTSUP;
+	if (dev_active_vfs(&nix->dev)) {
+		rc = NIX_ERR_OP_NOTSUP;
+		goto exit;
+	}
 
 	req = mbox_alloc_msg_cgx_mac_addr_set(mbox);
 	mbox_memcpy(req->mac_addr, addr, PLT_ETHER_ADDR_LEN);
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -88,79 +110,106 @@ roc_nix_mac_max_entries_get(struct roc_nix *roc_nix)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
 	struct cgx_max_dmac_entries_get_rsp *rsp;
-	struct mbox *mbox = nix_to_mbox(nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int rc;
 
-	if (roc_nix_is_vf_or_sdp(roc_nix))
-		return NIX_ERR_OP_NOTSUP;
+	if (roc_nix_is_vf_or_sdp(roc_nix)) {
+		rc = NIX_ERR_OP_NOTSUP;
+		goto exit;
+	}
 
 	mbox_alloc_msg_cgx_mac_max_entries_get(mbox);
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
-	return rsp->max_dmac_filters ? rsp->max_dmac_filters : 1;
+	rc = rsp->max_dmac_filters ? rsp->max_dmac_filters : 1;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_mac_addr_add(struct roc_nix *roc_nix, uint8_t addr[])
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = nix_to_mbox(nix);
 	struct cgx_mac_addr_add_req *req;
 	struct cgx_mac_addr_add_rsp *rsp;
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int rc;
 
-	if (roc_nix_is_vf_or_sdp(roc_nix))
-		return NIX_ERR_OP_NOTSUP;
+	if (roc_nix_is_vf_or_sdp(roc_nix)) {
+		rc = NIX_ERR_OP_NOTSUP;
+		goto exit;
+	}
 
-	if (dev_active_vfs(&nix->dev))
-		return NIX_ERR_OP_NOTSUP;
+	if (dev_active_vfs(&nix->dev)) {
+		rc = NIX_ERR_OP_NOTSUP;
+		goto exit;
+	}
 
 	req = mbox_alloc_msg_cgx_mac_addr_add(mbox);
 	mbox_memcpy(req->mac_addr, addr, PLT_ETHER_ADDR_LEN);
 
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc < 0)
-		return rc;
+		goto exit;
 
-	return rsp->index;
+	rc = rsp->index;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_mac_addr_del(struct roc_nix *roc_nix, uint32_t index)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = nix_to_mbox(nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct cgx_mac_addr_del_req *req;
 	int rc = -ENOSPC;
 
-	if (roc_nix_is_vf_or_sdp(roc_nix))
-		return NIX_ERR_OP_NOTSUP;
+	if (roc_nix_is_vf_or_sdp(roc_nix)) {
+		rc = NIX_ERR_OP_NOTSUP;
+		goto exit;
+	}
 
 	req = mbox_alloc_msg_cgx_mac_addr_del(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->index = index;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_mac_promisc_mode_enable(struct roc_nix *roc_nix, int enable)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = nix_to_mbox(nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
+	int rc;
 
-	if (roc_nix_is_vf_or_sdp(roc_nix))
-		return NIX_ERR_OP_NOTSUP;
+	if (roc_nix_is_vf_or_sdp(roc_nix)) {
+		rc = NIX_ERR_OP_NOTSUP;
+		goto exit;
+	}
 
 	if (enable)
 		mbox_alloc_msg_cgx_promisc_enable(mbox);
 	else
 		mbox_alloc_msg_cgx_promisc_disable(mbox);
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -168,14 +217,15 @@ roc_nix_mac_link_info_get(struct roc_nix *roc_nix,
 			  struct roc_nix_link_info *link_info)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = nix_to_mbox(nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct cgx_link_info_msg *rsp;
 	int rc;
 
 	mbox_alloc_msg_cgx_get_linkinfo(mbox);
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	link_info->status = rsp->link_info.link_up;
 	link_info->full_duplex = rsp->link_info.full_duplex;
@@ -185,22 +235,29 @@ roc_nix_mac_link_info_get(struct roc_nix *roc_nix,
 	link_info->fec = rsp->link_info.fec;
 	link_info->port = rsp->link_info.port;
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_mac_link_state_set(struct roc_nix *roc_nix, uint8_t up)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = nix_to_mbox(nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct cgx_set_link_state_msg *req;
 	int rc = -ENOSPC;
 
 	req = mbox_alloc_msg_cgx_set_link_state(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->enable = up;
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -208,29 +265,37 @@ roc_nix_mac_link_info_set(struct roc_nix *roc_nix,
 			  struct roc_nix_link_info *link_info)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = nix_to_mbox(nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct cgx_set_link_mode_req *req;
 	int rc;
 
 	rc = roc_nix_mac_link_state_set(roc_nix, link_info->status);
 	if (rc)
-		return rc;
+		goto exit;
 
 	req = mbox_alloc_msg_cgx_set_link_mode(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc =  -ENOSPC;
+		goto exit;
+	}
 	req->args.speed = link_info->speed;
 	req->args.duplex = link_info->full_duplex;
 	req->args.an = link_info->autoneg;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
+
 }
 
 int
 roc_nix_mac_mtu_set(struct roc_nix *roc_nix, uint16_t mtu)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = nix_to_mbox(nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_frs_cfg *req;
 	bool sdp_link = false;
 	int rc = -ENOSPC;
@@ -240,25 +305,29 @@ roc_nix_mac_mtu_set(struct roc_nix *roc_nix, uint16_t mtu)
 
 	req = mbox_alloc_msg_nix_set_hw_frs(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->maxlen = mtu;
 	req->update_smq = true;
 	req->sdp_link = sdp_link;
 
 	rc = mbox_process(mbox);
 	if (rc)
-		return rc;
+		goto exit;
 
 	/* Save MTU for later use */
 	nix->mtu = mtu;
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_mac_max_rx_len_set(struct roc_nix *roc_nix, uint16_t maxlen)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = nix_to_mbox(nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_frs_cfg *req;
 	bool sdp_link = false;
 	int rc = -ENOSPC;
@@ -268,11 +337,14 @@ roc_nix_mac_max_rx_len_set(struct roc_nix *roc_nix, uint16_t maxlen)
 
 	req = mbox_alloc_msg_nix_set_hw_frs(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->sdp_link = sdp_link;
 	req->maxlen = maxlen;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
diff --git a/drivers/common/cnxk/roc_nix_mcast.c b/drivers/common/cnxk/roc_nix_mcast.c
index 87d083ebb312d..3d741112742c9 100644
--- a/drivers/common/cnxk/roc_nix_mcast.c
+++ b/drivers/common/cnxk/roc_nix_mcast.c
@@ -5,53 +5,54 @@
 #include "roc_api.h"
 #include "roc_priv.h"
 
-static inline struct mbox *
-get_mbox(struct roc_nix *roc_nix)
-{
-	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct dev *dev = &nix->dev;
-
-	return dev->mbox;
-}
-
 int
 roc_nix_mcast_mcam_entry_alloc(struct roc_nix *roc_nix, uint16_t nb_entries,
 			       uint8_t priority, uint16_t index[])
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct npc_mcam_alloc_entry_req *req;
 	struct npc_mcam_alloc_entry_rsp *rsp;
 	int rc = -ENOSPC, i;
 
 	req = mbox_alloc_msg_npc_mcam_alloc_entry(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->priority = priority;
 	req->count = nb_entries;
 
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	for (i = 0; i < rsp->count; i++)
 		index[i] = rsp->entry_list[i];
 
-	return rsp->count;
+	rc = rsp->count;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_mcast_mcam_entry_free(struct roc_nix *roc_nix, uint32_t index)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct npc_mcam_free_entry_req *req;
 	int rc = -ENOSPC;
 
 	req = mbox_alloc_msg_npc_mcam_free_entry(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->entry = index;
 
-	return mbox_process_msg(mbox, NULL);
+	rc = mbox_process_msg(mbox, NULL);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -59,20 +60,25 @@ roc_nix_mcast_mcam_entry_write(struct roc_nix *roc_nix,
 			       struct mcam_entry *entry, uint32_t index,
 			       uint8_t intf, uint64_t action)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct npc_mcam_write_entry_req *req;
 	int rc = -ENOSPC;
 
 	req = mbox_alloc_msg_npc_mcam_write_entry(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->entry = index;
 	req->intf = intf;
 	req->enable_entry = true;
 	mbox_memcpy(&req->entry_data, entry, sizeof(struct mcam_entry));
 	req->entry_data.action = action;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -80,19 +86,24 @@ roc_nix_mcast_mcam_entry_ena_dis(struct roc_nix *roc_nix, uint32_t index,
 				 bool enable)
 {
 	struct npc_mcam_ena_dis_entry_req *req;
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int rc = -ENOSPC;
 
 	if (enable) {
 		req = mbox_alloc_msg_npc_mcam_ena_entry(mbox);
 		if (req == NULL)
-			return rc;
+			goto exit;
 	} else {
 		req = mbox_alloc_msg_npc_mcam_dis_entry(mbox);
 		if (req == NULL)
-			return rc;
+			goto exit;
 	}
 
 	req->entry = index;
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
diff --git a/drivers/common/cnxk/roc_nix_npc.c b/drivers/common/cnxk/roc_nix_npc.c
index ad8839dde8330..8c4a5753ee0aa 100644
--- a/drivers/common/cnxk/roc_nix_npc.c
+++ b/drivers/common/cnxk/roc_nix_npc.c
@@ -5,66 +5,76 @@
 #include "roc_api.h"
 #include "roc_priv.h"
 
-static inline struct mbox *
-get_mbox(struct roc_nix *roc_nix)
-{
-	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct dev *dev = &nix->dev;
-
-	return dev->mbox;
-}
-
 int
 roc_nix_npc_promisc_ena_dis(struct roc_nix *roc_nix, int enable)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_rx_mode *req;
 	int rc = -ENOSPC;
 
-	if (roc_nix_is_vf_or_sdp(roc_nix))
-		return NIX_ERR_PARAM;
+	if (roc_nix_is_vf_or_sdp(roc_nix)) {
+		rc = NIX_ERR_PARAM;
+		goto exit;
+	}
 
 	req = mbox_alloc_msg_nix_set_rx_mode(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 
 	if (enable)
 		req->mode = NIX_RX_MODE_UCAST | NIX_RX_MODE_PROMISC;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_npc_mac_addr_set(struct roc_nix *roc_nix, uint8_t addr[])
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_set_mac_addr *req;
+	int rc;
 
 	req = mbox_alloc_msg_nix_set_mac_addr(mbox);
 	mbox_memcpy(req->mac_addr, addr, PLT_ETHER_ADDR_LEN);
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_npc_mac_addr_get(struct roc_nix *roc_nix, uint8_t *addr)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_get_mac_addr_rsp *rsp;
 	int rc;
 
 	mbox_alloc_msg_nix_get_mac_addr(mbox);
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	mbox_memcpy(addr, rsp->mac_addr, PLT_ETHER_ADDR_LEN);
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_npc_rx_ena_dis(struct roc_nix *roc_nix, bool enable)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int rc;
 
 	if (enable)
@@ -75,6 +85,8 @@ roc_nix_npc_rx_ena_dis(struct roc_nix *roc_nix, bool enable)
 	rc = mbox_process(mbox);
 	if (!rc)
 		roc_nix->io_enabled = enable;
+
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -83,21 +95,28 @@ roc_nix_npc_mcast_config(struct roc_nix *roc_nix, bool mcast_enable,
 			 bool prom_enable)
 
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_rx_mode *req;
 	int rc = -ENOSPC;
 
-	if (roc_nix_is_vf_or_sdp(roc_nix))
-		return 0;
+	if (roc_nix_is_vf_or_sdp(roc_nix)) {
+		rc = 0;
+		goto exit;
+	}
 
 	req = mbox_alloc_msg_nix_set_rx_mode(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 
 	if (mcast_enable)
 		req->mode = NIX_RX_MODE_ALLMULTI;
 	if (prom_enable)
 		req->mode = NIX_RX_MODE_PROMISC;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
diff --git a/drivers/common/cnxk/roc_nix_ops.c b/drivers/common/cnxk/roc_nix_ops.c
index 8d3cddf2a69de..fc7a955fc114a 100644
--- a/drivers/common/cnxk/roc_nix_ops.c
+++ b/drivers/common/cnxk/roc_nix_ops.c
@@ -5,15 +5,6 @@
 #include "roc_api.h"
 #include "roc_priv.h"
 
-static inline struct mbox *
-get_mbox(struct roc_nix *roc_nix)
-{
-	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct dev *dev = &nix->dev;
-
-	return dev->mbox;
-}
-
 static void
 nix_lso_tcp(struct nix_lso_format_cfg *req, bool v4)
 {
@@ -172,17 +163,21 @@ int
 roc_nix_lso_custom_fmt_setup(struct roc_nix *roc_nix,
 			     struct nix_lso_format *fields, uint16_t nb_fields)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_lso_format_cfg_rsp *rsp;
 	struct nix_lso_format_cfg *req;
 	int rc = -ENOSPC;
 
-	if (nb_fields > NIX_LSO_FIELD_MAX)
-		return -EINVAL;
+	if (nb_fields > NIX_LSO_FIELD_MAX) {
+		rc = -EINVAL;
+		goto exit;
+	}
 
 	req = mbox_alloc_msg_nix_lso_format_cfg(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 
 	req->field_mask = NIX_LSO_FIELD_MASK;
 	mbox_memcpy(req->fields, fields,
@@ -190,17 +185,21 @@ roc_nix_lso_custom_fmt_setup(struct roc_nix *roc_nix,
 
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	plt_nix_dbg("Setup custom format %u", rsp->lso_format_idx);
-	return rsp->lso_format_idx;
+	rc = rsp->lso_format_idx;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_lso_fmt_setup(struct roc_nix *roc_nix)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_lso_format_cfg_rsp *rsp;
 	struct nix_lso_format_cfg *req;
 	int rc = -ENOSPC;
@@ -210,14 +209,16 @@ roc_nix_lso_fmt_setup(struct roc_nix *roc_nix)
 	 */
 	req = mbox_alloc_msg_nix_lso_format_cfg(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	nix_lso_tcp(req, true);
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
-	if (rsp->lso_format_idx != NIX_LSO_FORMAT_IDX_TSOV4)
-		return NIX_ERR_INTERNAL;
+	if (rsp->lso_format_idx != NIX_LSO_FORMAT_IDX_TSOV4) {
+		rc = NIX_ERR_INTERNAL;
+		goto exit;
+	}
 
 	plt_nix_dbg("tcpv4 lso fmt=%u\n", rsp->lso_format_idx);
 
@@ -225,15 +226,19 @@ roc_nix_lso_fmt_setup(struct roc_nix *roc_nix)
 	 * IPv6/TCP LSO
 	 */
 	req = mbox_alloc_msg_nix_lso_format_cfg(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc =  -ENOSPC;
+		goto exit;
+	}
 	nix_lso_tcp(req, false);
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
-	if (rsp->lso_format_idx != NIX_LSO_FORMAT_IDX_TSOV6)
-		return NIX_ERR_INTERNAL;
+	if (rsp->lso_format_idx != NIX_LSO_FORMAT_IDX_TSOV6) {
+		rc = NIX_ERR_INTERNAL;
+		goto exit;
+	}
 
 	plt_nix_dbg("tcpv6 lso fmt=%u\n", rsp->lso_format_idx);
 
@@ -241,12 +246,14 @@ roc_nix_lso_fmt_setup(struct roc_nix *roc_nix)
 	 * IPv4/UDP/TUN HDR/IPv4/TCP LSO
 	 */
 	req = mbox_alloc_msg_nix_lso_format_cfg(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc =  -ENOSPC;
+		goto exit;
+	}
 	nix_lso_udp_tun_tcp(req, true, true);
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	nix->lso_udp_tun_idx[ROC_NIX_LSO_TUN_V4V4] = rsp->lso_format_idx;
 	plt_nix_dbg("udp tun v4v4 fmt=%u\n", rsp->lso_format_idx);
@@ -255,12 +262,14 @@ roc_nix_lso_fmt_setup(struct roc_nix *roc_nix)
 	 * IPv4/UDP/TUN HDR/IPv6/TCP LSO
 	 */
 	req = mbox_alloc_msg_nix_lso_format_cfg(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc =  -ENOSPC;
+		goto exit;
+	}
 	nix_lso_udp_tun_tcp(req, true, false);
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	nix->lso_udp_tun_idx[ROC_NIX_LSO_TUN_V4V6] = rsp->lso_format_idx;
 	plt_nix_dbg("udp tun v4v6 fmt=%u\n", rsp->lso_format_idx);
@@ -269,12 +278,14 @@ roc_nix_lso_fmt_setup(struct roc_nix *roc_nix)
 	 * IPv6/UDP/TUN HDR/IPv4/TCP LSO
 	 */
 	req = mbox_alloc_msg_nix_lso_format_cfg(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc =  -ENOSPC;
+		goto exit;
+	}
 	nix_lso_udp_tun_tcp(req, false, true);
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	nix->lso_udp_tun_idx[ROC_NIX_LSO_TUN_V6V4] = rsp->lso_format_idx;
 	plt_nix_dbg("udp tun v6v4 fmt=%u\n", rsp->lso_format_idx);
@@ -283,12 +294,14 @@ roc_nix_lso_fmt_setup(struct roc_nix *roc_nix)
 	 * IPv6/UDP/TUN HDR/IPv6/TCP LSO
 	 */
 	req = mbox_alloc_msg_nix_lso_format_cfg(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc =  -ENOSPC;
+		goto exit;
+	}
 	nix_lso_udp_tun_tcp(req, false, false);
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	nix->lso_udp_tun_idx[ROC_NIX_LSO_TUN_V6V6] = rsp->lso_format_idx;
 	plt_nix_dbg("udp tun v6v6 fmt=%u\n", rsp->lso_format_idx);
@@ -297,12 +310,14 @@ roc_nix_lso_fmt_setup(struct roc_nix *roc_nix)
 	 * IPv4/TUN HDR/IPv4/TCP LSO
 	 */
 	req = mbox_alloc_msg_nix_lso_format_cfg(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc =  -ENOSPC;
+		goto exit;
+	}
 	nix_lso_tun_tcp(req, true, true);
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	nix->lso_tun_idx[ROC_NIX_LSO_TUN_V4V4] = rsp->lso_format_idx;
 	plt_nix_dbg("tun v4v4 fmt=%u\n", rsp->lso_format_idx);
@@ -311,12 +326,14 @@ roc_nix_lso_fmt_setup(struct roc_nix *roc_nix)
 	 * IPv4/TUN HDR/IPv6/TCP LSO
 	 */
 	req = mbox_alloc_msg_nix_lso_format_cfg(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc =  -ENOSPC;
+		goto exit;
+	}
 	nix_lso_tun_tcp(req, true, false);
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	nix->lso_tun_idx[ROC_NIX_LSO_TUN_V4V6] = rsp->lso_format_idx;
 	plt_nix_dbg("tun v4v6 fmt=%u\n", rsp->lso_format_idx);
@@ -325,12 +342,14 @@ roc_nix_lso_fmt_setup(struct roc_nix *roc_nix)
 	 * IPv6/TUN HDR/IPv4/TCP LSO
 	 */
 	req = mbox_alloc_msg_nix_lso_format_cfg(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc =  -ENOSPC;
+		goto exit;
+	}
 	nix_lso_tun_tcp(req, false, true);
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	nix->lso_tun_idx[ROC_NIX_LSO_TUN_V6V4] = rsp->lso_format_idx;
 	plt_nix_dbg("tun v6v4 fmt=%u\n", rsp->lso_format_idx);
@@ -339,16 +358,22 @@ roc_nix_lso_fmt_setup(struct roc_nix *roc_nix)
 	 * IPv6/TUN HDR/IPv6/TCP LSO
 	 */
 	req = mbox_alloc_msg_nix_lso_format_cfg(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc =  -ENOSPC;
+		goto exit;
+	}
+		goto exit;
 	nix_lso_tun_tcp(req, false, false);
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	nix->lso_tun_idx[ROC_NIX_LSO_TUN_V6V6] = rsp->lso_format_idx;
 	plt_nix_dbg("tun v6v6 fmt=%u\n", rsp->lso_format_idx);
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -369,7 +394,9 @@ roc_nix_switch_hdr_set(struct roc_nix *roc_nix, uint64_t switch_header_type,
 		       uint8_t pre_l2_size_offset_mask,
 		       uint8_t pre_l2_size_shift_dir)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct npc_set_pkind *req;
 	struct msg_resp *rsp;
 	int rc = -ENOSPC;
@@ -386,24 +413,27 @@ roc_nix_switch_hdr_set(struct roc_nix *roc_nix, uint64_t switch_header_type,
 	    switch_header_type != ROC_PRIV_FLAGS_PRE_L2 &&
 	    switch_header_type != ROC_PRIV_FLAGS_CUSTOM) {
 		plt_err("switch header type is not supported");
-		return NIX_ERR_PARAM;
+		rc = NIX_ERR_PARAM;
+		goto exit;
 	}
 
 	if (switch_header_type == ROC_PRIV_FLAGS_LEN_90B &&
 	    !roc_nix_is_sdp(roc_nix)) {
 		plt_err("chlen90b is not supported on non-SDP device");
-		return NIX_ERR_PARAM;
+		rc = NIX_ERR_PARAM;
+		goto exit;
 	}
 
 	if (switch_header_type == ROC_PRIV_FLAGS_HIGIG &&
 	    roc_nix_is_vf_or_sdp(roc_nix)) {
 		plt_err("higig2 is supported on PF devices only");
-		return NIX_ERR_PARAM;
+		rc = NIX_ERR_PARAM;
+		goto exit;
 	}
 
 	req = mbox_alloc_msg_npc_set_pkind(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->mode = switch_header_type;
 
 	if (switch_header_type == ROC_PRIV_FLAGS_LEN_90B) {
@@ -426,56 +456,70 @@ roc_nix_switch_hdr_set(struct roc_nix *roc_nix, uint64_t switch_header_type,
 	req->dir = PKIND_RX;
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	req = mbox_alloc_msg_npc_set_pkind(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 	req->mode = switch_header_type;
 	req->dir = PKIND_TX;
-	return mbox_process_msg(mbox, (void *)&rsp);
+	rc = mbox_process_msg(mbox, (void *)&rsp);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_eeprom_info_get(struct roc_nix *roc_nix,
 			struct roc_nix_eeprom_info *info)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct cgx_fw_data *rsp = NULL;
 	int rc;
 
 	if (!info) {
 		plt_err("Input buffer is NULL");
-		return NIX_ERR_PARAM;
+		rc = NIX_ERR_PARAM;
+		goto exit;
 	}
 
 	mbox_alloc_msg_cgx_get_aux_link_info(mbox);
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc) {
 		plt_err("Failed to get fw data: %d", rc);
-		return rc;
+		goto exit;
 	}
 
 	info->sff_id = rsp->fwdata.sfp_eeprom.sff_id;
 	mbox_memcpy(info->buf, rsp->fwdata.sfp_eeprom.buf, SFP_EEPROM_SIZE);
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_rx_drop_re_set(struct roc_nix *roc_nix, bool ena)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_rx_cfg *req;
 	int rc = -EIO;
 
 	/* No-op if no change */
-	if (ena == !!(nix->rx_cfg & ROC_NIX_LF_RX_CFG_DROP_RE))
-		return 0;
+	if (ena == !!(nix->rx_cfg & ROC_NIX_LF_RX_CFG_DROP_RE)) {
+		rc = 0;
+		goto exit;
+	}
 
 	req = mbox_alloc_msg_nix_set_rx_cfg(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 
 	if (ena)
 		req->len_verify |= NIX_RX_DROP_RE;
@@ -491,11 +535,14 @@ roc_nix_rx_drop_re_set(struct roc_nix *roc_nix, bool ena)
 
 	rc = mbox_process(mbox);
 	if (rc)
-		return rc;
+		goto exit;
 
 	if (ena)
 		nix->rx_cfg |= ROC_NIX_LF_RX_CFG_DROP_RE;
 	else
 		nix->rx_cfg &= ~ROC_NIX_LF_RX_CFG_DROP_RE;
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
diff --git a/drivers/common/cnxk/roc_nix_ptp.c b/drivers/common/cnxk/roc_nix_ptp.c
index 05e4211de9e72..187e6c8d4f6a3 100644
--- a/drivers/common/cnxk/roc_nix_ptp.c
+++ b/drivers/common/cnxk/roc_nix_ptp.c
@@ -7,64 +7,73 @@
 
 #define PTP_FREQ_ADJUST (1 << 9)
 
-static inline struct mbox *
-get_mbox(struct roc_nix *roc_nix)
-{
-	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct dev *dev = &nix->dev;
-
-	return dev->mbox;
-}
-
 int
 roc_nix_ptp_rx_ena_dis(struct roc_nix *roc_nix, int enable)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
+	int rc;
 
-	if (roc_nix_is_vf_or_sdp(roc_nix) || roc_nix_is_lbk(roc_nix))
-		return NIX_ERR_PARAM;
+	if (roc_nix_is_vf_or_sdp(roc_nix) || roc_nix_is_lbk(roc_nix)) {
+		rc = NIX_ERR_PARAM;
+		goto exit;
+	}
 
 	if (enable)
 		mbox_alloc_msg_cgx_ptp_rx_enable(mbox);
 	else
 		mbox_alloc_msg_cgx_ptp_rx_disable(mbox);
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_ptp_tx_ena_dis(struct roc_nix *roc_nix, int enable)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
+	int rc;
 
-	if (roc_nix_is_vf_or_sdp(roc_nix) || roc_nix_is_lbk(roc_nix))
-		return NIX_ERR_PARAM;
+	if (roc_nix_is_vf_or_sdp(roc_nix) || roc_nix_is_lbk(roc_nix)) {
+		rc = NIX_ERR_PARAM;
+		goto exit;
+	}
 
 	if (enable)
 		mbox_alloc_msg_nix_lf_ptp_tx_enable(mbox);
 	else
 		mbox_alloc_msg_nix_lf_ptp_tx_disable(mbox);
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_ptp_clock_read(struct roc_nix *roc_nix, uint64_t *clock, uint64_t *tsc,
 		       uint8_t is_pmu)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct ptp_req *req;
 	struct ptp_rsp *rsp;
 	int rc = -ENOSPC;
 
 	req = mbox_alloc_msg_ptp_op(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->op = PTP_OP_GET_CLOCK;
 	req->is_pmu = is_pmu;
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	if (clock)
 		*clock = rsp->clk;
@@ -72,30 +81,42 @@ roc_nix_ptp_clock_read(struct roc_nix *roc_nix, uint64_t *clock, uint64_t *tsc,
 	if (tsc)
 		*tsc = rsp->tsc;
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_ptp_sync_time_adjust(struct roc_nix *roc_nix, int64_t delta)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct ptp_req *req;
 	struct ptp_rsp *rsp;
 	int rc = -ENOSPC;
 
-	if (roc_nix_is_vf_or_sdp(roc_nix) || roc_nix_is_lbk(roc_nix))
-		return NIX_ERR_PARAM;
+	if (roc_nix_is_vf_or_sdp(roc_nix) || roc_nix_is_lbk(roc_nix)) {
+		rc = NIX_ERR_PARAM;
+		goto exit;
+	}
 
-	if ((delta <= -PTP_FREQ_ADJUST) || (delta >= PTP_FREQ_ADJUST))
-		return NIX_ERR_INVALID_RANGE;
+	if ((delta <= -PTP_FREQ_ADJUST) || (delta >= PTP_FREQ_ADJUST)) {
+		rc = NIX_ERR_INVALID_RANGE;
+		goto exit;
+	}
 
 	req = mbox_alloc_msg_ptp_op(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->op = PTP_OP_ADJFINE;
 	req->scaled_ppm = delta;
 
-	return mbox_process_msg(mbox, (void *)&rsp);
+	rc = mbox_process_msg(mbox, (void *)&rsp);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
diff --git a/drivers/common/cnxk/roc_nix_queue.c b/drivers/common/cnxk/roc_nix_queue.c
index 5fad8e45434f3..20a1e7d4d88c1 100644
--- a/drivers/common/cnxk/roc_nix_queue.c
+++ b/drivers/common/cnxk/roc_nix_queue.c
@@ -47,15 +47,18 @@ nix_rq_vwqe_flush(struct roc_nix_rq *rq, uint16_t vwqe_interval)
 int
 nix_rq_ena_dis(struct dev *dev, struct roc_nix_rq *rq, bool enable)
 {
-	struct mbox *mbox = dev->mbox;
+	struct mbox *mbox = mbox_get(dev->mbox);
+	int rc;
 
 	/* Pkts will be dropped silently if RQ is disabled */
 	if (roc_model_is_cn9k()) {
 		struct nix_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_aq_enq(mbox);
-		if (!aq)
-			return -ENOSPC;
+		if (!aq) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		aq->qidx = rq->qid;
 		aq->ctype = NIX_AQ_CTYPE_RQ;
@@ -67,8 +70,10 @@ nix_rq_ena_dis(struct dev *dev, struct roc_nix_rq *rq, bool enable)
 		struct nix_cn10k_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-		if (!aq)
-			return -ENOSPC;
+		if (!aq) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		aq->qidx = rq->qid;
 		aq->ctype = NIX_AQ_CTYPE_RQ;
@@ -78,7 +83,10 @@ nix_rq_ena_dis(struct dev *dev, struct roc_nix_rq *rq, bool enable)
 		aq->rq_mask.ena = ~(aq->rq_mask.ena);
 	}
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -103,7 +111,7 @@ roc_nix_rq_is_sso_enable(struct roc_nix *roc_nix, uint32_t qid)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
 	struct dev *dev = &nix->dev;
-	struct mbox *mbox = dev->mbox;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	bool sso_enable;
 	int rc;
 
@@ -112,15 +120,17 @@ roc_nix_rq_is_sso_enable(struct roc_nix *roc_nix, uint32_t qid)
 		struct nix_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_aq_enq(mbox);
-		if (!aq)
-			return -ENOSPC;
+		if (!aq) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		aq->qidx = qid;
 		aq->ctype = NIX_AQ_CTYPE_RQ;
 		aq->op = NIX_AQ_INSTOP_READ;
 		rc = mbox_process_msg(mbox, (void *)&rsp);
 		if (rc)
-			return rc;
+			goto exit;
 
 		sso_enable = rsp->rq.sso_ena;
 	} else {
@@ -128,8 +138,10 @@ roc_nix_rq_is_sso_enable(struct roc_nix *roc_nix, uint32_t qid)
 		struct nix_cn10k_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-		if (!aq)
-			return -ENOSPC;
+		if (!aq) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		aq->qidx = qid;
 		aq->ctype = NIX_AQ_CTYPE_RQ;
@@ -137,12 +149,15 @@ roc_nix_rq_is_sso_enable(struct roc_nix *roc_nix, uint32_t qid)
 
 		rc = mbox_process_msg(mbox, (void *)&rsp);
 		if (rc)
-			return rc;
+			goto exit;
 
 		sso_enable = rsp->rq.sso_ena;
 	}
 
-	return sso_enable ? true : false;
+	rc = sso_enable ? true : false;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
@@ -170,36 +185,45 @@ nix_rq_aura_buf_type_update(struct roc_nix_rq *rq, bool set)
 		struct nix_aq_enq_rsp *rsp;
 		struct nix_aq_enq_req *aq;
 
-		aq = mbox_alloc_msg_nix_aq_enq(mbox);
-		if (!aq)
+		aq = mbox_alloc_msg_nix_aq_enq(mbox_get(mbox));
+		if (!aq) {
+			mbox_put(mbox);
 			return -ENOSPC;
+		}
 
 		aq->qidx = rq->qid;
 		aq->ctype = NIX_AQ_CTYPE_RQ;
 		aq->op = NIX_AQ_INSTOP_READ;
 		rc = mbox_process_msg(mbox, (void *)&rsp);
-		if (rc)
+		if (rc) {
+			mbox_put(mbox);
 			return rc;
+		}
 
 		/* Get aura handle from aura */
 		lpb_aura = roc_npa_aura_handle_gen(rsp->rq.lpb_aura, aura_base);
 		if (rsp->rq.spb_ena)
 			spb_aura = roc_npa_aura_handle_gen(rsp->rq.spb_aura, aura_base);
+		mbox_put(mbox);
 	} else {
 		struct nix_cn10k_aq_enq_rsp *rsp;
 		struct nix_cn10k_aq_enq_req *aq;
 
-		aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-		if (!aq)
+		aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox_get(mbox));
+		if (!aq) {
+			mbox_put(mbox);
 			return -ENOSPC;
+		}
 
 		aq->qidx = rq->qid;
 		aq->ctype = NIX_AQ_CTYPE_RQ;
 		aq->op = NIX_AQ_INSTOP_READ;
 
 		rc = mbox_process_msg(mbox, (void *)&rsp);
-		if (rc)
+		if (rc) {
+			mbox_put(mbox);
 			return rc;
+		}
 
 		/* Get aura handle from aura */
 		lpb_aura = roc_npa_aura_handle_gen(rsp->rq.lpb_aura, aura_base);
@@ -207,6 +231,8 @@ nix_rq_aura_buf_type_update(struct roc_nix_rq *rq, bool set)
 			spb_aura = roc_npa_aura_handle_gen(rsp->rq.spb_aura, aura_base);
 		if (rsp->rq.vwqe_ena)
 			vwqe_aura = roc_npa_aura_handle_gen(rsp->rq.wqe_aura, aura_base);
+
+		mbox_put(mbox);
 	}
 
 skip_ctx_read:
@@ -238,12 +264,15 @@ nix_rq_aura_buf_type_update(struct roc_nix_rq *rq, bool set)
 static int
 nix_rq_cn9k_cman_cfg(struct dev *dev, struct roc_nix_rq *rq)
 {
-	struct mbox *mbox = dev->mbox;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_aq_enq_req *aq;
+	int rc;
 
 	aq = mbox_alloc_msg_nix_aq_enq(mbox);
-	if (!aq)
-		return -ENOSPC;
+	if (!aq) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	aq->qidx = rq->qid;
 	aq->ctype = NIX_AQ_CTYPE_RQ;
@@ -272,7 +301,10 @@ nix_rq_cn9k_cman_cfg(struct dev *dev, struct roc_nix_rq *rq)
 		aq->rq_mask.xqe_pass = ~(aq->rq_mask.xqe_pass);
 	}
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -573,11 +605,14 @@ static int
 nix_rq_cman_cfg(struct dev *dev, struct roc_nix_rq *rq)
 {
 	struct nix_cn10k_aq_enq_req *aq;
-	struct mbox *mbox = dev->mbox;
+	struct mbox *mbox = mbox_get(dev->mbox);
+	int rc;
 
 	aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-	if (!aq)
-		return -ENOSPC;
+	if (!aq) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	aq->qidx = rq->qid;
 	aq->ctype = NIX_AQ_CTYPE_RQ;
@@ -606,23 +641,30 @@ nix_rq_cman_cfg(struct dev *dev, struct roc_nix_rq *rq)
 		aq->rq_mask.xqe_pass = ~(aq->rq_mask.xqe_pass);
 	}
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_rq_init(struct roc_nix *roc_nix, struct roc_nix_rq *rq, bool ena)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	bool is_cn9k = roc_model_is_cn9k();
 	struct dev *dev = &nix->dev;
 	int rc;
 
-	if (roc_nix == NULL || rq == NULL)
+	if (roc_nix == NULL || rq == NULL) {
+		mbox_put(mbox);
 		return NIX_ERR_PARAM;
+	}
 
-	if (rq->qid >= nix->nb_rx_queues)
+	if (rq->qid >= nix->nb_rx_queues) {
+		mbox_put(mbox);
 		return NIX_ERR_QUEUE_INVALID_RANGE;
+	}
 
 	rq->roc_nix = roc_nix;
 
@@ -631,12 +673,17 @@ roc_nix_rq_init(struct roc_nix *roc_nix, struct roc_nix_rq *rq, bool ena)
 	else
 		rc = nix_rq_cfg(dev, rq, nix->qints, false, ena);
 
-	if (rc)
+	if (rc) {
+		mbox_put(mbox);
 		return rc;
+	}
 
 	rc = mbox_process(mbox);
-	if (rc)
+	if (rc) {
+		mbox_put(mbox);
 		return rc;
+	}
+	mbox_put(mbox);
 
 	/* Update aura buf type to indicate its use */
 	nix_rq_aura_buf_type_update(rq, true);
@@ -655,9 +702,10 @@ int
 roc_nix_rq_modify(struct roc_nix *roc_nix, struct roc_nix_rq *rq, bool ena)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *m_box = (&nix->dev)->mbox;
 	bool is_cn9k = roc_model_is_cn9k();
 	struct dev *dev = &nix->dev;
+	struct mbox *mbox;
 	int rc;
 
 	if (roc_nix == NULL || rq == NULL)
@@ -671,17 +719,23 @@ roc_nix_rq_modify(struct roc_nix *roc_nix, struct roc_nix_rq *rq, bool ena)
 
 	rq->roc_nix = roc_nix;
 
+	mbox = mbox_get(m_box);
 	if (is_cn9k)
 		rc = nix_rq_cn9k_cfg(dev, rq, nix->qints, true, ena);
 	else
 		rc = nix_rq_cfg(dev, rq, nix->qints, true, ena);
 
-	if (rc)
+	if (rc) {
+		mbox_put(mbox);
 		return rc;
+	}
 
 	rc = mbox_process(mbox);
-	if (rc)
+	if (rc) {
+		mbox_put(mbox);
 		return rc;
+	}
+	mbox_put(mbox);
 
 	/* Update aura attribute to indicate its use */
 	nix_rq_aura_buf_type_update(rq, true);
@@ -771,9 +825,11 @@ roc_nix_cq_init(struct roc_nix *roc_nix, struct roc_nix_cq *cq)
 	if (roc_model_is_cn9k()) {
 		struct nix_aq_enq_req *aq;
 
-		aq = mbox_alloc_msg_nix_aq_enq(mbox);
-		if (!aq)
+		aq = mbox_alloc_msg_nix_aq_enq(mbox_get(mbox));
+		if (!aq) {
+			mbox_put(mbox);
 			return -ENOSPC;
+		}
 
 		aq->qidx = cq->qid;
 		aq->ctype = NIX_AQ_CTYPE_CQ;
@@ -782,9 +838,11 @@ roc_nix_cq_init(struct roc_nix *roc_nix, struct roc_nix_cq *cq)
 	} else {
 		struct nix_cn10k_aq_enq_req *aq;
 
-		aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-		if (!aq)
+		aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox_get(mbox));
+		if (!aq) {
+			mbox_put(mbox);
 			return -ENOSPC;
+		}
 
 		aq->qidx = cq->qid;
 		aq->ctype = NIX_AQ_CTYPE_CQ;
@@ -843,6 +901,7 @@ roc_nix_cq_init(struct roc_nix *roc_nix, struct roc_nix_cq *cq)
 	}
 
 	rc = mbox_process(mbox);
+	mbox_put(mbox);
 	if (rc)
 		goto free_mem;
 
@@ -865,15 +924,17 @@ roc_nix_cq_fini(struct roc_nix_cq *cq)
 		return NIX_ERR_PARAM;
 
 	nix = roc_nix_to_nix_priv(cq->roc_nix);
-	mbox = (&nix->dev)->mbox;
+	mbox = mbox_get((&nix->dev)->mbox);
 
 	/* Disable CQ */
 	if (roc_model_is_cn9k()) {
 		struct nix_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_aq_enq(mbox);
-		if (!aq)
+		if (!aq) {
+			mbox_put(mbox);
 			return -ENOSPC;
+		}
 
 		aq->qidx = cq->qid;
 		aq->ctype = NIX_AQ_CTYPE_CQ;
@@ -886,8 +947,10 @@ roc_nix_cq_fini(struct roc_nix_cq *cq)
 		struct nix_cn10k_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-		if (!aq)
+		if (!aq) {
+			mbox_put(mbox);
 			return -ENOSPC;
+		}
 
 		aq->qidx = cq->qid;
 		aq->ctype = NIX_AQ_CTYPE_CQ;
@@ -899,9 +962,12 @@ roc_nix_cq_fini(struct roc_nix_cq *cq)
 	}
 
 	rc = mbox_process(mbox);
-	if (rc)
+	if (rc) {
+		mbox_put(mbox);
 		return rc;
+	}
 
+	mbox_put(mbox);
 	plt_free(cq->desc_base);
 	return 0;
 }
@@ -1043,7 +1109,7 @@ sq_cn9k_init(struct nix *nix, struct roc_nix_sq *sq, uint32_t rr_quantum,
 static int
 sq_cn9k_fini(struct nix *nix, struct roc_nix_sq *sq)
 {
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	struct nix_aq_enq_rsp *rsp;
 	struct nix_aq_enq_req *aq;
 	uint16_t sqes_per_sqb;
@@ -1051,24 +1117,32 @@ sq_cn9k_fini(struct nix *nix, struct roc_nix_sq *sq)
 	int rc, count;
 
 	aq = mbox_alloc_msg_nix_aq_enq(mbox);
-	if (!aq)
+	if (!aq) {
+		mbox_put(mbox);
 		return -ENOSPC;
+	}
 
 	aq->qidx = sq->qid;
 	aq->ctype = NIX_AQ_CTYPE_SQ;
 	aq->op = NIX_AQ_INSTOP_READ;
 	rc = mbox_process_msg(mbox, (void *)&rsp);
-	if (rc)
+	if (rc) {
+		mbox_put(mbox);
 		return rc;
+	}
 
 	/* Check if sq is already cleaned up */
-	if (!rsp->sq.ena)
+	if (!rsp->sq.ena) {
+		mbox_put(mbox);
 		return 0;
+	}
 
 	/* Disable sq */
 	aq = mbox_alloc_msg_nix_aq_enq(mbox);
-	if (!aq)
+	if (!aq) {
+		mbox_put(mbox);
 		return -ENOSPC;
+	}
 
 	aq->qidx = sq->qid;
 	aq->ctype = NIX_AQ_CTYPE_SQ;
@@ -1076,20 +1150,26 @@ sq_cn9k_fini(struct nix *nix, struct roc_nix_sq *sq)
 	aq->sq_mask.ena = ~aq->sq_mask.ena;
 	aq->sq.ena = 0;
 	rc = mbox_process(mbox);
-	if (rc)
+	if (rc) {
+		mbox_put(mbox);
 		return rc;
+	}
 
 	/* Read SQ and free sqb's */
 	aq = mbox_alloc_msg_nix_aq_enq(mbox);
-	if (!aq)
+	if (!aq) {
+		mbox_put(mbox);
 		return -ENOSPC;
+	}
 
 	aq->qidx = sq->qid;
 	aq->ctype = NIX_AQ_CTYPE_SQ;
 	aq->op = NIX_AQ_INSTOP_READ;
 	rc = mbox_process_msg(mbox, (void *)&rsp);
-	if (rc)
+	if (rc) {
+		mbox_put(mbox);
 		return rc;
+	}
 
 	if (aq->sq.smq_pend)
 		plt_err("SQ has pending SQE's");
@@ -1111,6 +1191,7 @@ sq_cn9k_fini(struct nix *nix, struct roc_nix_sq *sq)
 	/* Free next to use sqb */
 	if (rsp->sq.next_sqb)
 		roc_npa_aura_op_free(sq->aura_handle, 1, rsp->sq.next_sqb);
+	mbox_put(mbox);
 	return 0;
 }
 
@@ -1159,7 +1240,7 @@ sq_init(struct nix *nix, struct roc_nix_sq *sq, uint32_t rr_quantum,
 static int
 sq_fini(struct nix *nix, struct roc_nix_sq *sq)
 {
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	struct nix_cn10k_aq_enq_rsp *rsp;
 	struct nix_cn10k_aq_enq_req *aq;
 	uint16_t sqes_per_sqb;
@@ -1167,24 +1248,32 @@ sq_fini(struct nix *nix, struct roc_nix_sq *sq)
 	int rc, count;
 
 	aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-	if (!aq)
+	if (!aq) {
+		mbox_put(mbox);
 		return -ENOSPC;
+	}
 
 	aq->qidx = sq->qid;
 	aq->ctype = NIX_AQ_CTYPE_SQ;
 	aq->op = NIX_AQ_INSTOP_READ;
 	rc = mbox_process_msg(mbox, (void *)&rsp);
-	if (rc)
+	if (rc) {
+		mbox_put(mbox);
 		return rc;
+	}
 
 	/* Check if sq is already cleaned up */
-	if (!rsp->sq.ena)
+	if (!rsp->sq.ena) {
+		mbox_put(mbox);
 		return 0;
+	}
 
 	/* Disable sq */
 	aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-	if (!aq)
+	if (!aq) {
+		mbox_put(mbox);
 		return -ENOSPC;
+	}
 
 	aq->qidx = sq->qid;
 	aq->ctype = NIX_AQ_CTYPE_SQ;
@@ -1192,20 +1281,26 @@ sq_fini(struct nix *nix, struct roc_nix_sq *sq)
 	aq->sq_mask.ena = ~aq->sq_mask.ena;
 	aq->sq.ena = 0;
 	rc = mbox_process(mbox);
-	if (rc)
+	if (rc) {
+		mbox_put(mbox);
 		return rc;
+	}
 
 	/* Read SQ and free sqb's */
 	aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-	if (!aq)
+	if (!aq) {
+		mbox_put(mbox);
 		return -ENOSPC;
+	}
 
 	aq->qidx = sq->qid;
 	aq->ctype = NIX_AQ_CTYPE_SQ;
 	aq->op = NIX_AQ_INSTOP_READ;
 	rc = mbox_process_msg(mbox, (void *)&rsp);
-	if (rc)
+	if (rc) {
+		mbox_put(mbox);
 		return rc;
+	}
 
 	if (aq->sq.smq_pend)
 		plt_err("SQ has pending SQE's");
@@ -1227,6 +1322,7 @@ sq_fini(struct nix *nix, struct roc_nix_sq *sq)
 	/* Free next to use sqb */
 	if (rsp->sq.next_sqb)
 		roc_npa_aura_op_free(sq->aura_handle, 1, rsp->sq.next_sqb);
+	mbox_put(mbox);
 	return 0;
 }
 
@@ -1234,9 +1330,10 @@ int
 roc_nix_sq_init(struct roc_nix *roc_nix, struct roc_nix_sq *sq)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *m_box = (&nix->dev)->mbox;
 	uint16_t qid, smq = UINT16_MAX;
 	uint32_t rr_quantum = 0;
+	struct mbox *mbox;
 	int rc;
 
 	if (sq == NULL)
@@ -1268,18 +1365,25 @@ roc_nix_sq_init(struct roc_nix *roc_nix, struct roc_nix_sq *sq)
 		goto nomem;
 	}
 
+	mbox = mbox_get(m_box);
 	/* Init SQ context */
 	if (roc_model_is_cn9k())
 		rc = sq_cn9k_init(nix, sq, rr_quantum, smq);
 	else
 		rc = sq_init(nix, sq, rr_quantum, smq);
 
-	if (rc)
+	if (rc) {
+		mbox_put(mbox);
 		goto nomem;
+	}
+
 
 	rc = mbox_process(mbox);
-	if (rc)
+	if (rc) {
+		mbox_put(mbox);
 		goto nomem;
+	}
+	mbox_put(mbox);
 
 	nix->sqs[qid] = sq;
 	sq->io_addr = nix->base + NIX_LF_OP_SENDX(0);
@@ -1324,12 +1428,15 @@ roc_nix_sq_fini(struct roc_nix_sq *sq)
 		rc |= sq_fini(roc_nix_to_nix_priv(sq->roc_nix), sq);
 
 	/* Sync NDC-NIX-TX for LF */
-	ndc_req = mbox_alloc_msg_ndc_sync_op(mbox);
-	if (ndc_req == NULL)
+	ndc_req = mbox_alloc_msg_ndc_sync_op(mbox_get(mbox));
+	if (ndc_req == NULL) {
+		mbox_put(mbox);
 		return -ENOSPC;
+	}
 	ndc_req->nix_lf_tx_sync = 1;
 	if (mbox_process(mbox))
 		rc |= NIX_ERR_NDC_SYNC;
+	mbox_put(mbox);
 
 	rc |= nix_tm_sq_flush_post(sq);
 
diff --git a/drivers/common/cnxk/roc_nix_rss.c b/drivers/common/cnxk/roc_nix_rss.c
index 7de69aabeb126..3599eb9baef30 100644
--- a/drivers/common/cnxk/roc_nix_rss.c
+++ b/drivers/common/cnxk/roc_nix_rss.c
@@ -54,7 +54,7 @@ static int
 nix_cn9k_rss_reta_set(struct nix *nix, uint8_t group,
 		      uint16_t reta[ROC_NIX_RSS_RETA_MAX], uint8_t lock_rx_ctx)
 {
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	struct nix_aq_enq_req *req;
 	uint16_t idx;
 	int rc;
@@ -67,10 +67,12 @@ nix_cn9k_rss_reta_set(struct nix *nix, uint8_t group,
 			 */
 			rc = mbox_process(mbox);
 			if (rc < 0)
-				return rc;
+				goto exit;
 			req = mbox_alloc_msg_nix_aq_enq(mbox);
-			if (!req)
-				return NIX_ERR_NO_MEM;
+			if (!req) {
+				rc =  NIX_ERR_NO_MEM;
+				goto exit;
+			}
 		}
 		req->rss.rq = reta[idx];
 		/* Fill AQ info */
@@ -88,10 +90,12 @@ nix_cn9k_rss_reta_set(struct nix *nix, uint8_t group,
 			 */
 			rc = mbox_process(mbox);
 			if (rc < 0)
-				return rc;
+				goto exit;
 			req = mbox_alloc_msg_nix_aq_enq(mbox);
-			if (!req)
-				return NIX_ERR_NO_MEM;
+			if (!req) {
+				rc =  NIX_ERR_NO_MEM;
+				goto exit;
+			}
 		}
 		req->rss.rq = reta[idx];
 		/* Fill AQ info */
@@ -102,16 +106,19 @@ nix_cn9k_rss_reta_set(struct nix *nix, uint8_t group,
 
 	rc = mbox_process(mbox);
 	if (rc < 0)
-		return rc;
+		goto exit;
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
 nix_rss_reta_set(struct nix *nix, uint8_t group,
 		 uint16_t reta[ROC_NIX_RSS_RETA_MAX], uint8_t lock_rx_ctx)
 {
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	struct nix_cn10k_aq_enq_req *req;
 	uint16_t idx;
 	int rc;
@@ -124,10 +131,12 @@ nix_rss_reta_set(struct nix *nix, uint8_t group,
 			 */
 			rc = mbox_process(mbox);
 			if (rc < 0)
-				return rc;
+				goto exit;
 			req = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-			if (!req)
-				return NIX_ERR_NO_MEM;
+			if (!req) {
+				rc =  NIX_ERR_NO_MEM;
+				goto exit;
+			}
 		}
 		req->rss.rq = reta[idx];
 		/* Fill AQ info */
@@ -145,10 +154,12 @@ nix_rss_reta_set(struct nix *nix, uint8_t group,
 			 */
 			rc = mbox_process(mbox);
 			if (rc < 0)
-				return rc;
+				goto exit;
 			req = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-			if (!req)
-				return NIX_ERR_NO_MEM;
+			if (!req) {
+				rc =  NIX_ERR_NO_MEM;
+				goto exit;
+			}
 		}
 		req->rss.rq = reta[idx];
 		/* Fill AQ info */
@@ -159,9 +170,12 @@ nix_rss_reta_set(struct nix *nix, uint8_t group,
 
 	rc = mbox_process(mbox);
 	if (rc < 0)
-		return rc;
+		goto exit;
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -205,25 +219,29 @@ roc_nix_rss_flowkey_set(struct roc_nix *roc_nix, uint8_t *alg_idx,
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
 	struct nix_rss_flowkey_cfg_rsp *rss_rsp;
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	struct nix_rss_flowkey_cfg *cfg;
 	int rc = -ENOSPC;
 
-	if (group >= ROC_NIX_RSS_GRPS)
-		return NIX_ERR_PARAM;
+	if (group >= ROC_NIX_RSS_GRPS) {
+		rc = NIX_ERR_PARAM;
+		goto exit;
+	}
 
 	cfg = mbox_alloc_msg_nix_rss_flowkey_cfg(mbox);
 	if (cfg == NULL)
-		return rc;
+		goto exit;
 	cfg->flowkey_cfg = flowkey;
 	cfg->mcam_index = mcam_index; /* -1 indicates default group */
 	cfg->group = group;	      /* 0 is default group */
 	rc = mbox_process_msg(mbox, (void *)&rss_rsp);
 	if (rc)
-		return rc;
+		goto exit;
 	if (alg_idx)
 		*alg_idx = rss_rsp->alg_idx;
 
+exit:
+	mbox_put(mbox);
 	return rc;
 }
 
diff --git a/drivers/common/cnxk/roc_nix_stats.c b/drivers/common/cnxk/roc_nix_stats.c
index 2e5071e1bb8c1..6b5803af84422 100644
--- a/drivers/common/cnxk/roc_nix_stats.c
+++ b/drivers/common/cnxk/roc_nix_stats.c
@@ -65,12 +65,18 @@ int
 roc_nix_stats_reset(struct roc_nix *roc_nix)
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
+	int rc;
 
-	if (mbox_alloc_msg_nix_stats_rst(mbox) == NULL)
-		return -ENOMEM;
+	if (mbox_alloc_msg_nix_stats_rst(mbox) == NULL) {
+		rc = -ENOMEM;
+		goto exit;
+	}
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
@@ -141,15 +147,17 @@ nix_stat_tx_queue_get(struct nix *nix, uint16_t qid,
 static int
 nix_stat_rx_queue_reset(struct nix *nix, uint16_t qid)
 {
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	int rc;
 
 	if (roc_model_is_cn9k()) {
 		struct nix_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_aq_enq(mbox);
-		if (!aq)
-			return -ENOSPC;
+		if (!aq) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		aq->qidx = qid;
 		aq->ctype = NIX_AQ_CTYPE_RQ;
@@ -170,8 +178,10 @@ nix_stat_rx_queue_reset(struct nix *nix, uint16_t qid)
 		struct nix_cn10k_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-		if (!aq)
-			return -ENOSPC;
+		if (!aq) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		aq->qidx = qid;
 		aq->ctype = NIX_AQ_CTYPE_RQ;
@@ -191,21 +201,26 @@ nix_stat_rx_queue_reset(struct nix *nix, uint16_t qid)
 	}
 
 	rc = mbox_process(mbox);
-	return rc ? NIX_ERR_AQ_WRITE_FAILED : 0;
+	rc = rc ? NIX_ERR_AQ_WRITE_FAILED : 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
 nix_stat_tx_queue_reset(struct nix *nix, uint16_t qid)
 {
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	int rc;
 
 	if (roc_model_is_cn9k()) {
 		struct nix_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_aq_enq(mbox);
-		if (!aq)
-			return -ENOSPC;
+		if (!aq) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		aq->qidx = qid;
 		aq->ctype = NIX_AQ_CTYPE_SQ;
@@ -223,8 +238,10 @@ nix_stat_tx_queue_reset(struct nix *nix, uint16_t qid)
 		struct nix_cn10k_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-		if (!aq)
-			return -ENOSPC;
+		if (!aq) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		aq->qidx = qid;
 		aq->ctype = NIX_AQ_CTYPE_SQ;
@@ -243,7 +260,10 @@ nix_stat_tx_queue_reset(struct nix *nix, uint16_t qid)
 	}
 
 	rc = mbox_process(mbox);
-	return rc ? NIX_ERR_AQ_WRITE_FAILED : 0;
+	rc = rc ? NIX_ERR_AQ_WRITE_FAILED : 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -363,15 +383,17 @@ roc_nix_xstats_get(struct roc_nix *roc_nix, struct roc_nix_xstat *xstats,
 		return count;
 
 	if (roc_model_is_cn9k()) {
-		req = mbox_alloc_msg_cgx_stats(mbox);
-		if (!req)
-			return -ENOSPC;
+		req = mbox_alloc_msg_cgx_stats(mbox_get(mbox));
+		if (!req) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		req->hdr.pcifunc = roc_nix_get_pf_func(roc_nix);
 
 		rc = mbox_process_msg(mbox, (void *)&cgx_resp);
 		if (rc)
-			return rc;
+			goto exit;
 
 		for (i = 0; i < roc_nix_num_rx_xstats(); i++) {
 			xstats[count].value =
@@ -387,15 +409,17 @@ roc_nix_xstats_get(struct roc_nix *roc_nix, struct roc_nix_xstat *xstats,
 			count++;
 		}
 	} else {
-		req = mbox_alloc_msg_rpm_stats(mbox);
-		if (!req)
-			return -ENOSPC;
+		req = mbox_alloc_msg_rpm_stats(mbox_get(mbox));
+		if (!req) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		req->hdr.pcifunc = roc_nix_get_pf_func(roc_nix);
 
 		rc = mbox_process_msg(mbox, (void *)&rpm_resp);
 		if (rc)
-			return rc;
+			goto exit;
 
 		for (i = 0; i < roc_nix_num_rx_xstats(); i++) {
 			xstats[count].value =
@@ -412,7 +436,10 @@ roc_nix_xstats_get(struct roc_nix *roc_nix, struct roc_nix_xstat *xstats,
 		}
 	}
 
-	return count;
+	rc = count;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
diff --git a/drivers/common/cnxk/roc_nix_tm.c b/drivers/common/cnxk/roc_nix_tm.c
index 255ca83f489e1..9eb4dfb1fdc4b 100644
--- a/drivers/common/cnxk/roc_nix_tm.c
+++ b/drivers/common/cnxk/roc_nix_tm.c
@@ -52,13 +52,14 @@ nix_tm_node_reg_conf(struct nix *nix, struct nix_tm_node *node)
 	/* Need this trigger to configure TL1 */
 	if (!nix_tm_have_tl1_access(nix) && hw_lvl == NIX_TXSCH_LVL_TL2) {
 		/* Prepare default conf for TL1 */
-		req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+		req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 		req->lvl = NIX_TXSCH_LVL_TL1;
 
 		k = nix_tm_tl1_default_prep(nix, node->parent_hw_id, req->reg,
 					    req->regval);
 		req->num_regs = k;
 		rc = mbox_process(mbox);
+		mbox_put(mbox);
 		if (rc)
 			goto error;
 	}
@@ -76,7 +77,7 @@ nix_tm_node_reg_conf(struct nix *nix, struct nix_tm_node *node)
 		return 0;
 
 	/* Copy and send config mbox */
-	req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+	req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 	req->lvl = hw_lvl;
 	req->num_regs = k;
 
@@ -85,6 +86,7 @@ nix_tm_node_reg_conf(struct nix *nix, struct nix_tm_node *node)
 	mbox_memcpy(req->regval_mask, regval_mask, sizeof(uint64_t) * k);
 
 	rc = mbox_process(mbox);
+	mbox_put(mbox);
 	if (rc)
 		goto error;
 
@@ -279,7 +281,7 @@ nix_tm_node_add(struct roc_nix *roc_nix, struct nix_tm_node *node)
 int
 nix_tm_clear_path_xoff(struct nix *nix, struct nix_tm_node *node)
 {
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	struct nix_txschq_config *req;
 	struct nix_tm_node *p;
 	int rc;
@@ -298,14 +300,17 @@ nix_tm_clear_path_xoff(struct nix *nix, struct nix_tm_node *node)
 							    req->regval);
 			rc = mbox_process(mbox);
 			if (rc)
-				return rc;
+				goto exit;
 
 			p->flags |= NIX_TM_NODE_ENABLED;
 		}
 		p = p->parent;
 	}
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -395,7 +400,7 @@ nix_tm_bp_config_set(struct roc_nix *roc_nix, uint16_t sq, uint16_t tc,
 
 	/* Allocating TL3 resources */
 	if (!req) {
-		req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+		req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 		req->lvl = nix->tm_link_cfg_lvl;
 		k = 0;
 	}
@@ -417,10 +422,13 @@ nix_tm_bp_config_set(struct roc_nix *roc_nix, uint16_t sq, uint16_t tc,
 	if (enable && sq_s->tc == ROC_NIX_PFC_CLASS_INVALID)
 		parent->tc_refcnt++;
 
-	return 0;
+	rc = 0;
+	goto exit;
 err:
 	plt_err("Failed to %s bp on link %u, rc=%d(%s)",
 		enable ? "enable" : "disable", link, rc, roc_error_msg_get(rc));
+exit:
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -430,7 +438,7 @@ nix_tm_bp_config_get(struct roc_nix *roc_nix, bool *is_enabled)
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
 	struct nix_txschq_config *req = NULL, *rsp;
 	enum roc_nix_tm_tree tree = nix->tm_tree;
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	struct nix_tm_node_list *list;
 	struct nix_tm_node *node;
 	bool found = false;
@@ -484,10 +492,13 @@ nix_tm_bp_config_get(struct roc_nix *roc_nix, bool *is_enabled)
 	}
 
 	*is_enabled = found ? !!enable : false;
-	return 0;
+	rc = 0;
+	goto exit;
 err:
 	plt_err("Failed to get bp status on link %u, rc=%d(%s)", link, rc,
 		roc_error_msg_get(rc));
+exit:
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -507,7 +518,7 @@ nix_tm_smq_xoff(struct nix *nix, struct nix_tm_node *node, bool enable)
 	if (rc)
 		return rc;
 
-	req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+	req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 	req->lvl = NIX_TXSCH_LVL_SMQ;
 	req->num_regs = 1;
 
@@ -516,7 +527,9 @@ nix_tm_smq_xoff(struct nix *nix, struct nix_tm_node *node, bool enable)
 	req->regval_mask[0] =
 		enable ? ~(BIT_ULL(50) | BIT_ULL(49)) : ~BIT_ULL(50);
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -677,13 +690,16 @@ roc_nix_tm_sq_free_pending_sqe(struct nix *nix, int q)
 
 	mbox = dev->mbox;
 	/* Sync NDC-NIX-TX for LF */
-	ndc_req = mbox_alloc_msg_ndc_sync_op(mbox);
-	if (ndc_req == NULL)
+	ndc_req = mbox_alloc_msg_ndc_sync_op(mbox_get(mbox));
+	if (ndc_req == NULL) {
+		mbox_put(mbox);
 		return -EFAULT;
+	}
 
 	ndc_req->nix_lf_tx_sync = 1;
 	if (mbox_process(mbox))
 		rc |= NIX_ERR_NDC_SYNC;
+	mbox_put(mbox);
 
 	if (rc)
 		plt_err("NDC_SYNC failed rc %d", rc);
@@ -775,12 +791,14 @@ nix_tm_sq_flush_pre(struct roc_nix_sq *sq)
 		/* Though it enables both RX MCAM Entries and CGX Link
 		 * we assume all the rx queues are stopped way back.
 		 */
-		mbox_alloc_msg_nix_lf_start_rx(mbox);
+		mbox_alloc_msg_nix_lf_start_rx(mbox_get(mbox));
 		rc = mbox_process(mbox);
 		if (rc) {
+			mbox_put(mbox);
 			plt_err("cgx start failed, rc=%d", rc);
 			return rc;
 		}
+		mbox_put(mbox);
 	}
 
 	/* Disable backpressure */
@@ -841,16 +859,20 @@ nix_tm_sq_flush_pre(struct roc_nix_sq *sq)
 		goto cleanup;
 	}
 
-	req = mbox_alloc_msg_nix_rx_sw_sync(mbox);
-	if (!req)
+	req = mbox_alloc_msg_nix_rx_sw_sync(mbox_get(mbox));
+	if (!req) {
+		mbox_put(mbox);
 		return -ENOSPC;
+	}
 
 	rc = mbox_process(mbox);
+	mbox_put(mbox);
 cleanup:
 	/* Restore cgx state */
 	if (!roc_nix->io_enabled) {
-		mbox_alloc_msg_nix_lf_stop_rx(mbox);
+		mbox_alloc_msg_nix_lf_stop_rx(mbox_get(mbox));
 		rc |= mbox_process(mbox);
+		mbox_put(mbox);
 	}
 
 	return rc;
@@ -937,7 +959,7 @@ int
 nix_tm_sq_sched_conf(struct nix *nix, struct nix_tm_node *node,
 		     bool rr_quantum_only)
 {
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	uint16_t qid = node->id, smq;
 	uint64_t rr_quantum;
 	int rc;
@@ -952,15 +974,19 @@ nix_tm_sq_sched_conf(struct nix *nix, struct nix_tm_node *node,
 		plt_tm_dbg("Enabling sq(%u)->smq(%u), rr_quantum 0x%" PRIx64,
 			   qid, smq, rr_quantum);
 
-	if (qid > nix->nb_tx_queues)
-		return -EFAULT;
+	if (qid > nix->nb_tx_queues) {
+		rc = -EFAULT;
+		goto exit;
+	}
 
 	if (roc_model_is_cn9k()) {
 		struct nix_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_aq_enq(mbox);
-		if (!aq)
-			return -ENOSPC;
+		if (!aq) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		aq->qidx = qid;
 		aq->ctype = NIX_AQ_CTYPE_SQ;
@@ -977,8 +1003,10 @@ nix_tm_sq_sched_conf(struct nix *nix, struct nix_tm_node *node,
 		struct nix_cn10k_aq_enq_req *aq;
 
 		aq = mbox_alloc_msg_nix_cn10k_aq_enq(mbox);
-		if (!aq)
-			return -ENOSPC;
+		if (!aq) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 
 		aq->qidx = qid;
 		aq->ctype = NIX_AQ_CTYPE_SQ;
@@ -996,6 +1024,8 @@ nix_tm_sq_sched_conf(struct nix *nix, struct nix_tm_node *node,
 	rc = mbox_process(mbox);
 	if (rc)
 		plt_err("Failed to set smq, rc=%d", rc);
+exit:
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -1037,9 +1067,11 @@ nix_tm_release_resources(struct nix *nix, uint8_t hw_lvl, bool contig,
 		schq += pos;
 
 		/* Free to AF */
-		req = mbox_alloc_msg_nix_txsch_free(mbox);
-		if (req == NULL)
+		req = mbox_alloc_msg_nix_txsch_free(mbox_get(mbox));
+		if (req == NULL) {
+			mbox_put(mbox);
 			return rc;
+		}
 		req->flags = 0;
 		req->schq_lvl = hw_lvl;
 		req->schq = schq;
@@ -1047,8 +1079,10 @@ nix_tm_release_resources(struct nix *nix, uint8_t hw_lvl, bool contig,
 		if (rc) {
 			plt_err("failed to release hwres %s(%u) rc %d",
 				nix_tm_hwlvl2str(hw_lvl), schq, rc);
+			mbox_put(mbox);
 			return rc;
 		}
+		mbox_put(mbox);
 
 		plt_tm_dbg("Released hwres %s(%u)", nix_tm_hwlvl2str(hw_lvl),
 			   schq);
@@ -1067,7 +1101,7 @@ nix_tm_release_resources(struct nix *nix, uint8_t hw_lvl, bool contig,
 int
 nix_tm_free_node_resource(struct nix *nix, struct nix_tm_node *node)
 {
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	struct nix_txsch_free_req *req;
 	struct plt_bitmap *bmp;
 	uint16_t avail, hw_id;
@@ -1093,13 +1127,14 @@ nix_tm_free_node_resource(struct nix *nix, struct nix_tm_node *node)
 		plt_bitmap_set(bmp, hw_id);
 		node->hw_id = NIX_TM_HW_ID_INVALID;
 		node->flags &= ~NIX_TM_NODE_HWRES;
-		return 0;
+		rc = 0;
+		goto exit;
 	}
 
 	/* Free to AF */
 	req = mbox_alloc_msg_nix_txsch_free(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->flags = 0;
 	req->schq_lvl = node->hw_lvl;
 	req->schq = hw_id;
@@ -1107,7 +1142,7 @@ nix_tm_free_node_resource(struct nix *nix, struct nix_tm_node *node)
 	if (rc) {
 		plt_err("failed to release hwres %s(%u) rc %d",
 			nix_tm_hwlvl2str(node->hw_lvl), hw_id, rc);
-		return rc;
+		goto exit;
 	}
 
 	/* Mark parent as dirty for reallocing it's children */
@@ -1118,7 +1153,10 @@ nix_tm_free_node_resource(struct nix *nix, struct nix_tm_node *node)
 	node->flags &= ~NIX_TM_NODE_HWRES;
 	plt_tm_dbg("Released hwres %s(%u) to af",
 		   nix_tm_hwlvl2str(node->hw_lvl), hw_id);
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -1415,8 +1453,9 @@ nix_tm_alloc_txschq(struct nix *nix, enum roc_nix_tm_tree tree)
 	/* Alloc as needed */
 	do {
 		pend = false;
-		req = mbox_alloc_msg_nix_txsch_alloc(mbox);
+		req = mbox_alloc_msg_nix_txsch_alloc(mbox_get(mbox));
 		if (!req) {
+			mbox_put(mbox);
 			rc = -ENOMEM;
 			goto alloc_err;
 		}
@@ -1441,10 +1480,13 @@ nix_tm_alloc_txschq(struct nix *nix, enum roc_nix_tm_tree tree)
 		}
 
 		rc = mbox_process_msg(mbox, (void *)&rsp);
-		if (rc)
+		if (rc) {
+			mbox_put(mbox);
 			goto alloc_err;
+		}
 
 		nix_tm_copy_rsp_to_nix(nix, rsp);
+		mbox_put(mbox);
 	} while (pend);
 
 	nix->tm_link_cfg_lvl = rsp->link_cfg_lvl;
diff --git a/drivers/common/cnxk/roc_nix_tm_mark.c b/drivers/common/cnxk/roc_nix_tm_mark.c
index d37292e8b9bce..e9a7604e798d0 100644
--- a/drivers/common/cnxk/roc_nix_tm_mark.c
+++ b/drivers/common/cnxk/roc_nix_tm_mark.c
@@ -109,9 +109,11 @@ nix_tm_update_red_algo(struct nix *nix, bool red_send)
 			tm_node->red_algo = NIX_REDALG_STD;
 
 		/* Update txschq config  */
-		req = mbox_alloc_msg_nix_txschq_cfg(mbox);
-		if (req == NULL)
+		req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
+		if (req == NULL) {
+			mbox_put(mbox);
 			return -ENOSPC;
+		}
 
 		req->lvl = tm_node->hw_lvl;
 		k = prepare_tm_shaper_red_algo(tm_node, req->reg, req->regval,
@@ -119,8 +121,11 @@ nix_tm_update_red_algo(struct nix *nix, bool red_send)
 		req->num_regs = k;
 
 		rc = mbox_process(mbox);
-		if (rc)
+		if (rc) {
+			mbox_put(mbox);
 			return rc;
+		}
+		mbox_put(mbox);
 	}
 	return 0;
 }
@@ -200,19 +205,23 @@ nix_tm_update_markfmt(struct nix *nix, enum roc_nix_tm_mark type,
 int
 nix_tm_mark_init(struct nix *nix)
 {
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	struct nix_mark_format_cfg_rsp *rsp;
 	struct nix_mark_format_cfg *req;
 	int rc, i, j;
 
 	/* Check for supported revisions */
-	if (roc_model_is_cn96_ax() || roc_model_is_cn95_a0())
-		return 0;
+	if (roc_model_is_cn96_ax() || roc_model_is_cn95_a0()) {
+		rc = 0;
+		goto exit;
+	}
 
 	/* Null mark format */
 	req = mbox_alloc_msg_nix_mark_format_cfg(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc =  -ENOSPC;
+		goto exit;
+	}
 
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc) {
@@ -268,6 +277,7 @@ nix_tm_mark_init(struct nix *nix)
 	nix_tm_update_markfmt(nix, ROC_NIX_TM_MARK_IPV6_DSCP, 0, 0);
 	nix_tm_update_markfmt(nix, ROC_NIX_TM_MARK_IPV6_ECN, 0, 0);
 exit:
+	mbox_put(mbox);
 	return rc;
 }
 
diff --git a/drivers/common/cnxk/roc_nix_tm_ops.c b/drivers/common/cnxk/roc_nix_tm_ops.c
index 5e8637ebdd1f5..8fb65be9d4fa0 100644
--- a/drivers/common/cnxk/roc_nix_tm_ops.c
+++ b/drivers/common/cnxk/roc_nix_tm_ops.c
@@ -22,12 +22,12 @@ roc_nix_tm_sq_aura_fc(struct roc_nix_sq *sq, bool enable)
 	if (!lf)
 		return NPA_ERR_DEVICE_NOT_BOUNDED;
 
-	mbox = lf->mbox;
+	mbox = mbox_get(lf->mbox);
 	/* Set/clear sqb aura fc_ena */
 	aura_handle = sq->aura_handle;
 	req = mbox_alloc_msg_npa_aq_enq(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 
 	req->aura_id = roc_npa_aura_handle_to_aura(aura_handle);
 	req->ctype = NPA_AQ_CTYPE_AURA;
@@ -48,12 +48,14 @@ roc_nix_tm_sq_aura_fc(struct roc_nix_sq *sq, bool enable)
 
 	rc = mbox_process(mbox);
 	if (rc)
-		return rc;
+		goto exit;
 
 	/* Read back npa aura ctx */
 	req = mbox_alloc_msg_npa_aq_enq(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	req->aura_id = roc_npa_aura_handle_to_aura(aura_handle);
 	req->ctype = NPA_AQ_CTYPE_AURA;
@@ -61,7 +63,7 @@ roc_nix_tm_sq_aura_fc(struct roc_nix_sq *sq, bool enable)
 
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	/* Init when enabled as there might be no triggers */
 	if (enable)
@@ -70,7 +72,10 @@ roc_nix_tm_sq_aura_fc(struct roc_nix_sq *sq, bool enable)
 		*(volatile uint64_t *)sq->fc = sq->aura_sqb_bufs;
 	/* Sync write barrier */
 	plt_wmb();
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -443,12 +448,14 @@ roc_nix_tm_hierarchy_disable(struct roc_nix *roc_nix)
 		/* Though it enables both RX MCAM Entries and CGX Link
 		 * we assume all the rx queues are stopped way back.
 		 */
-		mbox_alloc_msg_nix_lf_start_rx(mbox);
+		mbox_alloc_msg_nix_lf_start_rx(mbox_get(mbox));
 		rc = mbox_process(mbox);
 		if (rc) {
+			mbox_put(mbox);
 			plt_err("cgx start failed, rc=%d", rc);
 			return rc;
 		}
+		mbox_put(mbox);
 	}
 
 	/* XON all SMQ's */
@@ -543,8 +550,9 @@ roc_nix_tm_hierarchy_disable(struct roc_nix *roc_nix)
 cleanup:
 	/* Restore cgx state */
 	if (!roc_nix->io_enabled) {
-		mbox_alloc_msg_nix_lf_stop_rx(mbox);
+		mbox_alloc_msg_nix_lf_stop_rx(mbox_get(mbox));
 		rc |= mbox_process(mbox);
+		mbox_put(mbox);
 	}
 	return rc;
 }
@@ -703,12 +711,13 @@ roc_nix_tm_node_suspend_resume(struct roc_nix *roc_nix, uint32_t node_id,
 		return 0;
 
 	/* send mbox for state change */
-	req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+	req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 
 	req->lvl = node->hw_lvl;
 	req->num_regs =
 		nix_tm_sw_xoff_prep(node, suspend, req->reg, req->regval);
 	rc = mbox_process(mbox);
+	mbox_put(mbox);
 	if (!rc)
 		node->flags = flags;
 	return rc;
@@ -731,30 +740,40 @@ roc_nix_tm_prealloc_res(struct roc_nix *roc_nix, uint8_t lvl,
 
 	/* Preallocate contiguous */
 	if (nix->contig_rsvd[hw_lvl] < contig) {
-		req = mbox_alloc_msg_nix_txsch_alloc(mbox);
-		if (req == NULL)
+		req = mbox_alloc_msg_nix_txsch_alloc(mbox_get(mbox));
+		if (req == NULL) {
+			mbox_put(mbox);
 			return rc;
+		}
 		req->schq_contig[hw_lvl] = contig - nix->contig_rsvd[hw_lvl];
 
 		rc = mbox_process_msg(mbox, (void *)&rsp);
-		if (rc)
+		if (rc) {
+			mbox_put(mbox);
 			return rc;
+		}
 
 		nix_tm_copy_rsp_to_nix(nix, rsp);
+		mbox_put(mbox);
 	}
 
 	/* Preallocate contiguous */
 	if (nix->discontig_rsvd[hw_lvl] < discontig) {
-		req = mbox_alloc_msg_nix_txsch_alloc(mbox);
-		if (req == NULL)
+		req = mbox_alloc_msg_nix_txsch_alloc(mbox_get(mbox));
+		if (req == NULL) {
+			mbox_put(mbox);
 			return -ENOSPC;
+		}
 		req->schq[hw_lvl] = discontig - nix->discontig_rsvd[hw_lvl];
 
 		rc = mbox_process_msg(mbox, (void *)&rsp);
-		if (rc)
+		if (rc) {
+			mbox_put(mbox);
 			return rc;
+		}
 
 		nix_tm_copy_rsp_to_nix(nix, rsp);
+		mbox_put(mbox);
 	}
 
 	/* Save thresholds */
@@ -818,17 +837,20 @@ roc_nix_tm_node_shaper_update(struct roc_nix *roc_nix, uint32_t node_id,
 	node->flags &= ~NIX_TM_NODE_ENABLED;
 
 	/* Flush the specific node with SW_XOFF */
-	req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+	req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 	req->lvl = node->hw_lvl;
 	k = nix_tm_sw_xoff_prep(node, true, req->reg, req->regval);
 	req->num_regs = k;
 
 	rc = mbox_process(mbox);
-	if (rc)
+	if (rc) {
+		mbox_put(mbox);
 		return rc;
+	}
+	mbox_put(mbox);
 
 	/* Update the PIR/CIR and clear SW XOFF */
-	req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+	req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 	req->lvl = node->hw_lvl;
 
 	k = nix_tm_shaper_reg_prep(node, profile, req->reg, req->regval);
@@ -837,6 +859,7 @@ roc_nix_tm_node_shaper_update(struct roc_nix *roc_nix, uint32_t node_id,
 
 	req->num_regs = k;
 	rc = mbox_process(mbox);
+	mbox_put(mbox);
 	if (!rc)
 		node->flags |= NIX_TM_NODE_ENABLED;
 	return rc;
@@ -891,16 +914,17 @@ roc_nix_tm_node_parent_update(struct roc_nix *roc_nix, uint32_t node_id,
 			return NIX_ERR_TM_SQ_UPDATE_FAIL;
 	} else {
 		/* XOFF Parent node */
-		req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+		req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 		req->lvl = node->parent->hw_lvl;
 		req->num_regs = nix_tm_sw_xoff_prep(node->parent, true,
 						    req->reg, req->regval);
 		rc = mbox_process(mbox);
+		mbox_put(mbox);
 		if (rc)
 			return rc;
 
 		/* XOFF this node and all other siblings */
-		req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+		req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 		req->lvl = node->hw_lvl;
 
 		k = 0;
@@ -911,10 +935,11 @@ roc_nix_tm_node_parent_update(struct roc_nix *roc_nix, uint32_t node_id,
 			if (k >= MAX_REGS_PER_MBOX_MSG) {
 				req->num_regs = k;
 				rc = mbox_process(mbox);
+				mbox_put(mbox);
 				if (rc)
 					return rc;
 				k = 0;
-				req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+				req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 				req->lvl = node->hw_lvl;
 			}
 		}
@@ -922,20 +947,22 @@ roc_nix_tm_node_parent_update(struct roc_nix *roc_nix, uint32_t node_id,
 		if (k) {
 			req->num_regs = k;
 			rc = mbox_process(mbox);
+			mbox_put(mbox);
 			if (rc)
 				return rc;
 			/* Update new weight for current node */
-			req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+			req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 		}
 
 		req->lvl = node->hw_lvl;
 		req->num_regs = nix_tm_sched_reg_prep(nix, node, req->reg, req->regval);
 		rc = mbox_process(mbox);
+		mbox_put(mbox);
 		if (rc)
 			return rc;
 
 		/* XON this node and all other siblings */
-		req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+		req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 		req->lvl = node->hw_lvl;
 
 		k = 0;
@@ -946,10 +973,11 @@ roc_nix_tm_node_parent_update(struct roc_nix *roc_nix, uint32_t node_id,
 			if (k >= MAX_REGS_PER_MBOX_MSG) {
 				req->num_regs = k;
 				rc = mbox_process(mbox);
+				mbox_put(mbox);
 				if (rc)
 					return rc;
 				k = 0;
-				req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+				req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 				req->lvl = node->hw_lvl;
 			}
 		}
@@ -957,15 +985,17 @@ roc_nix_tm_node_parent_update(struct roc_nix *roc_nix, uint32_t node_id,
 		if (k) {
 			req->num_regs = k;
 			rc = mbox_process(mbox);
+			mbox_put(mbox);
 			if (rc)
 				return rc;
 			/* XON Parent node */
-			req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+			req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 		}
 
 		req->lvl = node->parent->hw_lvl;
 		req->num_regs = nix_tm_sw_xoff_prep(node->parent, false, req->reg, req->regval);
 		rc = mbox_process(mbox);
+		mbox_put(mbox);
 		if (rc)
 			return rc;
 	}
@@ -1017,20 +1047,22 @@ roc_nix_tm_rlimit_sq(struct roc_nix *roc_nix, uint16_t qid, uint64_t rate)
 	int rc;
 
 	if ((nix->tm_tree == ROC_NIX_TM_USER) ||
-	    !(nix->tm_flags & NIX_TM_HIERARCHY_ENA))
+	    !(nix->tm_flags & NIX_TM_HIERARCHY_ENA)) {
 		return NIX_ERR_TM_INVALID_TREE;
+	}
 
 	node = nix_tm_node_search(nix, qid, nix->tm_tree);
 
 	/* check if we found a valid leaf node */
 	if (!node || !nix_tm_is_leaf(nix, node->lvl) || !node->parent ||
-	    node->parent->hw_id == NIX_TM_HW_ID_INVALID)
+	    node->parent->hw_id == NIX_TM_HW_ID_INVALID) {
 		return NIX_ERR_TM_INVALID_NODE;
+	}
 
 	parent = node->parent;
 	flags = parent->flags;
 
-	req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+	req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 	req->lvl = NIX_TXSCH_LVL_MDQ;
 	reg = req->reg;
 	regval = req->regval;
@@ -1059,6 +1091,7 @@ roc_nix_tm_rlimit_sq(struct roc_nix *roc_nix, uint16_t qid, uint64_t rate)
 exit:
 	req->num_regs = k;
 	rc = mbox_process(mbox);
+	mbox_put(mbox);
 	if (rc)
 		return rc;
 
@@ -1084,14 +1117,17 @@ roc_nix_tm_fini(struct roc_nix *roc_nix)
 		plt_err("Failed to freeup existing nodes or rsrcs, rc=%d", rc);
 
 	/* Free all other hw resources */
-	req = mbox_alloc_msg_nix_txsch_free(mbox);
-	if (req == NULL)
+	req = mbox_alloc_msg_nix_txsch_free(mbox_get(mbox));
+	if (req == NULL) {
+		mbox_put(mbox);
 		return;
+	}
 
 	req->flags = TXSCHQ_FREE_ALL;
 	rc = mbox_process(mbox);
 	if (rc)
 		plt_err("Failed to freeup all res, rc=%d", rc);
+	mbox_put(mbox);
 
 	for (hw_lvl = 0; hw_lvl < NIX_TXSCH_LVL_CNT; hw_lvl++) {
 		plt_bitmap_reset(nix->schq_bmp[hw_lvl]);
@@ -1110,7 +1146,7 @@ int
 roc_nix_tm_rsrc_count(struct roc_nix *roc_nix, uint16_t schq[ROC_TM_LVL_MAX])
 {
 	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct mbox *mbox = (&nix->dev)->mbox;
+	struct mbox *mbox = mbox_get((&nix->dev)->mbox);
 	struct free_rsrcs_rsp *rsp;
 	uint8_t hw_lvl;
 	int rc, i;
@@ -1119,7 +1155,7 @@ roc_nix_tm_rsrc_count(struct roc_nix *roc_nix, uint16_t schq[ROC_TM_LVL_MAX])
 	mbox_alloc_msg_free_rsrc_cnt(mbox);
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	for (i = 0; i < ROC_TM_LVL_MAX; i++) {
 		hw_lvl = nix_tm_lvl2nix(nix, i);
@@ -1130,7 +1166,10 @@ roc_nix_tm_rsrc_count(struct roc_nix *roc_nix, uint16_t schq[ROC_TM_LVL_MAX])
 						rsp->schq[hw_lvl]);
 	}
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 void
diff --git a/drivers/common/cnxk/roc_nix_tm_utils.c b/drivers/common/cnxk/roc_nix_tm_utils.c
index d33e793664f67..a52b897713d3a 100644
--- a/drivers/common/cnxk/roc_nix_tm_utils.c
+++ b/drivers/common/cnxk/roc_nix_tm_utils.c
@@ -1166,7 +1166,7 @@ roc_nix_tm_node_stats_get(struct roc_nix *roc_nix, uint32_t node_id, bool clear,
 
 	memset(n_stats, 0, sizeof(struct roc_nix_tm_node_stats));
 
-	req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+	req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 	req->read = 1;
 	req->lvl = NIX_TXSCH_LVL_TL1;
 
@@ -1182,8 +1182,10 @@ roc_nix_tm_node_stats_get(struct roc_nix *roc_nix, uint32_t node_id, bool clear,
 	req->num_regs = i;
 
 	rc = mbox_process_msg(mbox, (void **)&rsp);
-	if (rc)
+	if (rc) {
+		mbox_put(mbox);
 		return rc;
+	}
 
 	/* Return stats */
 	n_stats->stats[ROC_NIX_TM_NODE_PKTS_DROPPED] = rsp->regval[0];
@@ -1194,13 +1196,14 @@ roc_nix_tm_node_stats_get(struct roc_nix *roc_nix, uint32_t node_id, bool clear,
 	n_stats->stats[ROC_NIX_TM_NODE_YELLOW_BYTES] = rsp->regval[5];
 	n_stats->stats[ROC_NIX_TM_NODE_RED_PKTS] = rsp->regval[6];
 	n_stats->stats[ROC_NIX_TM_NODE_RED_BYTES] = rsp->regval[7];
+	mbox_put(mbox);
 
 clear_stats:
 	if (!clear)
 		return 0;
 
 	/* Clear all the stats */
-	req = mbox_alloc_msg_nix_txschq_cfg(mbox);
+	req = mbox_alloc_msg_nix_txschq_cfg(mbox_get(mbox));
 	req->lvl = NIX_TXSCH_LVL_TL1;
 	i = 0;
 	req->reg[i++] = NIX_AF_TL1X_DROPPED_PACKETS(schq);
@@ -1213,7 +1216,9 @@ roc_nix_tm_node_stats_get(struct roc_nix *roc_nix, uint32_t node_id, bool clear,
 	req->reg[i++] = NIX_AF_TL1X_RED_BYTES(schq);
 	req->num_regs = i;
 
-	return mbox_process_msg(mbox, (void **)&rsp);
+	rc = mbox_process_msg(mbox, (void **)&rsp);
+	mbox_put(mbox);
+	return rc;
 }
 
 bool
diff --git a/drivers/common/cnxk/roc_nix_vlan.c b/drivers/common/cnxk/roc_nix_vlan.c
index 66bf8adbb3c3b..abd2eb0571829 100644
--- a/drivers/common/cnxk/roc_nix_vlan.c
+++ b/drivers/common/cnxk/roc_nix_vlan.c
@@ -5,29 +5,25 @@
 #include "roc_api.h"
 #include "roc_priv.h"
 
-static inline struct mbox *
-get_mbox(struct roc_nix *roc_nix)
-{
-	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
-	struct dev *dev = &nix->dev;
-
-	return dev->mbox;
-}
-
 int
 roc_nix_vlan_mcam_entry_read(struct roc_nix *roc_nix, uint32_t index,
 			     struct npc_mcam_read_entry_rsp **rsp)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct npc_mcam_read_entry_req *req;
 	int rc = -ENOSPC;
 
 	req = mbox_alloc_msg_npc_mcam_read_entry(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->entry = index;
 
-	return mbox_process_msg(mbox, (void **)rsp);
+	rc = mbox_process_msg(mbox, (void **)rsp);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -35,20 +31,25 @@ roc_nix_vlan_mcam_entry_write(struct roc_nix *roc_nix, uint32_t index,
 			      struct mcam_entry *entry, uint8_t intf,
 			      uint8_t enable)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct npc_mcam_write_entry_req *req;
 	struct msghdr *rsp;
 	int rc = -ENOSPC;
 
 	req = mbox_alloc_msg_npc_mcam_write_entry(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->entry = index;
 	req->intf = intf;
 	req->enable_entry = enable;
 	mbox_memcpy(&req->entry_data, entry, sizeof(struct mcam_entry));
 
-	return mbox_process_msg(mbox, (void *)&rsp);
+	rc = mbox_process_msg(mbox, (void *)&rsp);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -58,12 +59,14 @@ roc_nix_vlan_mcam_entry_alloc_and_write(struct roc_nix *roc_nix,
 {
 	struct npc_mcam_alloc_and_write_entry_req *req;
 	struct npc_mcam_alloc_and_write_entry_rsp *rsp;
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int rc = -ENOSPC;
 
 	req = mbox_alloc_msg_npc_mcam_alloc_and_write_entry(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->priority = priority;
 	req->ref_entry = ref_entry;
 	req->intf = intf;
@@ -72,24 +75,32 @@ roc_nix_vlan_mcam_entry_alloc_and_write(struct roc_nix *roc_nix,
 
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
-	return rsp->entry;
+	rc = rsp->entry;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_vlan_mcam_entry_free(struct roc_nix *roc_nix, uint32_t index)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct npc_mcam_free_entry_req *req;
 	int rc = -ENOSPC;
 
 	req = mbox_alloc_msg_npc_mcam_free_entry(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->entry = index;
 
-	return mbox_process_msg(mbox, NULL);
+	rc = mbox_process_msg(mbox, NULL);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -97,33 +108,40 @@ roc_nix_vlan_mcam_entry_ena_dis(struct roc_nix *roc_nix, uint32_t index,
 				const int enable)
 {
 	struct npc_mcam_ena_dis_entry_req *req;
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int rc = -ENOSPC;
 
 	if (enable) {
 		req = mbox_alloc_msg_npc_mcam_ena_entry(mbox);
 		if (req == NULL)
-			return rc;
+			goto exit;
 	} else {
 		req = mbox_alloc_msg_npc_mcam_dis_entry(mbox);
 		if (req == NULL)
-			return rc;
+			goto exit;
 	}
 
 	req->entry = index;
-	return mbox_process_msg(mbox, NULL);
+	rc =  mbox_process_msg(mbox, NULL);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_vlan_strip_vtag_ena_dis(struct roc_nix *roc_nix, bool enable)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_vtag_config *vtag_cfg;
 	int rc = -ENOSPC;
 
 	vtag_cfg = mbox_alloc_msg_nix_vtag_cfg(mbox);
 	if (vtag_cfg == NULL)
-		return rc;
+		goto exit;
 	vtag_cfg->vtag_size = NIX_VTAGSIZE_T4;
 	vtag_cfg->cfg_type = 1;	       /* Rx VLAN configuration */
 	vtag_cfg->rx.capture_vtag = 1; /* Always capture */
@@ -134,7 +152,10 @@ roc_nix_vlan_strip_vtag_ena_dis(struct roc_nix *roc_nix, bool enable)
 	else
 		vtag_cfg->rx.strip_vtag = 0;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -142,14 +163,16 @@ roc_nix_vlan_insert_ena_dis(struct roc_nix *roc_nix,
 			    struct roc_nix_vlan_config *vlan_cfg,
 			    uint64_t *mcam_index, bool enable)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_vtag_config *vtag_cfg;
 	struct nix_vtag_config_rsp *rsp;
 	int rc = -ENOSPC;
 
 	vtag_cfg = mbox_alloc_msg_nix_vtag_cfg(mbox);
 	if (vtag_cfg == NULL)
-		return rc;
+		goto exit;
 	vtag_cfg->cfg_type = 0; /* Tx VLAN configuration */
 	vtag_cfg->vtag_size = NIX_VTAGSIZE_T4;
 
@@ -175,25 +198,30 @@ roc_nix_vlan_insert_ena_dis(struct roc_nix *roc_nix,
 
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	if (enable)
 		*mcam_index =
 			(((uint64_t)rsp->vtag1_idx << 32) | rsp->vtag0_idx);
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 roc_nix_vlan_tpid_set(struct roc_nix *roc_nix, uint32_t type, uint16_t tpid)
 {
-	struct mbox *mbox = get_mbox(roc_nix);
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+	struct dev *dev = &nix->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct nix_set_vlan_tpid *tpid_cfg;
 	int rc = -ENOSPC;
 
 	tpid_cfg = mbox_alloc_msg_nix_set_vlan_tpid(mbox);
 	if (tpid_cfg == NULL)
-		return rc;
+		goto exit;
 	tpid_cfg->tpid = tpid;
 
 	if (type & ROC_NIX_VLAN_TYPE_OUTER)
@@ -201,5 +229,8 @@ roc_nix_vlan_tpid_set(struct roc_nix *roc_nix, uint32_t type, uint16_t tpid)
 	else
 		tpid_cfg->vlan_type = NIX_VLAN_TYPE_INNER;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
diff --git a/drivers/common/cnxk/roc_npa.c b/drivers/common/cnxk/roc_npa.c
index f015fc2f1b676..cf143a28b0842 100644
--- a/drivers/common/cnxk/roc_npa.c
+++ b/drivers/common/cnxk/roc_npa.c
@@ -40,17 +40,19 @@ roc_npa_aura_op_range_set(uint64_t aura_handle, uint64_t start_iova,
 }
 
 static int
-npa_aura_pool_init(struct mbox *mbox, uint32_t aura_id, struct npa_aura_s *aura,
+npa_aura_pool_init(struct mbox *m_box, uint32_t aura_id, struct npa_aura_s *aura,
 		   struct npa_pool_s *pool)
 {
 	struct npa_aq_enq_req *aura_init_req, *pool_init_req;
 	struct npa_aq_enq_rsp *aura_init_rsp, *pool_init_rsp;
-	struct mbox_dev *mdev = &mbox->dev[0];
+	struct mbox_dev *mdev = &m_box->dev[0];
 	int rc = -ENOSPC, off;
+	struct mbox *mbox;
 
+	mbox = mbox_get(m_box);
 	aura_init_req = mbox_alloc_msg_npa_aq_enq(mbox);
 	if (aura_init_req == NULL)
-		return rc;
+		goto exit;
 	aura_init_req->aura_id = aura_id;
 	aura_init_req->ctype = NPA_AQ_CTYPE_AURA;
 	aura_init_req->op = NPA_AQ_INSTOP_INIT;
@@ -58,7 +60,7 @@ npa_aura_pool_init(struct mbox *mbox, uint32_t aura_id, struct npa_aura_s *aura,
 
 	pool_init_req = mbox_alloc_msg_npa_aq_enq(mbox);
 	if (pool_init_req == NULL)
-		return rc;
+		goto exit;
 	pool_init_req->aura_id = aura_id;
 	pool_init_req->ctype = NPA_AQ_CTYPE_POOL;
 	pool_init_req->op = NPA_AQ_INSTOP_INIT;
@@ -66,7 +68,7 @@ npa_aura_pool_init(struct mbox *mbox, uint32_t aura_id, struct npa_aura_s *aura,
 
 	rc = mbox_process(mbox);
 	if (rc < 0)
-		return rc;
+		goto exit;
 
 	off = mbox->rx_start +
 	      PLT_ALIGN(sizeof(struct mbox_hdr), MBOX_MSG_ALIGN);
@@ -75,19 +77,23 @@ npa_aura_pool_init(struct mbox *mbox, uint32_t aura_id, struct npa_aura_s *aura,
 	pool_init_rsp = (struct npa_aq_enq_rsp *)((uintptr_t)mdev->mbase + off);
 
 	if (aura_init_rsp->hdr.rc == 0 && pool_init_rsp->hdr.rc == 0)
-		return 0;
+		rc = 0;
 	else
-		return NPA_ERR_AURA_POOL_INIT;
+		rc = NPA_ERR_AURA_POOL_INIT;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
-npa_aura_pool_fini(struct mbox *mbox, uint32_t aura_id, uint64_t aura_handle)
+npa_aura_pool_fini(struct mbox *m_box, uint32_t aura_id, uint64_t aura_handle)
 {
 	struct npa_aq_enq_req *aura_req, *pool_req;
 	struct npa_aq_enq_rsp *aura_rsp, *pool_rsp;
-	struct mbox_dev *mdev = &mbox->dev[0];
+	struct mbox_dev *mdev = &m_box->dev[0];
 	struct ndc_sync_op *ndc_req;
 	int rc = -ENOSPC, off;
+	struct mbox *mbox;
 	uint64_t ptr;
 
 	/* Procedure for disabling an aura/pool */
@@ -98,9 +104,10 @@ npa_aura_pool_fini(struct mbox *mbox, uint32_t aura_id, uint64_t aura_handle)
 		ptr = roc_npa_aura_op_alloc(aura_handle, 0);
 	} while (ptr);
 
+	mbox = mbox_get(m_box);
 	pool_req = mbox_alloc_msg_npa_aq_enq(mbox);
 	if (pool_req == NULL)
-		return rc;
+		goto exit;
 	pool_req->aura_id = aura_id;
 	pool_req->ctype = NPA_AQ_CTYPE_POOL;
 	pool_req->op = NPA_AQ_INSTOP_WRITE;
@@ -109,7 +116,7 @@ npa_aura_pool_fini(struct mbox *mbox, uint32_t aura_id, uint64_t aura_handle)
 
 	aura_req = mbox_alloc_msg_npa_aq_enq(mbox);
 	if (aura_req == NULL)
-		return rc;
+		goto exit;
 	aura_req->aura_id = aura_id;
 	aura_req->ctype = NPA_AQ_CTYPE_AURA;
 	aura_req->op = NPA_AQ_INSTOP_WRITE;
@@ -118,7 +125,7 @@ npa_aura_pool_fini(struct mbox *mbox, uint32_t aura_id, uint64_t aura_handle)
 
 	rc = mbox_process(mbox);
 	if (rc < 0)
-		return rc;
+		goto exit;
 
 	off = mbox->rx_start +
 	      PLT_ALIGN(sizeof(struct mbox_hdr), MBOX_MSG_ALIGN);
@@ -132,15 +139,21 @@ npa_aura_pool_fini(struct mbox *mbox, uint32_t aura_id, uint64_t aura_handle)
 
 	/* Sync NDC-NPA for LF */
 	ndc_req = mbox_alloc_msg_ndc_sync_op(mbox);
-	if (ndc_req == NULL)
-		return -ENOSPC;
+	if (ndc_req == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 	ndc_req->npa_lf_sync = 1;
 	rc = mbox_process(mbox);
 	if (rc) {
 		plt_err("Error on NDC-NPA LF sync, rc %d", rc);
-		return NPA_ERR_AURA_POOL_FINI;
+		rc = NPA_ERR_AURA_POOL_FINI;
+		goto exit;
 	}
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -157,13 +170,13 @@ roc_npa_pool_op_pc_reset(uint64_t aura_handle)
 	if (lf == NULL)
 		return NPA_ERR_PARAM;
 
-	mbox = lf->mbox;
+	mbox = mbox_get(lf->mbox);
 	mdev = &mbox->dev[0];
 	plt_npa_dbg("lf=%p aura_handle=0x%" PRIx64, lf, aura_handle);
 
 	pool_req = mbox_alloc_msg_npa_aq_enq(mbox);
 	if (pool_req == NULL)
-		return rc;
+		goto exit;
 	pool_req->aura_id = roc_npa_aura_handle_to_aura(aura_handle);
 	pool_req->ctype = NPA_AQ_CTYPE_POOL;
 	pool_req->op = NPA_AQ_INSTOP_WRITE;
@@ -172,26 +185,34 @@ roc_npa_pool_op_pc_reset(uint64_t aura_handle)
 
 	rc = mbox_process(mbox);
 	if (rc < 0)
-		return rc;
+		goto exit;
 
 	off = mbox->rx_start +
 	      PLT_ALIGN(sizeof(struct mbox_hdr), MBOX_MSG_ALIGN);
 	pool_rsp = (struct npa_aq_enq_rsp *)((uintptr_t)mdev->mbase + off);
 
-	if (pool_rsp->hdr.rc != 0)
-		return NPA_ERR_AURA_POOL_FINI;
+	if (pool_rsp->hdr.rc != 0) {
+		rc = NPA_ERR_AURA_POOL_FINI;
+		goto exit;
+	}
 
 	/* Sync NDC-NPA for LF */
 	ndc_req = mbox_alloc_msg_ndc_sync_op(mbox);
-	if (ndc_req == NULL)
-		return -ENOSPC;
+	if (ndc_req == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 	ndc_req->npa_lf_sync = 1;
 	rc = mbox_process(mbox);
 	if (rc) {
 		plt_err("Error on NDC-NPA LF sync, rc %d", rc);
-		return NPA_ERR_AURA_POOL_FINI;
+		rc = NPA_ERR_AURA_POOL_FINI;
+		goto exit;
 	}
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -199,15 +220,18 @@ roc_npa_aura_drop_set(uint64_t aura_handle, uint64_t limit, bool ena)
 {
 	struct npa_aq_enq_req *aura_req;
 	struct npa_lf *lf;
+	struct mbox *mbox;
 	int rc;
 
 	lf = idev_npa_obj_get();
 	if (lf == NULL)
 		return NPA_ERR_DEVICE_NOT_BOUNDED;
-
-	aura_req = mbox_alloc_msg_npa_aq_enq(lf->mbox);
-	if (aura_req == NULL)
-		return -ENOMEM;
+	mbox = mbox_get(lf->mbox);
+	aura_req = mbox_alloc_msg_npa_aq_enq(mbox);
+	if (aura_req == NULL) {
+		rc = -ENOMEM;
+		goto exit;
+	}
 	aura_req->aura_id = roc_npa_aura_handle_to_aura(aura_handle);
 	aura_req->ctype = NPA_AQ_CTYPE_AURA;
 	aura_req->op = NPA_AQ_INSTOP_WRITE;
@@ -217,8 +241,10 @@ roc_npa_aura_drop_set(uint64_t aura_handle, uint64_t limit, bool ena)
 	aura_req->aura_mask.aura_drop_ena =
 		~(aura_req->aura_mask.aura_drop_ena);
 	aura_req->aura_mask.aura_drop = ~(aura_req->aura_mask.aura_drop);
-	rc = mbox_process(lf->mbox);
+	rc = mbox_process(mbox);
 
+exit:
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -473,23 +499,28 @@ roc_npa_aura_limit_modify(uint64_t aura_handle, uint16_t aura_limit)
 {
 	struct npa_aq_enq_req *aura_req;
 	struct npa_lf *lf;
+	struct mbox *mbox;
 	int rc;
 
 	lf = idev_npa_obj_get();
 	if (lf == NULL)
 		return NPA_ERR_DEVICE_NOT_BOUNDED;
 
-	aura_req = mbox_alloc_msg_npa_aq_enq(lf->mbox);
-	if (aura_req == NULL)
-		return -ENOMEM;
+	mbox = mbox_get(lf->mbox);
+	aura_req = mbox_alloc_msg_npa_aq_enq(mbox);
+	if (aura_req == NULL) {
+		rc = -ENOMEM;
+		goto exit;
+	}
 	aura_req->aura_id = roc_npa_aura_handle_to_aura(aura_handle);
 	aura_req->ctype = NPA_AQ_CTYPE_AURA;
 	aura_req->op = NPA_AQ_INSTOP_WRITE;
 
 	aura_req->aura.limit = aura_limit;
 	aura_req->aura_mask.limit = ~(aura_req->aura_mask.limit);
-	rc = mbox_process(lf->mbox);
-
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -540,6 +571,7 @@ roc_npa_pool_range_update_check(uint64_t aura_handle)
 	__io struct npa_pool_s *pool;
 	struct npa_aq_enq_req *req;
 	struct npa_aq_enq_rsp *rsp;
+	struct mbox *mbox;
 	int rc;
 
 	lf = idev_npa_obj_get();
@@ -548,28 +580,35 @@ roc_npa_pool_range_update_check(uint64_t aura_handle)
 
 	lim = lf->aura_lim;
 
-	req = mbox_alloc_msg_npa_aq_enq(lf->mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	mbox = mbox_get(lf->mbox);
+	req = mbox_alloc_msg_npa_aq_enq(mbox);
+	if (req == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	req->aura_id = aura_id;
 	req->ctype = NPA_AQ_CTYPE_POOL;
 	req->op = NPA_AQ_INSTOP_READ;
 
-	rc = mbox_process_msg(lf->mbox, (void *)&rsp);
+	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc) {
 		plt_err("Failed to get pool(0x%" PRIx64 ") context", aura_id);
-		return rc;
+		goto exit;
 	}
 
 	pool = &rsp->pool;
 	if (lim[aura_id].ptr_start != pool->ptr_start ||
 	    lim[aura_id].ptr_end != pool->ptr_end) {
 		plt_err("Range update failed on pool(0x%" PRIx64 ")", aura_id);
-		return NPA_ERR_PARAM;
+		rc = NPA_ERR_PARAM;
+		goto exit;
 	}
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 uint64_t
@@ -593,36 +632,51 @@ roc_npa_zero_aura_handle(void)
 }
 
 static inline int
-npa_attach(struct mbox *mbox)
+npa_attach(struct mbox *m_box)
 {
+	struct mbox *mbox = mbox_get(m_box);
 	struct rsrc_attach_req *req;
+	int rc;
 
 	req = mbox_alloc_msg_attach_resources(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 	req->modify = true;
 	req->npalf = true;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static inline int
-npa_detach(struct mbox *mbox)
+npa_detach(struct mbox *m_box)
 {
+	struct mbox *mbox = mbox_get(m_box);
 	struct rsrc_detach_req *req;
+	int rc;
 
 	req = mbox_alloc_msg_detach_resources(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 	req->partial = true;
 	req->npalf = true;
 
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static inline int
-npa_get_msix_offset(struct mbox *mbox, uint16_t *npa_msixoff)
+npa_get_msix_offset(struct mbox *m_box, uint16_t *npa_msixoff)
 {
+	struct mbox *mbox = mbox_get(m_box);
 	struct msix_offset_rsp *msix_rsp;
 	int rc;
 
@@ -632,39 +686,52 @@ npa_get_msix_offset(struct mbox *mbox, uint16_t *npa_msixoff)
 	if (rc == 0)
 		*npa_msixoff = msix_rsp->npa_msixoff;
 
+	mbox_put(mbox);
 	return rc;
 }
 
 static inline int
 npa_lf_alloc(struct npa_lf *lf)
 {
-	struct mbox *mbox = lf->mbox;
+	struct mbox *mbox = mbox_get(lf->mbox);
 	struct npa_lf_alloc_req *req;
 	struct npa_lf_alloc_rsp *rsp;
 	int rc;
 
 	req = mbox_alloc_msg_npa_lf_alloc(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	if (req == NULL) {
+		rc =  -ENOSPC;
+		goto exit;
+	}
 	req->aura_sz = lf->aura_sz;
 	req->nr_pools = lf->nr_pools;
 
 	rc = mbox_process_msg(mbox, (void *)&rsp);
-	if (rc)
-		return NPA_ERR_ALLOC;
+	if (rc) {
+		rc = NPA_ERR_ALLOC;
+		goto exit;
+	}
 
 	lf->stack_pg_ptrs = rsp->stack_pg_ptrs;
 	lf->stack_pg_bytes = rsp->stack_pg_bytes;
 	lf->qints = rsp->qints;
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
-npa_lf_free(struct mbox *mbox)
+npa_lf_free(struct mbox *mail_box)
 {
+	struct mbox *mbox = mbox_get(mail_box);
+	int rc;
+
 	mbox_alloc_msg_npa_lf_free(mbox);
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+	mbox_put(mbox);
+	return rc;
 }
 
 static inline uint32_t
diff --git a/drivers/common/cnxk/roc_npa_debug.c b/drivers/common/cnxk/roc_npa_debug.c
index 798ace291c847..173d32cd9bb40 100644
--- a/drivers/common/cnxk/roc_npa_debug.c
+++ b/drivers/common/cnxk/roc_npa_debug.c
@@ -91,6 +91,7 @@ roc_npa_ctx_dump(void)
 {
 	struct npa_aq_enq_req *aq;
 	struct npa_aq_enq_rsp *rsp;
+	struct mbox *mbox;
 	struct npa_lf *lf;
 	uint32_t q;
 	int rc = 0;
@@ -98,23 +99,26 @@ roc_npa_ctx_dump(void)
 	lf = idev_npa_obj_get();
 	if (lf == NULL)
 		return NPA_ERR_DEVICE_NOT_BOUNDED;
+	mbox = mbox_get(lf->mbox);
 
 	for (q = 0; q < lf->nr_pools; q++) {
 		/* Skip disabled POOL */
 		if (plt_bitmap_get(lf->npa_bmp, q))
 			continue;
 
-		aq = mbox_alloc_msg_npa_aq_enq(lf->mbox);
-		if (aq == NULL)
-			return -ENOSPC;
+		aq = mbox_alloc_msg_npa_aq_enq(mbox);
+		if (aq == NULL) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 		aq->aura_id = q;
 		aq->ctype = NPA_AQ_CTYPE_POOL;
 		aq->op = NPA_AQ_INSTOP_READ;
 
-		rc = mbox_process_msg(lf->mbox, (void *)&rsp);
+		rc = mbox_process_msg(mbox, (void *)&rsp);
 		if (rc) {
 			plt_err("Failed to get pool(%d) context", q);
-			return rc;
+			goto exit;
 		}
 		npa_dump("============== pool=%d ===============\n", q);
 		npa_pool_dump(&rsp->pool);
@@ -125,22 +129,26 @@ roc_npa_ctx_dump(void)
 		if (plt_bitmap_get(lf->npa_bmp, q))
 			continue;
 
-		aq = mbox_alloc_msg_npa_aq_enq(lf->mbox);
-		if (aq == NULL)
-			return -ENOSPC;
+		aq = mbox_alloc_msg_npa_aq_enq(mbox);
+		if (aq == NULL) {
+			rc = -ENOSPC;
+			goto exit;
+		}
 		aq->aura_id = q;
 		aq->ctype = NPA_AQ_CTYPE_AURA;
 		aq->op = NPA_AQ_INSTOP_READ;
 
-		rc = mbox_process_msg(lf->mbox, (void *)&rsp);
+		rc = mbox_process_msg(mbox, (void *)&rsp);
 		if (rc) {
 			plt_err("Failed to get aura(%d) context", q);
-			return rc;
+			goto exit;
 		}
 		npa_dump("============== aura=%d ===============\n", q);
 		npa_aura_dump(&rsp->aura);
 	}
 
+exit:
+	mbox_put(mbox);
 	return rc;
 }
 
diff --git a/drivers/common/cnxk/roc_npc.c b/drivers/common/cnxk/roc_npc.c
index de3352250bbf2..5d49760eb9d65 100644
--- a/drivers/common/cnxk/roc_npc.c
+++ b/drivers/common/cnxk/roc_npc.c
@@ -1013,13 +1013,15 @@ npc_vtag_cfg_delete(struct roc_npc *roc_npc, struct roc_npc_flow *flow)
 	} tx_vtag_action;
 
 	nix = roc_nix_to_nix_priv(roc_nix);
-	mbox = (&nix->dev)->mbox;
+	mbox = mbox_get((&nix->dev)->mbox);
 
 	tx_vtag_action.reg = flow->vtag_action;
 	vtag_cfg = mbox_alloc_msg_nix_vtag_cfg(mbox);
 
-	if (vtag_cfg == NULL)
-		return -ENOSPC;
+	if (vtag_cfg == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	vtag_cfg->cfg_type = VTAG_TX;
 	vtag_cfg->vtag_size = NIX_VTAGSIZE_T4;
@@ -1033,9 +1035,12 @@ npc_vtag_cfg_delete(struct roc_npc *roc_npc, struct roc_npc_flow *flow)
 
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
-	return 0;
+	rc =  0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
@@ -1129,10 +1134,12 @@ npc_vtag_insert_action_configure(struct mbox *mbox, struct roc_npc_flow *flow,
 		struct nix_tx_vtag_action_s act;
 	} tx_vtag_action;
 
-	vtag_cfg = mbox_alloc_msg_nix_vtag_cfg(mbox);
+	vtag_cfg = mbox_alloc_msg_nix_vtag_cfg(mbox_get(mbox));
 
-	if (vtag_cfg == NULL)
-		return -ENOSPC;
+	if (vtag_cfg == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	vtag_cfg->cfg_type = VTAG_TX;
 	vtag_cfg->vtag_size = NIX_VTAGSIZE_T4;
@@ -1152,12 +1159,13 @@ npc_vtag_insert_action_configure(struct mbox *mbox, struct roc_npc_flow *flow,
 
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
 	if (rsp->vtag0_idx < 0 ||
 	    ((flow->vtag_insert_count == 2) && (rsp->vtag1_idx < 0))) {
 		plt_err("Failed to config TX VTAG action");
-		return -EINVAL;
+		rc =  -EINVAL;
+		goto exit;
 	}
 
 	tx_vtag_action.reg = 0;
@@ -1182,7 +1190,10 @@ npc_vtag_insert_action_configure(struct mbox *mbox, struct roc_npc_flow *flow,
 
 	flow->vtag_action = tx_vtag_action.reg;
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
@@ -1201,10 +1212,12 @@ npc_vtag_strip_action_configure(struct mbox *mbox,
 			(*strip_cnt)++;
 	}
 
-	vtag_cfg = mbox_alloc_msg_nix_vtag_cfg(mbox);
+	vtag_cfg = mbox_alloc_msg_nix_vtag_cfg(mbox_get(mbox));
 
-	if (vtag_cfg == NULL)
-		return -ENOSPC;
+	if (vtag_cfg == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	vtag_cfg->cfg_type = VTAG_RX;
 	vtag_cfg->rx.strip_vtag = 1;
@@ -1215,7 +1228,7 @@ npc_vtag_strip_action_configure(struct mbox *mbox,
 
 	rc = mbox_process(mbox);
 	if (rc)
-		return rc;
+		goto exit;
 
 	rx_vtag_action |= (NIX_RX_VTAGACTION_VTAG_VALID << 15);
 	rx_vtag_action |= ((uint64_t)NPC_LID_LB << 8);
@@ -1228,7 +1241,10 @@ npc_vtag_strip_action_configure(struct mbox *mbox,
 	}
 	flow->vtag_action = rx_vtag_action;
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
@@ -1539,16 +1555,19 @@ roc_npc_mcam_merge_base_steering_rule(struct roc_npc *roc_npc,
 	struct npc_mcam_read_base_rule_rsp *base_rule_rsp;
 	struct npc *npc = roc_npc_to_npc_priv(roc_npc);
 	struct mcam_entry *base_entry;
+	struct mbox *mbox = mbox_get(npc->mbox);
 	int idx, rc;
 
-	if (roc_nix_is_pf(roc_npc->roc_nix))
-		return 0;
+	if (roc_nix_is_pf(roc_npc->roc_nix)) {
+		rc = 0;
+		goto exit;
+	}
 
-	(void)mbox_alloc_msg_npc_read_base_steer_rule(npc->mbox);
-	rc = mbox_process_msg(npc->mbox, (void *)&base_rule_rsp);
+	(void)mbox_alloc_msg_npc_read_base_steer_rule(mbox);
+	rc = mbox_process_msg(mbox, (void *)&base_rule_rsp);
 	if (rc) {
 		plt_err("Failed to fetch VF's base MCAM entry");
-		return rc;
+		goto exit;
 	}
 	base_entry = &base_rule_rsp->entry_data;
 	for (idx = 0; idx < ROC_NPC_MAX_MCAM_WIDTH_DWORDS; idx++) {
@@ -1556,5 +1575,8 @@ roc_npc_mcam_merge_base_steering_rule(struct roc_npc *roc_npc,
 		flow->mcam_mask[idx] |= base_entry->kw_mask[idx];
 	}
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
diff --git a/drivers/common/cnxk/roc_npc_mcam.c b/drivers/common/cnxk/roc_npc_mcam.c
index c419ce3a4cc93..37e756661a163 100644
--- a/drivers/common/cnxk/roc_npc_mcam.c
+++ b/drivers/common/cnxk/roc_npc_mcam.c
@@ -11,14 +11,16 @@ npc_mcam_alloc_counter(struct mbox *mbox, uint16_t *ctr)
 	struct npc_mcam_alloc_counter_rsp *rsp;
 	int rc = -ENOSPC;
 
-	req = mbox_alloc_msg_npc_mcam_alloc_counter(mbox);
+	req = mbox_alloc_msg_npc_mcam_alloc_counter(mbox_get(mbox));
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->count = 1;
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 	*ctr = rsp->cntr_list[0];
+exit:
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -28,11 +30,14 @@ npc_mcam_free_counter(struct mbox *mbox, uint16_t ctr_id)
 	struct npc_mcam_oper_counter_req *req;
 	int rc = -ENOSPC;
 
-	req = mbox_alloc_msg_npc_mcam_free_counter(mbox);
+	req = mbox_alloc_msg_npc_mcam_free_counter(mbox_get(mbox));
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->cntr = ctr_id;
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -42,14 +47,16 @@ npc_mcam_read_counter(struct mbox *mbox, uint32_t ctr_id, uint64_t *count)
 	struct npc_mcam_oper_counter_rsp *rsp;
 	int rc = -ENOSPC;
 
-	req = mbox_alloc_msg_npc_mcam_counter_stats(mbox);
+	req = mbox_alloc_msg_npc_mcam_counter_stats(mbox_get(mbox));
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->cntr = ctr_id;
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 	*count = rsp->stat;
+exit:
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -59,11 +66,14 @@ npc_mcam_clear_counter(struct mbox *mbox, uint32_t ctr_id)
 	struct npc_mcam_oper_counter_req *req;
 	int rc = -ENOSPC;
 
-	req = mbox_alloc_msg_npc_mcam_clear_counter(mbox);
+	req = mbox_alloc_msg_npc_mcam_clear_counter(mbox_get(mbox));
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->cntr = ctr_id;
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -72,25 +82,31 @@ npc_mcam_free_entry(struct mbox *mbox, uint32_t entry)
 	struct npc_mcam_free_entry_req *req;
 	int rc = -ENOSPC;
 
-	req = mbox_alloc_msg_npc_mcam_free_entry(mbox);
+	req = mbox_alloc_msg_npc_mcam_free_entry(mbox_get(mbox));
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->entry = entry;
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 npc_mcam_free_all_entries(struct npc *npc)
 {
 	struct npc_mcam_free_entry_req *req;
-	struct mbox *mbox = npc->mbox;
+	struct mbox *mbox = mbox_get(npc->mbox);
 	int rc = -ENOSPC;
 
 	req = mbox_alloc_msg_npc_mcam_free_entry(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->all = 1;
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
@@ -309,9 +325,9 @@ npc_mcam_alloc_entries(struct mbox *mbox, int ref_mcam, int *alloc_entry, int re
 	int rc = -ENOSPC;
 	int i;
 
-	req = mbox_alloc_msg_npc_mcam_alloc_entry(mbox);
+	req = mbox_alloc_msg_npc_mcam_alloc_entry(mbox_get(mbox));
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->contig = is_conti;
 	req->count = req_count;
 	req->priority = prio;
@@ -319,13 +335,16 @@ npc_mcam_alloc_entries(struct mbox *mbox, int ref_mcam, int *alloc_entry, int re
 
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 	for (i = 0; i < rsp->count; i++)
 		alloc_entry[i] = rsp->entry_list[i];
 	*resp_count = rsp->count;
 	if (is_conti)
 		alloc_entry[0] = rsp->entry;
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -334,12 +353,12 @@ npc_mcam_alloc_entry(struct npc *npc, struct roc_npc_flow *mcam,
 {
 	struct npc_mcam_alloc_entry_req *req;
 	struct npc_mcam_alloc_entry_rsp *rsp;
-	struct mbox *mbox = npc->mbox;
+	struct mbox *mbox = mbox_get(npc->mbox);
 	int rc = -ENOSPC;
 
 	req = mbox_alloc_msg_npc_mcam_alloc_entry(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->contig = 1;
 	req->count = 1;
 	req->priority = prio;
@@ -347,19 +366,22 @@ npc_mcam_alloc_entry(struct npc *npc, struct roc_npc_flow *mcam,
 
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 	memset(mcam, 0, sizeof(struct roc_npc_flow));
 	mcam->mcam_id = rsp->entry;
 	mcam->nix_intf = ref_mcam->nix_intf;
 	*resp_count = rsp->count;
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 npc_mcam_ena_dis_entry(struct npc *npc, struct roc_npc_flow *mcam, bool enable)
 {
 	struct npc_mcam_ena_dis_entry_req *req;
-	struct mbox *mbox = npc->mbox;
+	struct mbox *mbox = mbox_get(npc->mbox);
 	int rc = -ENOSPC;
 
 	if (enable)
@@ -368,10 +390,13 @@ npc_mcam_ena_dis_entry(struct npc *npc, struct roc_npc_flow *mcam, bool enable)
 		req = mbox_alloc_msg_npc_mcam_dis_entry(mbox);
 
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->entry = mcam->mcam_id;
 	mcam->enable = enable;
-	return mbox_process(mbox);
+	rc = mbox_process(mbox);
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -394,8 +419,9 @@ npc_mcam_write_entry(struct mbox *mbox, struct roc_npc_flow *mcam)
 			return rc;
 	}
 
-	req = mbox_alloc_msg_npc_mcam_write_entry(mbox);
+	req = mbox_alloc_msg_npc_mcam_write_entry(mbox_get(mbox));
 	if (req == NULL) {
+		mbox_put(mbox);
 		if (mcam->use_ctr)
 			npc_mcam_free_counter(mbox, ctr);
 
@@ -415,7 +441,9 @@ npc_mcam_write_entry(struct mbox *mbox, struct roc_npc_flow *mcam)
 		req->entry_data.kw[i] = mcam->mcam_data[i];
 		req->entry_data.kw_mask[i] = mcam->mcam_mask[i];
 	}
-	return mbox_process_msg(mbox, (void *)&rsp);
+	rc = mbox_process_msg(mbox, (void *)&rsp);
+	mbox_put(mbox);
+	return rc;
 }
 
 static void
@@ -478,7 +506,7 @@ int
 npc_mcam_fetch_kex_cfg(struct npc *npc)
 {
 	struct npc_get_kex_cfg_rsp *kex_rsp;
-	struct mbox *mbox = npc->mbox;
+	struct mbox *mbox = mbox_get(npc->mbox);
 	int rc = 0;
 
 	mbox_alloc_msg_npc_get_kex_cfg(mbox);
@@ -494,6 +522,7 @@ npc_mcam_fetch_kex_cfg(struct npc *npc)
 	npc_mcam_process_mkex_cfg(npc, kex_rsp);
 
 done:
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -589,9 +618,11 @@ npc_mcam_alloc_and_write(struct npc *npc, struct roc_npc_flow *flow,
 		}
 	}
 
-	req = mbox_alloc_msg_npc_mcam_write_entry(mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	req = mbox_alloc_msg_npc_mcam_write_entry(mbox_get(mbox));
+	if (req == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 	req->set_cntr = flow->use_ctr;
 	req->cntr = flow->ctr_id;
 	req->entry = entry;
@@ -667,13 +698,16 @@ npc_mcam_alloc_and_write(struct npc *npc, struct roc_npc_flow *flow,
 
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc != 0)
-		return rc;
+		goto exit;
 
 	flow->mcam_id = entry;
 
 	if (flow->use_ctr)
 		flow->ctr_id = ctr;
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static void
@@ -755,6 +789,7 @@ npc_program_mcam(struct npc *npc, struct npc_parse_state *pst, bool mcam_alloc)
 	struct idev_cfg *idev;
 	uint16_t layer_info;
 	uint64_t lt, flags;
+	struct mbox *mbox;
 
 	/* Skip till Layer A data start */
 	while (bit < NPC_PARSE_KEX_S_LA_OFFSET) {
@@ -826,12 +861,15 @@ npc_program_mcam(struct npc *npc, struct npc_parse_state *pst, bool mcam_alloc)
 		skip_base_rule = true;
 
 	if (pst->is_vf && pst->flow->nix_intf == NIX_INTF_RX && !skip_base_rule) {
-		(void)mbox_alloc_msg_npc_read_base_steer_rule(npc->mbox);
-		rc = mbox_process_msg(npc->mbox, (void *)&base_rule_rsp);
+		mbox = mbox_get(npc->mbox);
+		(void)mbox_alloc_msg_npc_read_base_steer_rule(mbox);
+		rc = mbox_process_msg(mbox, (void *)&base_rule_rsp);
 		if (rc) {
+			mbox_put(mbox);
 			plt_err("Failed to fetch VF's base MCAM entry");
 			return rc;
 		}
+		mbox_put(mbox);
 		base_entry = &base_rule_rsp->entry_data;
 		for (idx = 0; idx < ROC_NPC_MAX_MCAM_WIDTH_DWORDS; idx++) {
 			pst->flow->mcam_data[idx] |= base_entry->kw[idx];
diff --git a/drivers/common/cnxk/roc_npc_mcam_dump.c b/drivers/common/cnxk/roc_npc_mcam_dump.c
index fe57811a848e3..2aaa2ac6710b4 100644
--- a/drivers/common/cnxk/roc_npc_mcam_dump.c
+++ b/drivers/common/cnxk/roc_npc_mcam_dump.c
@@ -620,15 +620,17 @@ roc_npc_flow_mcam_dump(FILE *file, struct roc_npc *roc_npc,
 		fprintf(file, "\tDW%d_Mask:%016lX\n", i, flow->mcam_mask[i]);
 	}
 
-	mcam_read_req = mbox_alloc_msg_npc_mcam_read_entry(npc->mbox);
+	mcam_read_req = mbox_alloc_msg_npc_mcam_read_entry(mbox_get(npc->mbox));
 	if (mcam_read_req == NULL) {
 		plt_err("Failed to alloc msg");
+		mbox_put(npc->mbox);
 		return;
 	}
 
 	mcam_read_req->entry = flow->mcam_id;
 	rc = mbox_process_msg(npc->mbox, (void *)&mcam_read_rsp);
 	if (rc) {
+		mbox_put(npc->mbox);
 		plt_err("Failed to fetch MCAM entry:%d", flow->mcam_id);
 		return;
 	}
@@ -643,4 +645,5 @@ roc_npc_flow_mcam_dump(FILE *file, struct roc_npc *roc_npc,
 	}
 
 	fprintf(file, "\n");
+	mbox_put(npc->mbox);
 }
diff --git a/drivers/common/cnxk/roc_npc_utils.c b/drivers/common/cnxk/roc_npc_utils.c
index 8bdabc116dde1..a9df62cee670b 100644
--- a/drivers/common/cnxk/roc_npc_utils.c
+++ b/drivers/common/cnxk/roc_npc_utils.c
@@ -269,11 +269,14 @@ npc_mcam_init(struct npc *npc, struct roc_npc_flow *flow, int mcam_id)
 {
 	struct npc_mcam_write_entry_req *req;
 	struct npc_mcam_write_entry_rsq *rsp;
+	struct mbox *mbox = mbox_get(npc->mbox);
 	int rc = 0, idx;
 
-	req = mbox_alloc_msg_npc_mcam_write_entry(npc->mbox);
-	if (req == NULL)
-		return -ENOSPC;
+	req = mbox_alloc_msg_npc_mcam_write_entry(mbox);
+	if (req == NULL) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 	req->set_cntr = 0;
 	req->cntr = 0;
 	req->entry = mcam_id;
@@ -299,12 +302,15 @@ npc_mcam_init(struct npc *npc, struct roc_npc_flow *flow, int mcam_id)
 		req->entry_data.kw_mask[0] |= ((uint64_t)0xffff << 32);
 	}
 
-	rc = mbox_process_msg(npc->mbox, (void *)&rsp);
+	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc != 0) {
 		plt_err("npc: mcam initialisation write failed");
-		return rc;
+		goto exit;
 	}
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -317,18 +323,21 @@ npc_mcam_move(struct mbox *mbox, uint16_t old_ent, uint16_t new_ent)
 	/* Old entry is disabled & it's contents are moved to new_entry,
 	 * new entry is enabled finally.
 	 */
-	req = mbox_alloc_msg_npc_mcam_shift_entry(mbox);
+	req = mbox_alloc_msg_npc_mcam_shift_entry(mbox_get(mbox));
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->curr_entry[0] = old_ent;
 	req->new_entry[0] = new_ent;
 	req->shift_count = 1;
 
 	rc = mbox_process_msg(mbox, (void *)&rsp);
 	if (rc)
-		return rc;
+		goto exit;
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 enum SHIFT_DIR {
@@ -567,9 +576,9 @@ npc_allocate_mcam_entry(struct mbox *mbox, int prio,
 	struct npc_mcam_alloc_entry_rsp *rsp;
 	int rc = -ENOSPC;
 
-	req = mbox_alloc_msg_npc_mcam_alloc_entry(mbox);
+	req = mbox_alloc_msg_npc_mcam_alloc_entry(mbox_get(mbox));
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->contig = 1;
 	req->count = 1;
 	req->priority = prio;
@@ -577,14 +586,19 @@ npc_allocate_mcam_entry(struct mbox *mbox, int prio,
 
 	rc = mbox_process_msg(mbox, (void *)&rsp_cmd);
 	if (rc)
-		return rc;
+		goto exit;
 
-	if (!rsp_cmd->count)
-		return -ENOSPC;
+	if (!rsp_cmd->count) {
+		rc = -ENOSPC;
+		goto exit;
+	}
 
 	mbox_memcpy(rsp_local, rsp_cmd, sizeof(*rsp));
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static void
diff --git a/drivers/common/cnxk/roc_sso.c b/drivers/common/cnxk/roc_sso.c
index 69898843739c9..9920d0c604c8c 100644
--- a/drivers/common/cnxk/roc_sso.c
+++ b/drivers/common/cnxk/roc_sso.c
@@ -12,67 +12,79 @@ int
 sso_lf_alloc(struct dev *dev, enum sso_lf_type lf_type, uint16_t nb_lf,
 	     void **rsp)
 {
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int rc = -ENOSPC;
 
 	switch (lf_type) {
 	case SSO_LF_TYPE_HWS: {
 		struct ssow_lf_alloc_req *req;
 
-		req = mbox_alloc_msg_ssow_lf_alloc(dev->mbox);
+		req = mbox_alloc_msg_ssow_lf_alloc(mbox);
 		if (req == NULL)
-			return rc;
+			goto exit;
 		req->hws = nb_lf;
 	} break;
 	case SSO_LF_TYPE_HWGRP: {
 		struct sso_lf_alloc_req *req;
 
-		req = mbox_alloc_msg_sso_lf_alloc(dev->mbox);
+		req = mbox_alloc_msg_sso_lf_alloc(mbox);
 		if (req == NULL)
-			return rc;
+			goto exit;
 		req->hwgrps = nb_lf;
 	} break;
 	default:
 		break;
 	}
 
-	rc = mbox_process_msg(dev->mbox, rsp);
-	if (rc)
-		return -EIO;
+	rc = mbox_process_msg(mbox, rsp);
+	if (rc) {
+		rc = -EIO;
+		goto exit;
+	}
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
 sso_lf_free(struct dev *dev, enum sso_lf_type lf_type, uint16_t nb_lf)
 {
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int rc = -ENOSPC;
 
 	switch (lf_type) {
 	case SSO_LF_TYPE_HWS: {
 		struct ssow_lf_free_req *req;
 
-		req = mbox_alloc_msg_ssow_lf_free(dev->mbox);
+		req = mbox_alloc_msg_ssow_lf_free(mbox);
 		if (req == NULL)
-			return rc;
+			goto exit;
 		req->hws = nb_lf;
 	} break;
 	case SSO_LF_TYPE_HWGRP: {
 		struct sso_lf_free_req *req;
 
-		req = mbox_alloc_msg_sso_lf_free(dev->mbox);
+		req = mbox_alloc_msg_sso_lf_free(mbox);
 		if (req == NULL)
-			return rc;
+			goto exit;
 		req->hwgrps = nb_lf;
 	} break;
 	default:
 		break;
 	}
 
-	rc = mbox_process(dev->mbox);
-	if (rc)
-		return -EIO;
+	rc = mbox_process(mbox);
+	if (rc) {
+		rc = -EIO;
+		goto exit;
+	}
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
@@ -80,12 +92,13 @@ sso_rsrc_attach(struct roc_sso *roc_sso, enum sso_lf_type lf_type,
 		uint16_t nb_lf)
 {
 	struct dev *dev = &roc_sso_to_sso_priv(roc_sso)->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct rsrc_attach_req *req;
 	int rc = -ENOSPC;
 
-	req = mbox_alloc_msg_attach_resources(dev->mbox);
+	req = mbox_alloc_msg_attach_resources(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	switch (lf_type) {
 	case SSO_LF_TYPE_HWS:
 		req->ssow = nb_lf;
@@ -94,14 +107,20 @@ sso_rsrc_attach(struct roc_sso *roc_sso, enum sso_lf_type lf_type,
 		req->sso = nb_lf;
 		break;
 	default:
-		return SSO_ERR_PARAM;
+		rc = SSO_ERR_PARAM;
+		goto exit;
 	}
 
 	req->modify = true;
-	if (mbox_process(dev->mbox))
-		return -EIO;
+	if (mbox_process(mbox)) {
+		rc = -EIO;
+		goto exit;
+	}
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
@@ -109,11 +128,12 @@ sso_rsrc_detach(struct roc_sso *roc_sso, enum sso_lf_type lf_type)
 {
 	struct dev *dev = &roc_sso_to_sso_priv(roc_sso)->dev;
 	struct rsrc_detach_req *req;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int rc = -ENOSPC;
 
-	req = mbox_alloc_msg_detach_resources(dev->mbox);
+	req = mbox_alloc_msg_detach_resources(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	switch (lf_type) {
 	case SSO_LF_TYPE_HWS:
 		req->ssow = true;
@@ -122,14 +142,20 @@ sso_rsrc_detach(struct roc_sso *roc_sso, enum sso_lf_type lf_type)
 		req->sso = true;
 		break;
 	default:
-		return SSO_ERR_PARAM;
+		rc = SSO_ERR_PARAM;
+		goto exit;
 	}
 
 	req->partial = true;
-	if (mbox_process(dev->mbox))
-		return -EIO;
+	if (mbox_process(mbox)) {
+		rc = -EIO;
+		goto exit;
+	}
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static int
@@ -137,19 +163,24 @@ sso_rsrc_get(struct roc_sso *roc_sso)
 {
 	struct dev *dev = &roc_sso_to_sso_priv(roc_sso)->dev;
 	struct free_rsrcs_rsp *rsrc_cnt;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int rc;
 
-	mbox_alloc_msg_free_rsrc_cnt(dev->mbox);
-	rc = mbox_process_msg(dev->mbox, (void **)&rsrc_cnt);
+	mbox_alloc_msg_free_rsrc_cnt(mbox);
+	rc = mbox_process_msg(mbox, (void **)&rsrc_cnt);
 	if (rc) {
 		plt_err("Failed to get free resource count\n");
-		return -EIO;
+		rc = -EIO;
+		goto exit;
 	}
 
 	roc_sso->max_hwgrp = rsrc_cnt->sso;
 	roc_sso->max_hws = rsrc_cnt->ssow;
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 void
@@ -195,17 +226,22 @@ sso_msix_fill(struct roc_sso *roc_sso, uint16_t nb_hws, uint16_t nb_hwgrp)
 	struct dev *dev = &sso->dev;
 	int i, rc;
 
-	mbox_alloc_msg_msix_offset(dev->mbox);
+	mbox_alloc_msg_msix_offset(mbox_get(dev->mbox));
 	rc = mbox_process_msg(dev->mbox, (void **)&rsp);
-	if (rc)
-		return -EIO;
+	if (rc) {
+		rc = -EIO;
+		goto exit;
+	}
 
 	for (i = 0; i < nb_hws; i++)
 		sso->hws_msix_offset[i] = rsp->ssow_msixoff[i];
 	for (i = 0; i < nb_hwgrp; i++)
 		sso->hwgrp_msix_offset[i] = rsp->sso_msixoff[i];
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(dev->mbox);
+	return rc;
 }
 
 /* Public Functions. */
@@ -288,26 +324,28 @@ roc_sso_hws_stats_get(struct roc_sso *roc_sso, uint8_t hws,
 	struct sso *sso = roc_sso_to_sso_priv(roc_sso);
 	struct sso_hws_stats *req_rsp;
 	struct dev *dev = &sso->dev;
+	struct mbox *mbox;
 	int rc;
 
 	plt_spinlock_lock(&sso->mbox_lock);
+	mbox = mbox_get(dev->mbox);
 	req_rsp = (struct sso_hws_stats *)mbox_alloc_msg_sso_hws_get_stats(
-		dev->mbox);
+		mbox);
 	if (req_rsp == NULL) {
-		rc = mbox_process(dev->mbox);
+		rc = mbox_process(mbox);
 		if (rc) {
 			rc = -EIO;
 			goto fail;
 		}
 		req_rsp = (struct sso_hws_stats *)
-			mbox_alloc_msg_sso_hws_get_stats(dev->mbox);
+			mbox_alloc_msg_sso_hws_get_stats(mbox);
 		if (req_rsp == NULL) {
 			rc = -ENOSPC;
 			goto fail;
 		}
 	}
 	req_rsp->hws = hws;
-	rc = mbox_process_msg(dev->mbox, (void **)&req_rsp);
+	rc = mbox_process_msg(mbox, (void **)&req_rsp);
 	if (rc) {
 		rc = -EIO;
 		goto fail;
@@ -315,6 +353,7 @@ roc_sso_hws_stats_get(struct roc_sso *roc_sso, uint8_t hws,
 
 	stats->arbitration = req_rsp->arbitration;
 fail:
+	mbox_put(mbox);
 	plt_spinlock_unlock(&sso->mbox_lock);
 	return rc;
 }
@@ -326,26 +365,28 @@ roc_sso_hwgrp_stats_get(struct roc_sso *roc_sso, uint8_t hwgrp,
 	struct sso *sso = roc_sso_to_sso_priv(roc_sso);
 	struct sso_grp_stats *req_rsp;
 	struct dev *dev = &sso->dev;
+	struct mbox *mbox;
 	int rc;
 
 	plt_spinlock_lock(&sso->mbox_lock);
+	mbox = mbox_get(dev->mbox);
 	req_rsp = (struct sso_grp_stats *)mbox_alloc_msg_sso_grp_get_stats(
-		dev->mbox);
+		mbox);
 	if (req_rsp == NULL) {
-		rc = mbox_process(dev->mbox);
+		rc = mbox_process(mbox);
 		if (rc) {
 			rc = -EIO;
 			goto fail;
 		}
 		req_rsp = (struct sso_grp_stats *)
-			mbox_alloc_msg_sso_grp_get_stats(dev->mbox);
+			mbox_alloc_msg_sso_grp_get_stats(mbox);
 		if (req_rsp == NULL) {
 			rc = -ENOSPC;
 			goto fail;
 		}
 	}
 	req_rsp->grp = hwgrp;
-	rc = mbox_process_msg(dev->mbox, (void **)&req_rsp);
+	rc = mbox_process_msg(mbox, (void **)&req_rsp);
 	if (rc) {
 		rc = -EIO;
 		goto fail;
@@ -361,6 +402,7 @@ roc_sso_hwgrp_stats_get(struct roc_sso *roc_sso, uint8_t hwgrp,
 	stats->ws_pc = req_rsp->ws_pc;
 
 fail:
+	mbox_put(mbox);
 	plt_spinlock_unlock(&sso->mbox_lock);
 	return rc;
 }
@@ -382,22 +424,24 @@ roc_sso_hwgrp_qos_config(struct roc_sso *roc_sso, struct roc_sso_hwgrp_qos *qos,
 	struct sso *sso = roc_sso_to_sso_priv(roc_sso);
 	struct dev *dev = &sso->dev;
 	struct sso_grp_qos_cfg *req;
+	struct mbox *mbox;
 	int i, rc;
 
 	plt_spinlock_lock(&sso->mbox_lock);
+	mbox = mbox_get(dev->mbox);
 	for (i = 0; i < nb_qos; i++) {
 		uint8_t iaq_prcnt = qos[i].iaq_prcnt;
 		uint8_t taq_prcnt = qos[i].taq_prcnt;
 
-		req = mbox_alloc_msg_sso_grp_qos_config(dev->mbox);
+		req = mbox_alloc_msg_sso_grp_qos_config(mbox);
 		if (req == NULL) {
-			rc = mbox_process(dev->mbox);
+			rc = mbox_process(mbox);
 			if (rc) {
 				rc = -EIO;
 				goto fail;
 			}
 
-			req = mbox_alloc_msg_sso_grp_qos_config(dev->mbox);
+			req = mbox_alloc_msg_sso_grp_qos_config(mbox);
 			if (req == NULL) {
 				rc = -ENOSPC;
 				goto fail;
@@ -412,10 +456,11 @@ roc_sso_hwgrp_qos_config(struct roc_sso *roc_sso, struct roc_sso_hwgrp_qos *qos,
 			       100;
 	}
 
-	rc = mbox_process(dev->mbox);
+	rc = mbox_process(mbox);
 	if (rc)
 		rc = -EIO;
 fail:
+	mbox_put(mbox);
 	plt_spinlock_unlock(&sso->mbox_lock);
 	return rc;
 }
@@ -565,19 +610,25 @@ int
 sso_hwgrp_alloc_xaq(struct dev *dev, uint32_t npa_aura_id, uint16_t hwgrps)
 {
 	struct sso_hw_setconfig *req;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int rc = -ENOSPC;
 
-	req = mbox_alloc_msg_sso_hw_setconfig(dev->mbox);
+	req = mbox_alloc_msg_sso_hw_setconfig(mbox);
 	if (req == NULL)
-		return rc;
+		goto exit;
 	req->npa_pf_func = idev_npa_pffunc_get();
 	req->npa_aura_id = npa_aura_id;
 	req->hwgrps = hwgrps;
 
-	if (mbox_process(dev->mbox))
-		return -EIO;
+	if (mbox_process(dev->mbox)) {
+		rc = -EIO;
+		goto exit;
+	}
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -598,16 +649,25 @@ int
 sso_hwgrp_release_xaq(struct dev *dev, uint16_t hwgrps)
 {
 	struct sso_hw_xaq_release *req;
+	struct mbox *mbox = mbox_get(dev->mbox);
+	int rc;
 
-	req = mbox_alloc_msg_sso_hw_release_xaq_aura(dev->mbox);
-	if (req == NULL)
-		return -EINVAL;
+	req = mbox_alloc_msg_sso_hw_release_xaq_aura(mbox);
+	if (req == NULL) {
+		rc =  -EINVAL;
+		goto exit;
+	}
 	req->hwgrps = hwgrps;
 
-	if (mbox_process(dev->mbox))
-		return -EIO;
+	if (mbox_process(mbox)) {
+		rc = -EIO;
+		goto exit;
+	}
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 int
@@ -630,10 +690,12 @@ roc_sso_hwgrp_set_priority(struct roc_sso *roc_sso, uint16_t hwgrp,
 	struct sso *sso = roc_sso_to_sso_priv(roc_sso);
 	struct dev *dev = &sso->dev;
 	struct sso_grp_priority *req;
+	struct mbox *mbox;
 	int rc = -ENOSPC;
 
 	plt_spinlock_lock(&sso->mbox_lock);
-	req = mbox_alloc_msg_sso_grp_set_priority(dev->mbox);
+	mbox = mbox_get(dev->mbox);
+	req = mbox_alloc_msg_sso_grp_set_priority(mbox);
 	if (req == NULL)
 		goto fail;
 	req->grp = hwgrp;
@@ -641,17 +703,19 @@ roc_sso_hwgrp_set_priority(struct roc_sso *roc_sso, uint16_t hwgrp,
 	req->affinity = affinity;
 	req->priority = priority;
 
-	rc = mbox_process(dev->mbox);
+	rc = mbox_process(mbox);
 	if (rc) {
 		rc = -EIO;
 		goto fail;
 	}
+	mbox_put(mbox);
 	plt_spinlock_unlock(&sso->mbox_lock);
 	plt_sso_dbg("HWGRP %d weight %d affinity %d priority %d", hwgrp, weight,
 		    affinity, priority);
 
 	return 0;
 fail:
+	mbox_put(mbox);
 	plt_spinlock_unlock(&sso->mbox_lock);
 	return rc;
 }
diff --git a/drivers/common/cnxk/roc_tim.c b/drivers/common/cnxk/roc_tim.c
index 0f9209937bcad..90ce72cfa04d6 100644
--- a/drivers/common/cnxk/roc_tim.c
+++ b/drivers/common/cnxk/roc_tim.c
@@ -12,17 +12,23 @@ tim_fill_msix(struct roc_tim *roc_tim, uint16_t nb_ring)
 	struct tim *tim = roc_tim_to_tim_priv(roc_tim);
 	struct dev *dev = &sso->dev;
 	struct msix_offset_rsp *rsp;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int i, rc;
 
-	mbox_alloc_msg_msix_offset(dev->mbox);
-	rc = mbox_process_msg(dev->mbox, (void **)&rsp);
-	if (rc)
-		return -EIO;
+	mbox_alloc_msg_msix_offset(mbox);
+	rc = mbox_process_msg(mbox, (void **)&rsp);
+	if (rc) {
+		rc = -EIO;
+		goto exit;
+	}
 
 	for (i = 0; i < nb_ring; i++)
 		tim->tim_msix_offsets[i] = rsp->timlf_msixoff[i];
 
-	return 0;
+	rc = 0;
+exit:
+	mbox_put(mbox);
+	return rc;
 }
 
 static void
@@ -91,12 +97,12 @@ roc_tim_lf_enable(struct roc_tim *roc_tim, uint8_t ring_id, uint64_t *start_tsc,
 {
 	struct sso *sso = roc_sso_to_sso_priv(roc_tim->roc_sso);
 	struct dev *dev = &sso->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct tim_enable_rsp *rsp;
 	struct tim_ring_req *req;
 	int rc = -ENOSPC;
 
-	plt_spinlock_lock(&sso->mbox_lock);
-	req = mbox_alloc_msg_tim_enable_ring(dev->mbox);
+	req = mbox_alloc_msg_tim_enable_ring(mbox);
 	if (req == NULL)
 		goto fail;
 	req->ring = ring_id;
@@ -114,7 +120,7 @@ roc_tim_lf_enable(struct roc_tim *roc_tim, uint8_t ring_id, uint64_t *start_tsc,
 		*start_tsc = rsp->timestarted;
 
 fail:
-	plt_spinlock_unlock(&sso->mbox_lock);
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -123,11 +129,11 @@ roc_tim_lf_disable(struct roc_tim *roc_tim, uint8_t ring_id)
 {
 	struct sso *sso = roc_sso_to_sso_priv(roc_tim->roc_sso);
 	struct dev *dev = &sso->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct tim_ring_req *req;
 	int rc = -ENOSPC;
 
-	plt_spinlock_lock(&sso->mbox_lock);
-	req = mbox_alloc_msg_tim_disable_ring(dev->mbox);
+	req = mbox_alloc_msg_tim_disable_ring(mbox);
 	if (req == NULL)
 		goto fail;
 	req->ring = ring_id;
@@ -139,7 +145,7 @@ roc_tim_lf_disable(struct roc_tim *roc_tim, uint8_t ring_id)
 	}
 
 fail:
-	plt_spinlock_unlock(&sso->mbox_lock);
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -159,11 +165,11 @@ roc_tim_lf_config(struct roc_tim *roc_tim, uint8_t ring_id,
 {
 	struct sso *sso = roc_sso_to_sso_priv(roc_tim->roc_sso);
 	struct dev *dev = &sso->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct tim_config_req *req;
 	int rc = -ENOSPC;
 
-	plt_spinlock_lock(&sso->mbox_lock);
-	req = mbox_alloc_msg_tim_config_ring(dev->mbox);
+	req = mbox_alloc_msg_tim_config_ring(mbox);
 	if (req == NULL)
 		goto fail;
 	req->ring = ring_id;
@@ -178,14 +184,14 @@ roc_tim_lf_config(struct roc_tim *roc_tim, uint8_t ring_id,
 	req->clockfreq = clockfreq;
 	req->gpioedge = TIM_GPIO_LTOH_TRANS;
 
-	rc = mbox_process(dev->mbox);
+	rc = mbox_process(mbox);
 	if (rc) {
 		tim_err_desc(rc);
 		rc = -EIO;
 	}
 
 fail:
-	plt_spinlock_unlock(&sso->mbox_lock);
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -196,12 +202,12 @@ roc_tim_lf_interval(struct roc_tim *roc_tim, enum roc_tim_clk_src clk_src,
 {
 	struct sso *sso = roc_sso_to_sso_priv(roc_tim->roc_sso);
 	struct dev *dev = &sso->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	struct tim_intvl_req *req;
 	struct tim_intvl_rsp *rsp;
 	int rc = -ENOSPC;
 
-	plt_spinlock_lock(&sso->mbox_lock);
-	req = mbox_alloc_msg_tim_get_min_intvl(dev->mbox);
+	req = mbox_alloc_msg_tim_get_min_intvl(mbox);
 	if (req == NULL)
 		goto fail;
 
@@ -218,7 +224,7 @@ roc_tim_lf_interval(struct roc_tim *roc_tim, enum roc_tim_clk_src clk_src,
 	*interval = rsp->intvl_cyc;
 
 fail:
-	plt_spinlock_unlock(&sso->mbox_lock);
+	mbox_put(mbox);
 	return rc;
 }
 
@@ -231,17 +237,17 @@ roc_tim_lf_alloc(struct roc_tim *roc_tim, uint8_t ring_id, uint64_t *clk)
 	struct tim_lf_alloc_req *req;
 	struct tim_lf_alloc_rsp *rsp;
 	struct dev *dev = &sso->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 	int rc = -ENOSPC;
 
-	plt_spinlock_lock(&sso->mbox_lock);
-	req = mbox_alloc_msg_tim_lf_alloc(dev->mbox);
+	req = mbox_alloc_msg_tim_lf_alloc(mbox);
 	if (req == NULL)
 		goto fail;
 	req->npa_pf_func = idev_npa_pffunc_get();
 	req->sso_pf_func = idev_sso_pffunc_get();
 	req->ring = ring_id;
 
-	rc = mbox_process_msg(dev->mbox, (void **)&rsp);
+	rc = mbox_process_msg(mbox, (void **)&rsp);
 	if (rc) {
 		tim_err_desc(rc);
 		rc = -EIO;
@@ -255,19 +261,19 @@ roc_tim_lf_alloc(struct roc_tim *roc_tim, uint8_t ring_id, uint64_t *clk)
 				   tim->tim_msix_offsets[ring_id]);
 	if (rc < 0) {
 		plt_tim_dbg("Failed to register Ring[%d] IRQ", ring_id);
-		free_req = mbox_alloc_msg_tim_lf_free(dev->mbox);
+		free_req = mbox_alloc_msg_tim_lf_free(mbox);
 		if (free_req == NULL) {
 			rc = -ENOSPC;
 			goto fail;
 		}
 		free_req->ring = ring_id;
-		rc = mbox_process(dev->mbox);
+		rc = mbox_process(mbox);
 		if (rc)
 			rc = -EIO;
 	}
 
 fail:
-	plt_spinlock_unlock(&sso->mbox_lock);
+	mbox_put(dev->mbox);
 	return rc;
 }
 
@@ -283,8 +289,7 @@ roc_tim_lf_free(struct roc_tim *roc_tim, uint8_t ring_id)
 	tim_unregister_irq_priv(roc_tim, sso->pci_dev->intr_handle, ring_id,
 				tim->tim_msix_offsets[ring_id]);
 
-	plt_spinlock_lock(&sso->mbox_lock);
-	req = mbox_alloc_msg_tim_lf_free(dev->mbox);
+	req = mbox_alloc_msg_tim_lf_free(mbox_get(dev->mbox));
 	if (req == NULL)
 		goto fail;
 	req->ring = ring_id;
@@ -293,11 +298,13 @@ roc_tim_lf_free(struct roc_tim *roc_tim, uint8_t ring_id)
 	if (rc < 0) {
 		tim_err_desc(rc);
 		rc = -EIO;
+		goto fail;
 	}
+	rc = 0;
 
 fail:
-	plt_spinlock_unlock(&sso->mbox_lock);
-	return 0;
+	mbox_put(dev->mbox);
+	return rc;
 }
 
 int
@@ -318,8 +325,7 @@ roc_tim_init(struct roc_tim *roc_tim)
 	dev = &sso->dev;
 	PLT_STATIC_ASSERT(sizeof(struct tim) <= TIM_MEM_SZ);
 	nb_lfs = roc_tim->nb_lfs;
-	plt_spinlock_lock(&sso->mbox_lock);
-	mbox_alloc_msg_free_rsrc_cnt(dev->mbox);
+	mbox_alloc_msg_free_rsrc_cnt(mbox_get(dev->mbox));
 	rc = mbox_process_msg(dev->mbox, (void *)&free_rsrc);
 	if (rc) {
 		plt_err("Unable to get free rsrc count.");
@@ -350,11 +356,12 @@ roc_tim_init(struct roc_tim *roc_tim)
 		goto fail;
 	}
 
+	mbox_put(dev->mbox);
 	rc = tim_fill_msix(roc_tim, nb_lfs);
 	if (rc < 0) {
 		plt_err("Unable to get TIM MSIX vectors");
 
-		detach_req = mbox_alloc_msg_detach_resources(dev->mbox);
+		detach_req = mbox_alloc_msg_detach_resources(mbox_get(dev->mbox));
 		if (detach_req == NULL) {
 			nb_lfs = 0;
 			goto fail;
@@ -363,10 +370,13 @@ roc_tim_init(struct roc_tim *roc_tim)
 		detach_req->timlfs = true;
 		mbox_process(dev->mbox);
 		nb_lfs = 0;
+	} else {
+		goto done;
 	}
 
 fail:
-	plt_spinlock_unlock(&sso->mbox_lock);
+	mbox_put(dev->mbox);
+done:
 	return nb_lfs;
 }
 
@@ -376,13 +386,13 @@ roc_tim_fini(struct roc_tim *roc_tim)
 	struct sso *sso = roc_sso_to_sso_priv(roc_tim->roc_sso);
 	struct rsrc_detach_req *detach_req;
 	struct dev *dev = &sso->dev;
+	struct mbox *mbox = mbox_get(dev->mbox);
 
-	plt_spinlock_lock(&sso->mbox_lock);
-	detach_req = mbox_alloc_msg_detach_resources(dev->mbox);
+	detach_req = mbox_alloc_msg_detach_resources(mbox);
 	PLT_ASSERT(detach_req);
 	detach_req->partial = true;
 	detach_req->timlfs = true;
 
-	mbox_process(dev->mbox);
-	plt_spinlock_unlock(&sso->mbox_lock);
+	mbox_process(mbox);
+	mbox_put(mbox);
 }
-- 
2.25.1

