From f3c72cfa72967ad1377e228728500b529de7508c Mon Sep 17 00:00:00 2001
From: Pavan Nikhilesh <pbhagavatula@marvell.com>
Date: Fri, 24 Nov 2023 01:29:51 +0530
Subject: [PATCH 689/955] net/octeon_ep: move SSE routines to separate file

Move SSE routines to separate files, avoid if define clutter.

Signed-off-by: Pavan Nikhilesh <pbhagavatula@marvell.com>
Change-Id: Ic5750323c432fe48d762af981aaa33dd52e24cb3
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/116604
Base-Builds: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Base-Tests: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Reviewed-by: Jerin Jacob Kollanukkaran <jerinj@marvell.com>
---
 drivers/net/octeon_ep/cnxk_ep_rx.c     | 127 -------------------------
 drivers/net/octeon_ep/cnxk_ep_rx_sse.c | 124 ++++++++++++++++++++++++
 drivers/net/octeon_ep/meson.build      |  25 ++---
 3 files changed, 138 insertions(+), 138 deletions(-)
 create mode 100644 drivers/net/octeon_ep/cnxk_ep_rx_sse.c

diff --git a/drivers/net/octeon_ep/cnxk_ep_rx.c b/drivers/net/octeon_ep/cnxk_ep_rx.c
index d2b5fd7f0fbed..f3e4fb27d1c21 100644
--- a/drivers/net/octeon_ep/cnxk_ep_rx.c
+++ b/drivers/net/octeon_ep/cnxk_ep_rx.c
@@ -4,81 +4,6 @@
 
 #include "cnxk_ep_rx.h"
 
-#ifdef RTE_ARCH_X86
-static __rte_always_inline uint32_t
-hadd(__m128i x)
-{
-	__m128i hi64 = _mm_shuffle_epi32(x, _MM_SHUFFLE(1, 0, 3, 2));
-	__m128i sum64 = _mm_add_epi32(hi64, x);
-	__m128i hi32 = _mm_shufflelo_epi16(sum64, _MM_SHUFFLE(1, 0, 3, 2));
-	__m128i sum32 = _mm_add_epi32(sum64, hi32);
-	return _mm_cvtsi128_si32(sum32);
-}
-
-static __rte_always_inline void
-cnxk_ep_process_pkts_vec_sse(struct rte_mbuf **rx_pkts, struct otx_ep_droq *droq, uint16_t new_pkts)
-{
-	struct rte_mbuf **recv_buf_list = droq->recv_buf_list;
-	uint32_t bytes_rsvd = 0, read_idx = droq->read_idx;
-	uint32_t idx0, idx1, idx2, idx3;
-	struct rte_mbuf *m0, *m1, *m2, *m3;
-	uint16_t nb_desc = droq->nb_desc;
-	uint16_t pkts = 0;
-
-	idx0 = read_idx;
-	while (pkts < new_pkts) {
-		const __m128i bswap_mask = _mm_set_epi8(0xFF, 0xFF, 12, 13, 0xFF, 0xFF, 8, 9, 0xFF,
-							0xFF, 4, 5, 0xFF, 0xFF, 0, 1);
-		const __m128i cpy_mask = _mm_set_epi8(0xFF, 0xFF, 9, 8, 0xFF, 0xFF, 9, 8, 0xFF,
-						      0xFF, 1, 0, 0xFF, 0xFF, 1, 0);
-		__m128i s01, s23;
-
-		idx1 = otx_ep_incr_index(idx0, 1, nb_desc);
-		idx2 = otx_ep_incr_index(idx1, 1, nb_desc);
-		idx3 = otx_ep_incr_index(idx2, 1, nb_desc);
-
-		m0 = recv_buf_list[idx0];
-		m1 = recv_buf_list[idx1];
-		m2 = recv_buf_list[idx2];
-		m3 = recv_buf_list[idx3];
-
-		s01 = _mm_set_epi32(rte_pktmbuf_mtod(m3, struct otx_ep_droq_info *)->length >> 48,
-				    rte_pktmbuf_mtod(m1, struct otx_ep_droq_info *)->length >> 48,
-				    rte_pktmbuf_mtod(m2, struct otx_ep_droq_info *)->length >> 48,
-				    rte_pktmbuf_mtod(m0, struct otx_ep_droq_info *)->length >> 48);
-		s01 = _mm_shuffle_epi8(s01, bswap_mask);
-		bytes_rsvd += hadd(s01);
-		s23 = _mm_shuffle_epi32(s01, _MM_SHUFFLE(3, 3, 1, 1));
-		s01 = _mm_shuffle_epi8(s01, cpy_mask);
-		s23 = _mm_shuffle_epi8(s23, cpy_mask);
-
-		*(uint64_t *)&m0->pkt_len = _mm_extract_epi64(s01, 0);
-		*(uint64_t *)&m1->pkt_len = _mm_extract_epi64(s01, 1);
-		*(uint64_t *)&m2->pkt_len = _mm_extract_epi64(s23, 0);
-		*(uint64_t *)&m3->pkt_len = _mm_extract_epi64(s23, 1);
-
-		*(uint64_t *)&m0->rearm_data = droq->rearm_data;
-		*(uint64_t *)&m1->rearm_data = droq->rearm_data;
-		*(uint64_t *)&m2->rearm_data = droq->rearm_data;
-		*(uint64_t *)&m3->rearm_data = droq->rearm_data;
-
-		rx_pkts[pkts++] = m0;
-		rx_pkts[pkts++] = m1;
-		rx_pkts[pkts++] = m2;
-		rx_pkts[pkts++] = m3;
-		idx0 = otx_ep_incr_index(idx3, 1, nb_desc);
-	}
-	droq->read_idx = idx0;
-
-	droq->refill_count += new_pkts;
-	droq->pkts_pending -= new_pkts;
-	/* Stats */
-	droq->stats.pkts_received += new_pkts;
-	droq->stats.bytes_received += bytes_rsvd;
-}
-
-#endif
-
 static __rte_always_inline void
 cnxk_ep_process_pkts_scalar_mseg(struct rte_mbuf **rx_pkts, struct otx_ep_droq *droq,
 				 uint16_t new_pkts)
@@ -160,26 +85,6 @@ cnxk_ep_recv_pkts(void *rx_queue, struct rte_mbuf **rx_pkts, uint16_t nb_pkts)
 	return new_pkts;
 }
 
-#ifdef RTE_ARCH_X86
-uint16_t __rte_noinline __rte_hot
-cnxk_ep_recv_pkts_sse(void *rx_queue, struct rte_mbuf **rx_pkts, uint16_t nb_pkts)
-{
-	struct otx_ep_droq *droq = (struct otx_ep_droq *)rx_queue;
-	uint16_t new_pkts, vpkts;
-
-	new_pkts = cnxk_ep_rx_pkts_to_process(droq, nb_pkts);
-	vpkts = RTE_ALIGN_FLOOR(new_pkts, CNXK_EP_OQ_DESC_PER_LOOP_SSE);
-	cnxk_ep_process_pkts_vec_sse(rx_pkts, droq, vpkts);
-	cnxk_ep_process_pkts_scalar(&rx_pkts[vpkts], droq, new_pkts - vpkts);
-
-	/* Refill RX buffers */
-	if (droq->refill_count >= DROQ_REFILL_THRESHOLD)
-		cnxk_ep_rx_refill(droq);
-
-	return new_pkts;
-}
-#endif
-
 uint16_t __rte_noinline __rte_hot
 cn9k_ep_recv_pkts(void *rx_queue, struct rte_mbuf **rx_pkts, uint16_t nb_pkts)
 {
@@ -207,38 +112,6 @@ cn9k_ep_recv_pkts(void *rx_queue, struct rte_mbuf **rx_pkts, uint16_t nb_pkts)
 	return new_pkts;
 }
 
-#ifdef RTE_ARCH_X86
-uint16_t __rte_noinline __rte_hot
-cn9k_ep_recv_pkts_sse(void *rx_queue, struct rte_mbuf **rx_pkts, uint16_t nb_pkts)
-{
-	struct otx_ep_droq *droq = (struct otx_ep_droq *)rx_queue;
-	uint16_t new_pkts, vpkts;
-
-	new_pkts = cnxk_ep_rx_pkts_to_process(droq, nb_pkts);
-	vpkts = RTE_ALIGN_FLOOR(new_pkts, CNXK_EP_OQ_DESC_PER_LOOP_SSE);
-	cnxk_ep_process_pkts_vec_sse(rx_pkts, droq, vpkts);
-	cnxk_ep_process_pkts_scalar(&rx_pkts[vpkts], droq, new_pkts - vpkts);
-
-	/* Refill RX buffers */
-	if (droq->refill_count >= DROQ_REFILL_THRESHOLD) {
-		cnxk_ep_rx_refill(droq);
-	} else {
-		/* SDP output goes into DROP state when output doorbell count
-		 * goes below drop count. When door bell count is written with
-		 * a value greater than drop count SDP output should come out
-		 * of DROP state. Due to a race condition this is not happening.
-		 * Writing doorbell register with 0 again may make SDP output
-		 * come out of this state.
-		 */
-
-		rte_write32(0, droq->pkts_credit_reg);
-	}
-
-	return new_pkts;
-}
-
-#endif
-
 uint16_t __rte_noinline __rte_hot
 cnxk_ep_recv_pkts_mseg(void *rx_queue, struct rte_mbuf **rx_pkts, uint16_t nb_pkts)
 {
diff --git a/drivers/net/octeon_ep/cnxk_ep_rx_sse.c b/drivers/net/octeon_ep/cnxk_ep_rx_sse.c
new file mode 100644
index 0000000000000..531f75a2e0510
--- /dev/null
+++ b/drivers/net/octeon_ep/cnxk_ep_rx_sse.c
@@ -0,0 +1,124 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(C) 2023 Marvell.
+ */
+
+#include "cnxk_ep_rx.h"
+
+static __rte_always_inline uint32_t
+hadd(__m128i x)
+{
+	__m128i hi64 = _mm_shuffle_epi32(x, _MM_SHUFFLE(1, 0, 3, 2));
+	__m128i sum64 = _mm_add_epi32(hi64, x);
+	__m128i hi32 = _mm_shufflelo_epi16(sum64, _MM_SHUFFLE(1, 0, 3, 2));
+	__m128i sum32 = _mm_add_epi32(sum64, hi32);
+	return _mm_cvtsi128_si32(sum32);
+}
+
+static __rte_always_inline void
+cnxk_ep_process_pkts_vec_sse(struct rte_mbuf **rx_pkts, struct otx_ep_droq *droq, uint16_t new_pkts)
+{
+	struct rte_mbuf **recv_buf_list = droq->recv_buf_list;
+	uint32_t bytes_rsvd = 0, read_idx = droq->read_idx;
+	uint32_t idx0, idx1, idx2, idx3;
+	struct rte_mbuf *m0, *m1, *m2, *m3;
+	uint16_t nb_desc = droq->nb_desc;
+	uint16_t pkts = 0;
+
+	idx0 = read_idx;
+	while (pkts < new_pkts) {
+		const __m128i bswap_mask = _mm_set_epi8(0xFF, 0xFF, 12, 13, 0xFF, 0xFF, 8, 9, 0xFF,
+							0xFF, 4, 5, 0xFF, 0xFF, 0, 1);
+		const __m128i cpy_mask = _mm_set_epi8(0xFF, 0xFF, 9, 8, 0xFF, 0xFF, 9, 8, 0xFF,
+						      0xFF, 1, 0, 0xFF, 0xFF, 1, 0);
+		__m128i s01, s23;
+
+		idx1 = otx_ep_incr_index(idx0, 1, nb_desc);
+		idx2 = otx_ep_incr_index(idx1, 1, nb_desc);
+		idx3 = otx_ep_incr_index(idx2, 1, nb_desc);
+
+		m0 = recv_buf_list[idx0];
+		m1 = recv_buf_list[idx1];
+		m2 = recv_buf_list[idx2];
+		m3 = recv_buf_list[idx3];
+
+		s01 = _mm_set_epi32(rte_pktmbuf_mtod(m3, struct otx_ep_droq_info *)->length >> 48,
+				    rte_pktmbuf_mtod(m1, struct otx_ep_droq_info *)->length >> 48,
+				    rte_pktmbuf_mtod(m2, struct otx_ep_droq_info *)->length >> 48,
+				    rte_pktmbuf_mtod(m0, struct otx_ep_droq_info *)->length >> 48);
+		s01 = _mm_shuffle_epi8(s01, bswap_mask);
+		bytes_rsvd += hadd(s01);
+		s23 = _mm_shuffle_epi32(s01, _MM_SHUFFLE(3, 3, 1, 1));
+		s01 = _mm_shuffle_epi8(s01, cpy_mask);
+		s23 = _mm_shuffle_epi8(s23, cpy_mask);
+
+		*(uint64_t *)&m0->pkt_len = _mm_extract_epi64(s01, 0);
+		*(uint64_t *)&m1->pkt_len = _mm_extract_epi64(s01, 1);
+		*(uint64_t *)&m2->pkt_len = _mm_extract_epi64(s23, 0);
+		*(uint64_t *)&m3->pkt_len = _mm_extract_epi64(s23, 1);
+
+		*(uint64_t *)&m0->rearm_data = droq->rearm_data;
+		*(uint64_t *)&m1->rearm_data = droq->rearm_data;
+		*(uint64_t *)&m2->rearm_data = droq->rearm_data;
+		*(uint64_t *)&m3->rearm_data = droq->rearm_data;
+
+		rx_pkts[pkts++] = m0;
+		rx_pkts[pkts++] = m1;
+		rx_pkts[pkts++] = m2;
+		rx_pkts[pkts++] = m3;
+		idx0 = otx_ep_incr_index(idx3, 1, nb_desc);
+	}
+	droq->read_idx = idx0;
+
+	droq->refill_count += new_pkts;
+	droq->pkts_pending -= new_pkts;
+	/* Stats */
+	droq->stats.pkts_received += new_pkts;
+	droq->stats.bytes_received += bytes_rsvd;
+}
+
+uint16_t __rte_noinline __rte_hot
+cnxk_ep_recv_pkts_sse(void *rx_queue, struct rte_mbuf **rx_pkts, uint16_t nb_pkts)
+{
+	struct otx_ep_droq *droq = (struct otx_ep_droq *)rx_queue;
+	uint16_t new_pkts, vpkts;
+
+	new_pkts = cnxk_ep_rx_pkts_to_process(droq, nb_pkts);
+	vpkts = RTE_ALIGN_FLOOR(new_pkts, CNXK_EP_OQ_DESC_PER_LOOP_SSE);
+	cnxk_ep_process_pkts_vec_sse(rx_pkts, droq, vpkts);
+	cnxk_ep_process_pkts_scalar(&rx_pkts[vpkts], droq, new_pkts - vpkts);
+
+	/* Refill RX buffers */
+	if (droq->refill_count >= DROQ_REFILL_THRESHOLD)
+		cnxk_ep_rx_refill(droq);
+
+	return new_pkts;
+}
+
+uint16_t __rte_noinline __rte_hot
+cn9k_ep_recv_pkts_sse(void *rx_queue, struct rte_mbuf **rx_pkts, uint16_t nb_pkts)
+{
+	struct otx_ep_droq *droq = (struct otx_ep_droq *)rx_queue;
+	uint16_t new_pkts, vpkts;
+
+	new_pkts = cnxk_ep_rx_pkts_to_process(droq, nb_pkts);
+	vpkts = RTE_ALIGN_FLOOR(new_pkts, CNXK_EP_OQ_DESC_PER_LOOP_SSE);
+	cnxk_ep_process_pkts_vec_sse(rx_pkts, droq, vpkts);
+	cnxk_ep_process_pkts_scalar(&rx_pkts[vpkts], droq, new_pkts - vpkts);
+
+	/* Refill RX buffers */
+	if (droq->refill_count >= DROQ_REFILL_THRESHOLD) {
+		cnxk_ep_rx_refill(droq);
+	} else {
+		/* SDP output goes into DROP state when output doorbell count
+		 * goes below drop count. When door bell count is written with
+		 * a value greater than drop count SDP output should come out
+		 * of DROP state. Due to a race condition this is not happening.
+		 * Writing doorbell register with 0 again may make SDP output
+		 * come out of this state.
+		 */
+
+		rte_write32(0, droq->pkts_credit_reg);
+	}
+
+	return new_pkts;
+}
diff --git a/drivers/net/octeon_ep/meson.build b/drivers/net/octeon_ep/meson.build
index 97b5538aabf52..e8ae56018d332 100644
--- a/drivers/net/octeon_ep/meson.build
+++ b/drivers/net/octeon_ep/meson.build
@@ -13,17 +13,20 @@ sources = files(
         'cnxk_ep_tx.c',
 )
 
-if cc.get_define('__AVX2__', args: machine_args) != ''
-    cflags += ['-DCC_AVX2_SUPPORT']
-    sources += files('cnxk_ep_rx_avx.c')
-elif cc.has_argument('-mavx2')
-    cflags += ['-DCC_AVX2_SUPPORT']
-    otx_ep_avx2_lib = static_library('otx_ep_avx2_lib',
-                    'cnxk_ep_rx_avx.c',
-                    dependencies: [static_rte_ethdev, static_rte_pci, static_rte_bus_pci],
-                    include_directories: includes,
-                    c_args: [cflags, '-mavx2'])
-    objs += otx_ep_avx2_lib.extract_objects('cnxk_ep_rx_avx.c')
+if arch_subdir == 'x86'
+    sources += files('cnxk_ep_rx_sse.c')
+    if cc.get_define('__AVX2__', args: machine_args) != ''
+        cflags += ['-DCC_AVX2_SUPPORT']
+        sources += files('cnxk_ep_rx_avx.c')
+    elif cc.has_argument('-mavx2')
+        cflags += ['-DCC_AVX2_SUPPORT']
+        otx_ep_avx2_lib = static_library('otx_ep_avx2_lib',
+                        'cnxk_ep_rx_avx.c',
+                        dependencies: [static_rte_ethdev, static_rte_pci, static_rte_bus_pci],
+                        include_directories: includes,
+                        c_args: [cflags, '-mavx2'])
+        objs += otx_ep_avx2_lib.extract_objects('cnxk_ep_rx_avx.c')
+    endif
 endif
 
 extra_flags = ['-Wno-strict-aliasing']
-- 
2.25.1

