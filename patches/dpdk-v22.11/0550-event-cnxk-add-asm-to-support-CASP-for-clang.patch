From 16b0dfc314a9121d595013ecb8d149cb7f4d535f Mon Sep 17 00:00:00 2001
From: Pavan Nikhilesh <pbhagavatula@marvell.com>
Date: Wed, 19 Jul 2023 05:01:45 +0530
Subject: [PATCH 550/955] event/cnxk: add asm to support CASP for clang

Clang fails to use register pairs for CASP instruction, use
inline asm to fix register pairs.

Signed-off-by: Pavan Nikhilesh <pbhagavatula@marvell.com>
Change-Id: If0c780252d5469a32c7bd65722e5224ea802fdc8
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/107764
Base-Builds: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Base-Tests: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Reviewed-by: Jerin Jacob Kollanukkaran <jerinj@marvell.com>
(cherry picked from commit 924f15bc14ffa25035f92b25c2e2b0dec71a01f4)
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/108122
Tested-by: Jerin Jacob Kollanukkaran <jerinj@marvell.com>
---
 drivers/event/cnxk/cn10k_worker.h | 15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

diff --git a/drivers/event/cnxk/cn10k_worker.h b/drivers/event/cnxk/cn10k_worker.h
index 3af43e28eff20..d1c278ce6ed9f 100644
--- a/drivers/event/cnxk/cn10k_worker.h
+++ b/drivers/event/cnxk/cn10k_worker.h
@@ -255,19 +255,32 @@ cn10k_sso_hws_get_work(struct cn10k_sso_hws *ws, struct rte_event *ev,
 	} gw;
 
 	gw.get_work = ws->gw_wdata;
-#if defined(RTE_ARCH_ARM64) && !defined(__clang__)
+#if defined(RTE_ARCH_ARM64)
+#if !defined(__clang__)
 	asm volatile(
 		PLT_CPU_FEATURE_PREAMBLE
 		"caspal %[wdata], %H[wdata], %[wdata], %H[wdata], [%[gw_loc]]\n"
 		: [wdata] "+r"(gw.get_work)
 		: [gw_loc] "r"(ws->base + SSOW_LF_GWS_OP_GET_WORK0)
 		: "memory");
+#else
+	register uint64_t x0 __asm("x0") = (uint64_t)gw.u64[0];
+	register uint64_t x1 __asm("x1") = (uint64_t)gw.u64[1];
+	asm volatile(".arch armv8-a+lse\n"
+		     "caspal %[x0], %[x1], %[x0], %[x1], [%[dst]]\n"
+		     : [x0] "+r"(x0), [x1] "+r"(x1)
+		     : [dst] "r"(ws->base + SSOW_LF_GWS_OP_GET_WORK0)
+		     : "memory");
+	gw.u64[0] = x0;
+	gw.u64[1] = x1;
+#endif
 #else
 	plt_write64(gw.u64[0], ws->base + SSOW_LF_GWS_OP_GET_WORK0);
 	do {
 		roc_load_pair(gw.u64[0], gw.u64[1],
 			      ws->base + SSOW_LF_GWS_WQE0);
 	} while (gw.u64[0] & BIT_ULL(63));
+	rte_smp_mb();
 #endif
 	ws->gw_rdata = gw.u64[0];
 	if (gw.u64[1])
-- 
2.25.1

