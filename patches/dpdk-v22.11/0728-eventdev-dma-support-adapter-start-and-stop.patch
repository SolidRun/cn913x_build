From ca00f01b0359e34768094f7a1eb676e975b34a6a Mon Sep 17 00:00:00 2001
From: Amit Prakash Shukla <amitprakashs@marvell.com>
Date: Fri, 29 Sep 2023 17:20:45 +0530
Subject: [PATCH 728/955] eventdev/dma: support adapter start and stop

Added API support to start and stop DMA adapter.

Signed-off-by: Amit Prakash Shukla <amitprakashs@marvell.com>
Change-Id: I71aeb53b4a3a9b7b74eaf8b4f044b4030b60314c
---
 lib/eventdev/rte_event_dma_adapter.c | 69 ++++++++++++++++++++++++++++
 1 file changed, 69 insertions(+)

diff --git a/lib/eventdev/rte_event_dma_adapter.c b/lib/eventdev/rte_event_dma_adapter.c
index 1d8bae0422c83..be6c2623e9316 100644
--- a/lib/eventdev/rte_event_dma_adapter.c
+++ b/lib/eventdev/rte_event_dma_adapter.c
@@ -74,6 +74,13 @@ struct dma_device_info {
 	/* Next queue pair to be processed */
 	uint16_t next_vchan_id;
 
+	/* Set to indicate processing has been started */
+	uint8_t dev_started;
+
+	/* Set to indicate dmadev->eventdev packet
+	 * transfer uses a hardware mechanism
+	 */
+	uint8_t internal_event_port;
 } __rte_cache_aligned;
 
 struct event_dma_adapter {
@@ -1129,3 +1136,65 @@ rte_event_dma_adapter_vchan_del(uint8_t id, int16_t dma_dev_id, uint16_t vchan)
 
 	return ret;
 }
+
+static int
+edma_adapter_ctrl(uint8_t id, int start)
+{
+	struct event_dma_adapter *adapter;
+	struct dma_device_info *dev_info;
+	struct rte_eventdev *dev;
+	uint16_t num_dma_dev;
+	int stop = !start;
+	int use_service;
+	uint32_t i;
+
+	use_service = 0;
+	EVENT_DMA_ADAPTER_ID_VALID_OR_ERR_RET(id, -EINVAL);
+	adapter = edma_id_to_adapter(id);
+	if (adapter == NULL)
+		return -EINVAL;
+
+	num_dma_dev = rte_dma_count_avail();
+	dev = &rte_eventdevs[adapter->eventdev_id];
+
+	for (i = 0; i < num_dma_dev; i++) {
+		dev_info = &adapter->dma_devs[i];
+		/* start check for num queue pairs */
+		if (start && !dev_info->num_vchanq)
+			continue;
+		/* stop check if dev has been started */
+		if (stop && !dev_info->dev_started)
+			continue;
+		use_service |= !dev_info->internal_event_port;
+		dev_info->dev_started = start;
+		if (dev_info->internal_event_port == 0)
+			continue;
+		start ? (*dev->dev_ops->dma_adapter_start)(dev, i) :
+			(*dev->dev_ops->dma_adapter_stop)(dev, i);
+	}
+
+	if (use_service)
+		rte_service_runstate_set(adapter->service_id, start);
+
+	return 0;
+}
+
+int
+rte_event_dma_adapter_start(uint8_t id)
+{
+	struct event_dma_adapter *adapter;
+
+	EVENT_DMA_ADAPTER_ID_VALID_OR_ERR_RET(id, -EINVAL);
+
+	adapter = edma_id_to_adapter(id);
+	if (adapter == NULL)
+		return -EINVAL;
+
+	return edma_adapter_ctrl(id, 1);
+}
+
+int
+rte_event_dma_adapter_stop(uint8_t id)
+{
+	return edma_adapter_ctrl(id, 0);
+}
-- 
2.25.1

