From bcd64827a6e0aa692ac609a912986769c7425f04 Mon Sep 17 00:00:00 2001
From: Ashwin Sekhar T K <asekhar@marvell.com>
Date: Wed, 29 Mar 2023 09:53:44 +0530
Subject: [PATCH 357/955] mempool/cnxk: avoid indefinite wait when counting
 batch alloc pointers

Avoid waiting indefinitely when counting batch alloc pointers by adding a
wait timeout.

Signed-off-by: Ashwin Sekhar T K <asekhar@marvell.com>
Change-Id: Ie3f5c39937c6ec758adf7d082bd61678d30606d6
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/100460
Base-Builds: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Base-Tests: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Reviewed-by: Jerin Jacob Kollanukkaran <jerinj@marvell.com>
---
 drivers/common/cnxk/roc_npa.h            | 15 +++++++++------
 drivers/mempool/cnxk/cn10k_mempool_ops.c |  3 ++-
 2 files changed, 11 insertions(+), 7 deletions(-)

diff --git a/drivers/common/cnxk/roc_npa.h b/drivers/common/cnxk/roc_npa.h
index a1511244db9c4..7f613327dcaf9 100644
--- a/drivers/common/cnxk/roc_npa.h
+++ b/drivers/common/cnxk/roc_npa.h
@@ -241,19 +241,23 @@ roc_npa_aura_batch_alloc_issue(uint64_t aura_handle, uint64_t *buf,
 }
 
 static inline void
-roc_npa_batch_alloc_wait(uint64_t *cache_line)
+roc_npa_batch_alloc_wait(uint64_t *cache_line, unsigned int wait_us)
 {
+	const uint64_t ticks = (uint64_t)wait_us * plt_tsc_hz() / (uint64_t)1E6;
+	const uint64_t start = plt_tsc_cycles();
+
 	/* Batch alloc status code is updated in bits [5:6] of the first word
 	 * of the 128 byte cache line.
 	 */
 	while (((__atomic_load_n(cache_line, __ATOMIC_RELAXED) >> 5) & 0x3) ==
 	       ALLOC_CCODE_INVAL)
-		;
+		if (wait_us && (plt_tsc_cycles() - start) >= ticks)
+			break;
 }
 
 static inline unsigned int
 roc_npa_aura_batch_alloc_count(uint64_t *aligned_buf, unsigned int num,
-			       unsigned int do_wait)
+			       unsigned int wait_us)
 {
 	unsigned int count, i;
 
@@ -267,8 +271,7 @@ roc_npa_aura_batch_alloc_count(uint64_t *aligned_buf, unsigned int num,
 
 		status = (struct npa_batch_alloc_status_s *)&aligned_buf[i];
 
-		if (do_wait)
-			roc_npa_batch_alloc_wait(&aligned_buf[i]);
+		roc_npa_batch_alloc_wait(&aligned_buf[i], wait_us);
 
 		count += status->count;
 	}
@@ -293,7 +296,7 @@ roc_npa_aura_batch_alloc_extract(uint64_t *buf, uint64_t *aligned_buf,
 
 		status = (struct npa_batch_alloc_status_s *)&aligned_buf[i];
 
-		roc_npa_batch_alloc_wait(&aligned_buf[i]);
+		roc_npa_batch_alloc_wait(&aligned_buf[i], 0);
 
 		line_count = status->count;
 
diff --git a/drivers/mempool/cnxk/cn10k_mempool_ops.c b/drivers/mempool/cnxk/cn10k_mempool_ops.c
index ba826f0f01618..ff0015d8ded63 100644
--- a/drivers/mempool/cnxk/cn10k_mempool_ops.c
+++ b/drivers/mempool/cnxk/cn10k_mempool_ops.c
@@ -9,6 +9,7 @@
 
 #define BATCH_ALLOC_SZ              ROC_CN10K_NPA_BATCH_ALLOC_MAX_PTRS
 #define BATCH_OP_DATA_TABLE_MZ_NAME "batch_op_data_table_mz"
+#define BATCH_ALLOC_WAIT_US         5
 
 enum batch_op_status {
 	BATCH_ALLOC_OP_NOT_ISSUED = 0,
@@ -178,7 +179,7 @@ cn10k_mempool_get_count(const struct rte_mempool *mp)
 
 		if (mem->status == BATCH_ALLOC_OP_ISSUED)
 			count += roc_npa_aura_batch_alloc_count(
-				mem->objs, BATCH_ALLOC_SZ, 1);
+				mem->objs, BATCH_ALLOC_SZ, BATCH_ALLOC_WAIT_US);
 
 		if (mem->status == BATCH_ALLOC_OP_DONE)
 			count += mem->sz;
-- 
2.25.1

