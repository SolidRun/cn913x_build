From 96aca2e7e974462dd805af2a4e771ad3bbc3f33b Mon Sep 17 00:00:00 2001
From: Nithin Dabilpuram <ndabilpuram@marvell.com>
Date: Fri, 10 Mar 2023 17:58:02 +0530
Subject: [PATCH 303/955] common/cnxk: fetch eng caps for inl outb inst format

Fetch engine caps and use it along with model check
to determine inline outbound instruction format
with NIX Tx offset or address.

Change-Id: I14a0047d65d5bb0597d581d860f671731c9d2169
Signed-off-by: Nithin Dabilpuram <ndabilpuram@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/98908
Base-Builds: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Base-Tests: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Reviewed-by: Srujana Challa <schalla@marvell.com>
Reviewed-by: Jerin Jacob Kollanukkaran <jerinj@marvell.com>
---
 drivers/common/cnxk/roc_cpt.h       |   3 +
 drivers/common/cnxk/roc_nix_inl.c   | 101 ++++++++++++++++++++++++++++
 drivers/common/cnxk/roc_nix_inl.h   |   1 +
 drivers/common/cnxk/roc_nix_priv.h  |   1 +
 drivers/common/cnxk/version.map     |   1 +
 drivers/net/cnxk/cn10k_ethdev_sec.c |   3 +-
 drivers/net/cnxk/cnxk_ethdev.c      |   2 +
 drivers/net/cnxk/cnxk_ethdev.h      |   3 +
 8 files changed, 114 insertions(+), 1 deletion(-)

diff --git a/drivers/common/cnxk/roc_cpt.h b/drivers/common/cnxk/roc_cpt.h
index 934183ab4d2c3..d541ddcdf009e 100644
--- a/drivers/common/cnxk/roc_cpt.h
+++ b/drivers/common/cnxk/roc_cpt.h
@@ -12,6 +12,9 @@
 #define ROC_AE_CPT_BLOCK_TYPE1 0
 #define ROC_AE_CPT_BLOCK_TYPE2 1
 
+#define ROC_LOADFVC_MAJOR_OP 0x01UL
+#define ROC_LOADFVC_MINOR_OP 0x08UL
+
 /* Default engine groups */
 #define ROC_CPT_DFLT_ENG_GRP_SE	   0UL
 #define ROC_CPT_DFLT_ENG_GRP_SE_IE 1UL
diff --git a/drivers/common/cnxk/roc_nix_inl.c b/drivers/common/cnxk/roc_nix_inl.c
index 8592e1cb0b677..c36d15c7fb38a 100644
--- a/drivers/common/cnxk/roc_nix_inl.c
+++ b/drivers/common/cnxk/roc_nix_inl.c
@@ -602,6 +602,96 @@ nix_inl_rq_mask_cfg(struct roc_nix *roc_nix, bool enable)
 	return rc;
 }
 
+static void
+nix_inl_eng_caps_get(struct nix *nix)
+{
+	struct roc_cpt_lf *lf = nix->cpt_lf_base;
+	uintptr_t lmt_base = lf->lmt_base;
+	union cpt_res_s res, *hw_res;
+	struct cpt_inst_s inst;
+	uint64_t *rptr;
+
+	hw_res = plt_zmalloc(sizeof(*hw_res), ROC_CPT_RES_ALIGN);
+	if (hw_res == NULL) {
+		plt_err("Couldn't allocate memory for result address");
+		return;
+	}
+
+	rptr = plt_zmalloc(ROC_ALIGN, 0);
+	if (rptr == NULL) {
+		plt_err("Couldn't allocate memory for rptr");
+		plt_free(hw_res);
+		return;
+	}
+
+	/* Fill CPT_INST_S for WRITE_SA microcode op */
+	memset(&inst, 0, sizeof(struct cpt_inst_s));
+	inst.res_addr = (uint64_t)hw_res;
+	inst.rptr = (uint64_t)rptr;
+	inst.w4.s.opcode_major = ROC_LOADFVC_MAJOR_OP;
+	inst.w4.s.opcode_minor = ROC_LOADFVC_MINOR_OP;
+	inst.w7.s.egrp = ROC_CPT_DFLT_ENG_GRP_SE;
+
+	/* Use 1 min timeout for the poll */
+	const uint64_t timeout = plt_tsc_cycles() + 60 * plt_tsc_hz();
+
+	if (roc_model_is_cn9k()) {
+		uint64_t lmt_status;
+
+		hw_res->cn9k.compcode = CPT_COMP_NOT_DONE;
+		rte_io_wmb();
+
+		do {
+			roc_lmt_mov_seg((void *)lmt_base, &inst, 4);
+			lmt_status = roc_lmt_submit_ldeor(lf->io_addr);
+		} while (lmt_status != 0);
+
+		/* Wait until CPT instruction completes */
+		do {
+			res.u64[0] = __atomic_load_n(&hw_res->u64[0], __ATOMIC_RELAXED);
+			if (unlikely(plt_tsc_cycles() > timeout))
+				break;
+		} while (res.cn9k.compcode == CPT_COMP_NOT_DONE);
+
+		if (res.cn9k.compcode != CPT_COMP_GOOD) {
+			plt_err("LOAD FVC operation timed out");
+			return;
+		}
+	} else {
+		uint64_t lmt_arg, io_addr;
+		uint16_t lmt_id;
+
+		hw_res->cn10k.compcode = CPT_COMP_NOT_DONE;
+
+		/* Use this lcore's LMT line as no one else is using it */
+		ROC_LMT_BASE_ID_GET(lmt_base, lmt_id);
+		memcpy((void *)lmt_base, &inst, sizeof(inst));
+
+		lmt_arg = ROC_CN10K_CPT_LMT_ARG | (uint64_t)lmt_id;
+		io_addr = lf->io_addr | ROC_CN10K_CPT_INST_DW_M1 << 4;
+
+		roc_lmt_submit_steorl(lmt_arg, io_addr);
+		plt_io_wmb();
+
+		/* Wait until CPT instruction completes */
+		do {
+			res.u64[0] = __atomic_load_n(&hw_res->u64[0], __ATOMIC_RELAXED);
+			if (unlikely(plt_tsc_cycles() > timeout))
+				break;
+		} while (res.cn10k.compcode == CPT_COMP_NOT_DONE);
+
+		if (res.cn10k.compcode != CPT_COMP_GOOD || res.cn10k.uc_compcode) {
+			plt_err("LOAD FVC operation timed out");
+			return;
+		}
+	}
+
+	nix->cpt_eng_caps = plt_be_to_cpu_64(*rptr);
+
+	plt_free(rptr);
+	plt_free(hw_res);
+}
+
 int
 roc_nix_inl_inb_init(struct roc_nix *roc_nix)
 {
@@ -652,6 +742,7 @@ roc_nix_inl_inb_init(struct roc_nix *roc_nix)
 		plt_err("Failed to setup inbound lf, rc=%d", rc);
 		return rc;
 	}
+	nix->cpt_eng_caps = roc_cpt->hw_caps[CPT_ENG_TYPE_SE].u;
 
 	/* Setup Inbound SA table */
 	rc = nix_inl_inb_sa_tbl_setup(roc_nix);
@@ -871,6 +962,8 @@ roc_nix_inl_outb_init(struct roc_nix *roc_nix)
 		}
 	}
 
+	/* Fetch engine capabilities */
+	nix_inl_eng_caps_get(nix);
 	return 0;
 
 lf_fini:
@@ -1571,3 +1664,11 @@ roc_nix_inl_meta_pool_cb_register(roc_nix_inl_meta_pool_cb_t cb)
 {
 	meta_pool_cb = cb;
 }
+
+uint64_t
+roc_nix_inl_eng_caps_get(struct roc_nix *roc_nix)
+{
+	struct nix *nix = roc_nix_to_nix_priv(roc_nix);
+
+	return nix->cpt_eng_caps;
+}
diff --git a/drivers/common/cnxk/roc_nix_inl.h b/drivers/common/cnxk/roc_nix_inl.h
index 6220ba6773978..daa21a941a25d 100644
--- a/drivers/common/cnxk/roc_nix_inl.h
+++ b/drivers/common/cnxk/roc_nix_inl.h
@@ -212,5 +212,6 @@ int __roc_api roc_nix_inl_sa_sync(struct roc_nix *roc_nix, void *sa, bool inb,
 int __roc_api roc_nix_inl_ctx_write(struct roc_nix *roc_nix, void *sa_dptr,
 				    void *sa_cptr, bool inb, uint16_t sa_len);
 void __roc_api roc_nix_inl_outb_cpt_lfs_dump(struct roc_nix *roc_nix, FILE *file);
+uint64_t __roc_api roc_nix_inl_eng_caps_get(struct roc_nix *roc_nix);
 
 #endif /* _ROC_NIX_INL_H_ */
diff --git a/drivers/common/cnxk/roc_nix_priv.h b/drivers/common/cnxk/roc_nix_priv.h
index f900a81d8aca2..6872630dc870d 100644
--- a/drivers/common/cnxk/roc_nix_priv.h
+++ b/drivers/common/cnxk/roc_nix_priv.h
@@ -209,6 +209,7 @@ struct nix {
 	uint16_t outb_se_ring_base;
 	uint16_t cpt_lbpid;
 	uint16_t cpt_nixbpid;
+	uint64_t cpt_eng_caps;
 	bool need_meta_aura;
 	/* Mode provided by driver */
 	bool inb_inl_dev;
diff --git a/drivers/common/cnxk/version.map b/drivers/common/cnxk/version.map
index ff31f4b536915..812cd9398fa05 100644
--- a/drivers/common/cnxk/version.map
+++ b/drivers/common/cnxk/version.map
@@ -157,6 +157,7 @@ INTERNAL {
 	roc_nix_inl_dev_rq_put;
 	roc_nix_inl_dev_unlock;
 	roc_nix_inl_dev_xaq_realloc;
+	roc_nix_inl_eng_caps_get;
 	roc_nix_inl_inb_is_enabled;
 	roc_nix_inl_inb_init;
 	roc_nix_inl_inb_sa_base_get;
diff --git a/drivers/net/cnxk/cn10k_ethdev_sec.c b/drivers/net/cnxk/cn10k_ethdev_sec.c
index 3c32de0f94b50..9625704ec1f28 100644
--- a/drivers/net/cnxk/cn10k_ethdev_sec.c
+++ b/drivers/net/cnxk/cn10k_ethdev_sec.c
@@ -809,7 +809,8 @@ cn10k_eth_sec_session_create(void *device,
 		sess_priv.chksum = (!ipsec->options.ip_csum_enable << 1 |
 				    !ipsec->options.l4_csum_enable);
 		sess_priv.dec_ttl = ipsec->options.dec_ttl;
-		if (roc_feature_nix_has_inl_ipsec_mseg())
+		if (roc_feature_nix_has_inl_ipsec_mseg() &&
+		    dev->outb.cpt_eng_caps & BIT_ULL(35))
 			sess_priv.nixtx_off = 1;
 
 		/* Pointer from eth_sec -> outb_sa */
diff --git a/drivers/net/cnxk/cnxk_ethdev.c b/drivers/net/cnxk/cnxk_ethdev.c
index 1cae3084e1846..b185866338226 100644
--- a/drivers/net/cnxk/cnxk_ethdev.c
+++ b/drivers/net/cnxk/cnxk_ethdev.c
@@ -203,6 +203,8 @@ nix_security_setup(struct cnxk_eth_dev *dev)
 			plt_err("Outbound fc sw mem alloc failed");
 			goto sa_bmap_free;
 		}
+
+		dev->outb.cpt_eng_caps = roc_nix_inl_eng_caps_get(nix);
 	}
 	return 0;
 
diff --git a/drivers/net/cnxk/cnxk_ethdev.h b/drivers/net/cnxk/cnxk_ethdev.h
index 62a06e5d03900..d76f5486e61e1 100644
--- a/drivers/net/cnxk/cnxk_ethdev.h
+++ b/drivers/net/cnxk/cnxk_ethdev.h
@@ -285,6 +285,9 @@ struct cnxk_eth_dev_sec_outb {
 
 	/* Lock to synchronize sa setup/release */
 	rte_spinlock_t lock;
+
+	/* Engine caps */
+	uint64_t cpt_eng_caps;
 };
 
 struct cnxk_eth_dev {
-- 
2.25.1

