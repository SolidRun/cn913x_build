From 320e13e189bc74e6169436aaaf799a4b699b155e Mon Sep 17 00:00:00 2001
From: Gowrishankar Muthukrishnan <gmuthukrishn@marvell.com>
Date: Wed, 9 Nov 2022 21:38:33 +0530
Subject: [PATCH 023/955] crypto/cnxk: fix incorrect digest for an empty input
 data

For an empty input data, digest value is incorrectly generated from
previous auth op, in case executed. This is due to incorrect gather
component used.

Fixes: 7c19abdd0cf1 ("common/cnxk: support 103XX CPT")

Signed-off-by: Anoob Joseph <anoobj@marvell.com>
Signed-off-by: Gowrishankar Muthukrishnan <gmuthukrishn@marvell.com>
Change-Id: I34d43a56ecfd64fc005fc640c0860fe99ba83f2c
---
 drivers/crypto/cnxk/cnxk_se.h | 46 ++++++++++++++---------------------
 1 file changed, 18 insertions(+), 28 deletions(-)

diff --git a/drivers/crypto/cnxk/cnxk_se.h b/drivers/crypto/cnxk/cnxk_se.h
index ce4c2bb5850bd..2944d3c287cbe 100644
--- a/drivers/crypto/cnxk/cnxk_se.h
+++ b/drivers/crypto/cnxk/cnxk_se.h
@@ -247,7 +247,7 @@ fill_sg_comp_from_iov(struct roc_se_sglist_comp *list, uint32_t i,
 	uint32_t extra_len = extra_buf ? extra_buf->size : 0;
 	uint32_t size = *psize;
 
-	for (j = 0; (j < from->buf_cnt) && size; j++) {
+	for (j = 0; j < from->buf_cnt; j++) {
 		struct roc_se_sglist_comp *to = &list[i >> 2];
 		uint32_t buf_sz = from->bufs[j].size;
 		void *vaddr = from->bufs[j].vaddr;
@@ -314,6 +314,9 @@ fill_sg_comp_from_iov(struct roc_se_sglist_comp *list, uint32_t i,
 		if (extra_offset)
 			extra_offset -= size;
 		i++;
+
+		if (unlikely(!size))
+			break;
 	}
 
 	*psize = size;
@@ -370,7 +373,9 @@ fill_sg2_comp_from_iov(struct roc_se_sg2list_comp *list, uint32_t i, struct roc_
 	uint32_t extra_len = extra_buf ? extra_buf->size : 0;
 	uint32_t size = *psize;
 
-	for (j = 0; (j < from->buf_cnt) && size; j++) {
+	rte_prefetch2(psize);
+
+	for (j = 0; j < from->buf_cnt; j++) {
 		struct roc_se_sg2list_comp *to = &list[i / 3];
 		uint32_t buf_sz = from->bufs[j].size;
 		void *vaddr = from->bufs[j].vaddr;
@@ -436,6 +441,9 @@ fill_sg2_comp_from_iov(struct roc_se_sg2list_comp *list, uint32_t i, struct roc_
 		if (extra_offset)
 			extra_offset -= size;
 		i++;
+
+		if (unlikely(!size))
+			break;
 	}
 
 	*psize = size;
@@ -887,20 +895,10 @@ cpt_digest_gen_sg_ver1_prep(uint32_t flags, uint64_t d_lens, struct roc_se_fc_pa
 
 	/* input data */
 	size = data_len;
-	if (size) {
-		i = fill_sg_comp_from_iov(gather_comp, i, params->src_iov, 0,
-					  &size, NULL, 0);
-		if (unlikely(size)) {
-			plt_dp_err("Insufficient dst IOV size, short by %dB",
-				   size);
-			return -1;
-		}
-	} else {
-		/*
-		 * Looks like we need to support zero data
-		 * gather ptr in case of hash & hmac
-		 */
-		i++;
+	i = fill_sg_comp_from_iov(gather_comp, i, params->src_iov, 0, &size, NULL, 0);
+	if (unlikely(size)) {
+		plt_dp_err("Insufficient dst IOV size, short by %dB", size);
+		return -1;
 	}
 	((uint16_t *)in_buffer)[2] = rte_cpu_to_be_16(i);
 	g_size_bytes = ((i + 3) / 4) * sizeof(struct roc_se_sglist_comp);
@@ -1011,18 +1009,10 @@ cpt_digest_gen_sg_ver2_prep(uint32_t flags, uint64_t d_lens, struct roc_se_fc_pa
 
 	/* input data */
 	size = data_len;
-	if (size) {
-		i = fill_sg2_comp_from_iov(gather_comp, i, params->src_iov, 0, &size, NULL, 0);
-		if (unlikely(size)) {
-			plt_dp_err("Insufficient dst IOV size, short by %dB", size);
-			return -1;
-		}
-	} else {
-		/*
-		 * Looks like we need to support zero data
-		 * gather ptr in case of hash & hmac
-		 */
-		i++;
+	i = fill_sg2_comp_from_iov(gather_comp, i, params->src_iov, 0, &size, NULL, 0);
+	if (unlikely(size)) {
+		plt_dp_err("Insufficient dst IOV size, short by %dB", size);
+		return -1;
 	}
 	cpt_inst_w5.s.gather_sz = ((i + 2) / 3);
 
-- 
2.25.1

