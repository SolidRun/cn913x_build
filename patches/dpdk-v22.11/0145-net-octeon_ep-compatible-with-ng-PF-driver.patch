From f8e6f1de2a1ceb013e3fa7ac2b08d77da59f26c6 Mon Sep 17 00:00:00 2001
From: Sathesh Edara <sedara@marvell.com>
Date: Mon, 2 Jan 2023 07:43:00 -0800
Subject: [PATCH 145/955] net/octeon_ep: compatible with ng PF driver

update driver in compatible with next
generation pf driver. Organized Mbox
code similar to next generation PF
driver and removed redundant code.

Signed-off-by: Sathesh Edara <sedara@marvell.com>
Change-Id: Ief01e77e5166b3abc85779b008fcf6150eddecfb
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/93518
Tested-by: Satananda Burla <sburla@marvell.com>
Reviewed-by: Veerasenareddy Burru <vburru@marvell.com>
---
 drivers/net/octeon_ep/cnxk_ep_vf.c    | 116 ---------
 drivers/net/octeon_ep/meson.build     |   1 +
 drivers/net/octeon_ep/otx2_ep_vf.c    | 114 ---------
 drivers/net/octeon_ep/otx_ep_common.h | 152 +-----------
 drivers/net/octeon_ep/otx_ep_ethdev.c | 324 +++-----------------------
 drivers/net/octeon_ep/otx_ep_irq.c    |   1 +
 drivers/net/octeon_ep/otx_ep_irq.h    |  12 +
 drivers/net/octeon_ep/otx_ep_mbox.c   | 271 +++++++++++++++++++++
 drivers/net/octeon_ep/otx_ep_mbox.h   | 163 +++++++++++++
 drivers/net/octeon_ep/otx_ep_vf.c     | 132 -----------
 10 files changed, 479 insertions(+), 807 deletions(-)
 create mode 100644 drivers/net/octeon_ep/otx_ep_irq.h
 create mode 100644 drivers/net/octeon_ep/otx_ep_mbox.c
 create mode 100644 drivers/net/octeon_ep/otx_ep_mbox.h

diff --git a/drivers/net/octeon_ep/cnxk_ep_vf.c b/drivers/net/octeon_ep/cnxk_ep_vf.c
index bd3c870189b09..3f05cd3b9d9be 100644
--- a/drivers/net/octeon_ep/cnxk_ep_vf.c
+++ b/drivers/net/octeon_ep/cnxk_ep_vf.c
@@ -395,114 +395,6 @@ cnxk_ep_get_defconf(struct otx_ep_device *otx_ep_dev __rte_unused)
 	return default_conf;
 }
 
-static int
-cnxk_vf_send_mbox_cmd_nolock(struct otx_ep_device *otx_ep,
-			 union otx_vf_mbox_word cmd,
-			 union otx_vf_mbox_word *rsp)
-{
-	volatile uint64_t reg_val = 0ull;
-	int retry_count = 0;
-	int count = 0;
-
-	cmd.s.type = OTX_VF_MBOX_TYPE_CMD;
-	cmd.s.version = OTX_VF_MBOX_VERSION;
-	otx_ep->mbox_cmd_id = ~otx_ep->mbox_cmd_id;
-	cmd.s.id = otx_ep->mbox_cmd_id;
-retry:
-	oct_ep_write64(cmd.u64, otx_ep->hw_addr + SDP_VF_R_MBOX_VF_PF_DATA(0));
-	for (count = 0; count < OTX_VF_MBOX_TIMEOUT_MS; count++) {
-		rte_delay_ms(1);
-		reg_val = oct_ep_read64(otx_ep->hw_addr + SDP_VF_R_MBOX_VF_PF_DATA(0));
-		if (reg_val != cmd.u64) {
-			rsp->u64 = reg_val;
-			if (rsp->s.id == cmd.s.id)
-				break;
-			/* resp for previous cmd. retry */
-			retry_count++;
-			if (retry_count == OTX_VF_MBOX_MAX_RETRIES)
-				break;
-			goto retry;
-		}
-	}
-	if (count == OTX_VF_MBOX_TIMEOUT_MS ||
-	    retry_count == OTX_VF_MBOX_MAX_RETRIES)
-		return -ETIMEDOUT;
-	rsp->u64 = reg_val;
-	return 0;
-}
-
-static int
-cnxk_vf_send_mbox_cmd(struct otx_ep_device *otx_ep,
-		      union otx_vf_mbox_word cmd,
-		      union otx_vf_mbox_word *rsp)
-{
-	volatile uint64_t reg_val = 0ull;
-	int retry_count = 0;
-	int count = 0;
-
-	cmd.s.type = OTX_VF_MBOX_TYPE_CMD;
-	cmd.s.version = OTX_VF_MBOX_VERSION;
-	rte_spinlock_lock(&otx_ep->mbox_lock);
-	otx_ep->mbox_cmd_id = ~otx_ep->mbox_cmd_id;
-	cmd.s.id = otx_ep->mbox_cmd_id;
-retry:
-	oct_ep_write64(cmd.u64, otx_ep->hw_addr + SDP_VF_R_MBOX_VF_PF_DATA(0));
-	for (count = 0; count < OTX_VF_MBOX_TIMEOUT_MS; count++) {
-		rte_delay_ms(1);
-		reg_val = oct_ep_read64(otx_ep->hw_addr + SDP_VF_R_MBOX_VF_PF_DATA(0));
-		if (reg_val != cmd.u64) {
-			rsp->u64 = reg_val;
-			if (rsp->s.id == cmd.s.id)
-				break;
-			/* resp for previous cmd. retry */
-			retry_count++;
-			if (retry_count == OTX_VF_MBOX_MAX_RETRIES)
-				break;
-			goto retry;
-		}
-	}
-	rte_spinlock_unlock(&otx_ep->mbox_lock);
-	if (count == OTX_VF_MBOX_TIMEOUT_MS ||
-	    retry_count == OTX_VF_MBOX_MAX_RETRIES)
-		return -ETIMEDOUT;
-	rsp->u64 = reg_val;
-	return 0;
-}
-
-static void
-cnxk_ep_vf_enable_mbox_interrupt(struct otx_ep_device *otx_ep)
-{
-	rte_write64(0x2, (uint8_t *)otx_ep->hw_addr +
-		   OTX_EP_R_MBOX_PF_VF_INT(0));
-}
-
-static void
-cnxk_ep_vf_disable_mbox_interrupt(struct otx_ep_device *otx_ep)
-{
-	rte_write64(0x00, (uint8_t *)otx_ep->hw_addr +
-		   OTX_EP_R_MBOX_PF_VF_INT(0));
-}
-
-static int
-cnxk_ep_register_interrupt(struct otx_ep_device *otx_ep,
-		rte_intr_callback_fn cb, void *data, unsigned int vec)
-{
-	int rc = -1;
-
-	rc = otx_ep_register_irq(otx_ep, cb, data, vec);
-	return rc;
-}
-
-static int
-cnxk_ep_unregister_interrupt(struct otx_ep_device *otx_ep,
-		rte_intr_callback_fn cb, void *data)
-{
-	int rc = -1;
-
-	rc = otx_ep_unregister_irq(otx_ep, cb, data);
-	return rc;
-}
-
 int
 cnxk_ep_vf_setup_device(struct otx_ep_device *otx_ep)
 {
@@ -539,13 +431,5 @@ cnxk_ep_vf_setup_device(struct otx_ep_device *otx_ep)
 
 	otx_ep->fn_list.enable_oq           = cnxk_ep_vf_enable_oq;
 	otx_ep->fn_list.disable_oq          = cnxk_ep_vf_disable_oq;
-	otx_ep->fn_list.send_mbox_cmd       =  cnxk_vf_send_mbox_cmd;
-	otx_ep->fn_list.send_mbox_cmd_nolock    =  cnxk_vf_send_mbox_cmd_nolock;
-
-	otx_ep->fn_list.enable_mbox_interrupt   = cnxk_ep_vf_enable_mbox_interrupt;
-	otx_ep->fn_list.disable_mbox_interrupt  = cnxk_ep_vf_disable_mbox_interrupt;
-	otx_ep->fn_list.register_interrupt        = cnxk_ep_register_interrupt;
-	otx_ep->fn_list.unregister_interrupt      = cnxk_ep_unregister_interrupt;
-
 	return 0;
 }
diff --git a/drivers/net/octeon_ep/meson.build b/drivers/net/octeon_ep/meson.build
index 2c499591ba787..de50b90bf4909 100644
--- a/drivers/net/octeon_ep/meson.build
+++ b/drivers/net/octeon_ep/meson.build
@@ -11,4 +11,5 @@ sources = files(
         'otx2_ep_vf.c',
         'cnxk_ep_vf.c',
         'otx_ep_irq.c',
+        'otx_ep_mbox.c',
 )
diff --git a/drivers/net/octeon_ep/otx2_ep_vf.c b/drivers/net/octeon_ep/otx2_ep_vf.c
index 053dd173b8665..0f01ade6a999d 100644
--- a/drivers/net/octeon_ep/otx2_ep_vf.c
+++ b/drivers/net/octeon_ep/otx2_ep_vf.c
@@ -569,113 +569,6 @@ static int otx2_vf_disable_rxq_intr(struct otx_ep_device *otx_epvf,
 	return 0;
 }
 
-static int
-otx2_vf_send_mbox_cmd_nolock(struct otx_ep_device *otx_ep,
-			 union otx_vf_mbox_word cmd,
-			 union otx_vf_mbox_word *rsp)
-{
-	volatile uint64_t reg_val = 0ull;
-	int retry_count = 0;
-	int count = 0;
-
-	cmd.s.type = OTX_VF_MBOX_TYPE_CMD;
-	cmd.s.version = OTX_VF_MBOX_VERSION;
-	otx_ep->mbox_cmd_id = ~otx_ep->mbox_cmd_id;
-	cmd.s.id = otx_ep->mbox_cmd_id;
-retry:
-	otx2_write64(cmd.u64, otx_ep->hw_addr + SDP_VF_R_MBOX_VF_PF_DATA(0));
-	for (count = 0; count < OTX_VF_MBOX_TIMEOUT_MS; count++) {
-		rte_delay_ms(1);
-		reg_val = otx2_read64(otx_ep->hw_addr + SDP_VF_R_MBOX_VF_PF_DATA(0));
-		if (reg_val != cmd.u64) {
-			rsp->u64 = reg_val;
-			if (rsp->s.id == cmd.s.id)
-				break;
-			/* resp for previous cmd. retry */
-			retry_count++;
-			if (retry_count == OTX_VF_MBOX_MAX_RETRIES)
-				break;
-			goto retry;
-		}
-	}
-	if (count == OTX_VF_MBOX_TIMEOUT_MS ||
-	    retry_count == OTX_VF_MBOX_MAX_RETRIES)
-		return -ETIMEDOUT;
-	rsp->u64 = reg_val;
-	return 0;
-}
-
-static int
-otx2_vf_send_mbox_cmd(struct otx_ep_device *otx_ep,
-		      union otx_vf_mbox_word cmd,
-		      union otx_vf_mbox_word *rsp)
-{
-	volatile uint64_t reg_val = 0ull;
-	int retry_count = 0;
-	int count = 0;
-
-	cmd.s.type = OTX_VF_MBOX_TYPE_CMD;
-	cmd.s.version = OTX_VF_MBOX_VERSION;
-	rte_spinlock_lock(&otx_ep->mbox_lock);
-	otx_ep->mbox_cmd_id = ~otx_ep->mbox_cmd_id;
-	cmd.s.id = otx_ep->mbox_cmd_id;
-retry:
-	otx2_write64(cmd.u64, otx_ep->hw_addr + SDP_VF_R_MBOX_VF_PF_DATA(0));
-	for (count = 0; count < OTX_VF_MBOX_TIMEOUT_MS; count++) {
-		rte_delay_ms(1);
-		reg_val = otx2_read64(otx_ep->hw_addr + SDP_VF_R_MBOX_VF_PF_DATA(0));
-		if (reg_val != cmd.u64) {
-			rsp->u64 = reg_val;
-			if (rsp->s.id == cmd.s.id)
-				break;
-			/* resp for previous cmd. retry */
-			retry_count++;
-			if (retry_count == OTX_VF_MBOX_MAX_RETRIES)
-				break;
-			goto retry;
-		}
-	}
-	rte_spinlock_unlock(&otx_ep->mbox_lock);
-	if (count == OTX_VF_MBOX_TIMEOUT_MS ||
-	    retry_count == OTX_VF_MBOX_MAX_RETRIES)
-		return -ETIMEDOUT;
-	rsp->u64 = reg_val;
-	return 0;
-}
-
-static void
-otx2_ep_vf_enable_mbox_interrupt(struct otx_ep_device *otx_ep)
-{
-	rte_write64(0x2, (uint8_t *)otx_ep->hw_addr +
-		   OTX_EP_R_MBOX_PF_VF_INT(0));
-}
-
-static void
-otx2_ep_vf_disable_mbox_interrupt(struct otx_ep_device *otx_ep)
-{
-	rte_write64(0x00, (uint8_t *)otx_ep->hw_addr +
-		   OTX_EP_R_MBOX_PF_VF_INT(0));
-}
-
-static int
-otx2_ep_register_interrupt(struct otx_ep_device *otx_ep,
-		rte_intr_callback_fn cb, void *data, unsigned int vec)
-{
-	int rc = -1;
-
-	rc = otx_ep_register_irq(otx_ep, cb, data, vec);
-	return rc;
-}
-
-static int
-otx2_ep_unregister_interrupt(struct otx_ep_device *otx_ep,
-		rte_intr_callback_fn cb, void *data)
-{
-	int rc = -1;
-
-	rc = otx_ep_unregister_irq(otx_ep, cb, data);
-	return rc;
-}
 int
 otx2_ep_vf_setup_device(struct otx_ep_device *otx_ep)
 {
@@ -714,12 +607,5 @@ otx2_ep_vf_setup_device(struct otx_ep_device *otx_ep)
 	otx_ep->fn_list.disable_oq          = otx2_vf_disable_oq;
 	otx_ep->fn_list.enable_rxq_intr     = otx2_vf_enable_rxq_intr;
 	otx_ep->fn_list.disable_rxq_intr    = otx2_vf_disable_rxq_intr;
-	otx_ep->fn_list.send_mbox_cmd       =  otx2_vf_send_mbox_cmd;
-	otx_ep->fn_list.send_mbox_cmd_nolock    =  otx2_vf_send_mbox_cmd_nolock;
-	otx_ep->fn_list.enable_mbox_interrupt   = otx2_ep_vf_enable_mbox_interrupt;
-	otx_ep->fn_list.disable_mbox_interrupt  = otx2_ep_vf_disable_mbox_interrupt;
-	otx_ep->fn_list.register_interrupt        = otx2_ep_register_interrupt;
-	otx_ep->fn_list.unregister_interrupt      = otx2_ep_unregister_interrupt;
-
 	return 0;
 }
diff --git a/drivers/net/octeon_ep/otx_ep_common.h b/drivers/net/octeon_ep/otx_ep_common.h
index 529fbc3b4a651..8c38503a9aca0 100644
--- a/drivers/net/octeon_ep/otx_ep_common.h
+++ b/drivers/net/octeon_ep/otx_ep_common.h
@@ -424,133 +424,7 @@ struct otx_ep_config {
 	/* OQ buffer size */
 	uint32_t oqdef_buf_size;
 };
-
-#define MBOX_MAX_DATA_SIZE  6
-#define MBOX_MORE_FRAG_FLAG 1
-#define MBOX_MAX_DATA_BUF_SIZE 256
-typedef enum {
-	OTX_VF_MBOX_CMD_SET_MTU,
-	OTX_VF_MBOX_CMD_SET_MAC_ADDR,
-	OTX_VF_MBOX_CMD_GET_MAC_ADDR,
-	OTX_VF_MBOX_CMD_START_QUEUE,
-	OTX_VF_MBOX_CMD_STOP_QUEUE,
-	OTX_VF_MBOX_CMD_GET_LINK,
-	OTX_VF_MBOX_CMD_BULK_SEND,
-	OTX_VF_MBOX_CMD_BULK_GET,
-	OTX_VF_MBOX_CMD_GET_MTU,
-	OTX_VF_MBOX_CMD_LAST,
-} otx_vf_mbox_opcode_t;
-
-typedef enum {
-	OTX_VF_MBOX_TYPE_CMD,
-	OTX_VF_MBOX_TYPE_RSP_ACK,
-	OTX_VF_MBOX_TYPE_RSP_NACK,
-} otx_vf_mbox_word_type_t;
-
-union otx_vf_mbox_word {
-	uint64_t u64;
-	struct {
-		uint64_t version:3;
-		uint64_t rsvd1:2;
-		uint64_t opcode:5;
-		uint64_t rsvd2:3;
-		uint64_t id:1;
-		uint64_t type:2;
-		uint64_t data:48;
-	} s;
-	struct {
-		uint64_t version:3;
-		uint64_t rsvd1:2;
-		uint64_t opcode:5;
-		uint64_t rsvd2:2;
-		uint64_t frag:1;
-		uint64_t id:1;
-		uint64_t type:2;
-		uint8_t data[6];
-	} s_data;
-	struct {
-		uint64_t version:3;
-		uint64_t rsvd1:2;
-		uint64_t opcode:5;
-		uint64_t rsvd2:3;
-		uint64_t id:1;
-		uint64_t type:2;
-		uint8_t mac_addr[6];
-	} s_set_mac;
-	struct {
-		uint64_t version:3;
-		uint64_t rsvd1:2;
-		uint64_t opcode:5;
-		uint64_t rsvd2:3;
-		uint64_t id:1;
-		uint64_t type:2;
-		uint64_t mtu:48;
-	} s_set_mtu;
-	struct {
-		uint64_t version:3;
-		uint64_t rsvd1:2;
-		uint64_t opcode:5;
-		uint64_t rsvd2:3;
-		uint64_t id:1;
-		uint64_t type:2;
-		uint64_t mtu:48;
-	} s_get_mtu;
-	struct {
-		uint64_t version:3;
-		uint64_t rsvd1:2;
-		uint64_t opcode:5;
-		uint64_t rsvd2:3;
-		uint64_t id:1;
-		uint64_t type:2;
-		uint64_t link_status:1;
-		uint64_t link_speed:8;
-		uint64_t duplex:1;
-		uint64_t autoneg:1;
-		uint64_t rsvd:37;
-	} s_get_link;
-} __rte_packed;
-
-typedef enum {
-	OTX_VF_LINK_STATUS_DOWN,
-	OTX_VF_LINK_STATUS_UP,
-} otx_vf_link_status_t;
-
-typedef enum {
-	OTX_VF_LINK_SPEED_NONE,
-	OTX_VF_LINK_SPEED_100,
-	OTX_VF_LINK_SPEED_1000,
-	OTX_VF_LINK_SPEED_2500,
-	OTX_VF_LINK_SPEED_5000,
-	OTX_VF_LINK_SPEED_10000,
-	OTX_VF_LINK_SPEED_20000,
-	OTX_VF_LINK_SPEED_25000,
-	OTX_VF_LINK_SPEED_40000,
-	OTX_VF_LINK_SPEED_50000,
-	OTX_VF_LINK_SPEED_100000,
-	OTX_VF_LINK_SPEED_LAST,
-} otx_vf_link_speed_t;
-
-typedef enum {
-	OTX_VF_LINK_HALF_DUPLEX,
-	OTX_VF_LINK_FULL_DUPLEX,
-} otx_vf_link_duplex_t;
-
-typedef enum {
-	OTX_VF_LINK_AUTONEG,
-	OTX_VF_LINK_FIXED,
-} otx_vf_link_autoneg_t;
-
-struct otx_vf_mbox_link {
-	uint64_t link_status:1;
-	uint64_t link_speed:8;
-	uint64_t duplex:1;
-	uint64_t autoneg:1;
-	uint64_t rsvd:37;
-} __rte_packed;
-
-#define OTX_VF_MBOX_TIMEOUT_MS 10
-#define OTX_VF_MBOX_MAX_RETRIES 2
-#define OTX_VF_MBOX_VERSION 0
+#define MBOX_MAX_DATA_BUF_SIZE 320
 
 /* SRIOV information */
 struct otx_ep_sriov_info {
@@ -579,19 +453,6 @@ struct otx_ep_fn_list {
 	void (*disable_oq)(struct otx_ep_device *otx_ep, uint32_t q_no);
 	int (*enable_rxq_intr)(struct otx_ep_device *otx_epvf, uint16_t q_no);
 	int (*disable_rxq_intr)(struct otx_ep_device *otx_epvf, uint16_t q_no);
-	int (*send_mbox_cmd)(struct otx_ep_device *otx_epvf, union
-		otx_vf_mbox_word cmd, union otx_vf_mbox_word *rsp);
-	int (*send_mbox_cmd_nolock)(struct otx_ep_device *otx_epvf, union
-		otx_vf_mbox_word cmd, union otx_vf_mbox_word *rsp);
-	void (*enable_mbox_interrupt)(struct otx_ep_device *otx_epvf);
-	void (*disable_mbox_interrupt)(struct otx_ep_device *otx_epvf);
-	int (*register_pf_vf_mbox_interrupt)(struct otx_ep_device *otx_epvf);
-	int (*unregister_pf_vf_mbox_interrupt)(struct otx_ep_device *otx_epvf);
-	int (*register_interrupt)(struct otx_ep_device *otx_ep,
-		rte_intr_callback_fn cb, void *data, unsigned int vec);
-	int (*unregister_interrupt)(struct otx_ep_device *otx_ep,
-		rte_intr_callback_fn cb, void *data);
-
 };
 
 /* OTX_EP EP VF device data structure */
@@ -668,17 +529,6 @@ int otx_ep_setup_oqs(struct otx_ep_device *otx_ep, int oq_no, int num_descs,
 		     int desc_size, struct rte_mempool *mpool,
 		     unsigned int socket_id);
 int otx_ep_delete_oqs(struct otx_ep_device *otx_ep, uint32_t oq_no);
-int otx_ep_register_irq(struct otx_ep_device *otx_ep,
-			rte_intr_callback_fn cb, void *data, unsigned int vec);
-int otx_ep_unregister_irq(struct otx_ep_device *otx_ep,
-			rte_intr_callback_fn cb, void *data);
-int otx_ep_send_vf_pf_config_data(struct rte_eth_dev *eth_dev,
-					otx_vf_mbox_opcode_t opcode,
-					uint8_t *data, int32_t size);
-int otx_ep_get_pf_vf_data(struct rte_eth_dev *eth_dev,
-					otx_vf_mbox_opcode_t opcode,
-					uint8_t *data, int32_t *size);
-
 
 struct otx_ep_sg_entry {
 	/** The first 64 bit gives the size of data in each dptr. */
diff --git a/drivers/net/octeon_ep/otx_ep_ethdev.c b/drivers/net/octeon_ep/otx_ep_ethdev.c
index 42e15534d7262..129db190aed7d 100644
--- a/drivers/net/octeon_ep/otx_ep_ethdev.c
+++ b/drivers/net/octeon_ep/otx_ep_ethdev.c
@@ -14,6 +14,8 @@
 #include "otx2_ep_vf.h"
 #include "cnxk_ep_vf.h"
 #include "otx_ep_rxtx.h"
+#include "otx_ep_mbox.h"
+#include "otx_ep_irq.h"
 
 #define OTX_EP_DEV(_eth_dev) \
 	((struct otx_ep_device *)(_eth_dev)->data->dev_private)
@@ -30,41 +32,6 @@ static const struct rte_eth_desc_lim otx_ep_tx_desc_lim = {
 	.nb_align	= OTX_EP_TXD_ALIGN,
 };
 
-static int
-otx_ep_send_mbox_cmd(struct otx_ep_device *otx_epvf, union otx_vf_mbox_word cmd,
-		     union otx_vf_mbox_word *rsp)
-{
-	return otx_epvf->fn_list.send_mbox_cmd(otx_epvf, cmd, rsp);
-}
-
-static int
-otx_ep_send_mbox_cmd_nolock(struct otx_ep_device *otx_epvf,
-			    union otx_vf_mbox_word cmd,
-			    union otx_vf_mbox_word *rsp)
-{
-	return otx_epvf->fn_list.send_mbox_cmd_nolock(otx_epvf, cmd, rsp);
-}
-
-static int
-otx_ep_dev_get_max_pkt_len(struct rte_eth_dev *eth_dev)
-{
-	struct otx_ep_device *otx_epvf =
-		(struct otx_ep_device *)OTX_EP_DEV(eth_dev);
-	union otx_vf_mbox_word cmd;
-	union otx_vf_mbox_word rsp;
-	int ret;
-
-	cmd.u64 = 0;
-	cmd.s_get_mtu.opcode = OTX_VF_MBOX_CMD_GET_MTU;
-
-	ret = otx_ep_send_mbox_cmd(otx_epvf, cmd, &rsp);
-	if (ret)
-		return ret;
-	if (rsp.s_get_mtu.type != OTX_VF_MBOX_TYPE_RSP_ACK)
-		return -EINVAL;
-	return rsp.s_get_mtu.mtu;
-}
-
 static int
 otx_ep_dev_info_get(struct rte_eth_dev *eth_dev,
 		    struct rte_eth_dev_info *devinfo)
@@ -74,7 +41,7 @@ otx_ep_dev_info_get(struct rte_eth_dev *eth_dev,
 
 	otx_epvf = OTX_EP_DEV(eth_dev);
 
-	max_rx_pktlen = otx_ep_dev_get_max_pkt_len(eth_dev);
+	max_rx_pktlen = otx_ep_mbox_get_max_pkt_len(eth_dev);
 	if (max_rx_pktlen > 0) {
 		max_rx_pktlen = max_rx_pktlen + RTE_ETHER_CRC_LEN;
 	} else {
@@ -109,74 +76,14 @@ static int
 otx_ep_dev_link_update(struct rte_eth_dev *eth_dev,
 		    int wait_to_complete __rte_unused)
 {
+	int32_t ret = 0;
 	struct rte_eth_link link;
-	struct otx_ep_device *otx_epvf =
-		(struct otx_ep_device *)OTX_EP_DEV(eth_dev);
-	union otx_vf_mbox_word cmd;
-	union otx_vf_mbox_word rsp;
-	int ret;
 
 	memset(&link, 0, sizeof(link));
-	link.link_status = RTE_ETH_LINK_DOWN;
-	link.link_duplex = RTE_ETH_LINK_HALF_DUPLEX;
-	link.link_autoneg = RTE_ETH_LINK_AUTONEG;
-	cmd.u64 = 0;
-	cmd.s_get_link.opcode = OTX_VF_MBOX_CMD_GET_LINK;
-
-	ret = otx_ep_send_mbox_cmd(otx_epvf, cmd, &rsp);
+	ret = otx_ep_mbox_get_link_info(eth_dev, &link);
 	if (ret)
-		return ret;
-	if (rsp.s_get_link.type != OTX_VF_MBOX_TYPE_RSP_ACK)
 		return -EINVAL;
-	if (rsp.s_get_link.link_status == OTX_VF_LINK_STATUS_DOWN)
-		return rte_eth_linkstatus_set(eth_dev, &link);
-
-
-	link.link_status = RTE_ETH_LINK_UP;
-	link.link_duplex = (rsp.s_get_link.duplex ==
-			    OTX_VF_LINK_HALF_DUPLEX) ?
-			    RTE_ETH_LINK_HALF_DUPLEX :
-			    RTE_ETH_LINK_FULL_DUPLEX;
-	link.link_autoneg = (rsp.s_get_link.autoneg ==
-			     OTX_VF_LINK_AUTONEG) ?
-			     RTE_ETH_LINK_AUTONEG :
-			     RTE_ETH_LINK_FIXED;
-
-	switch (rsp.s_get_link.link_speed) {
-	case OTX_VF_LINK_SPEED_100:
-		link.link_speed = RTE_ETH_SPEED_NUM_100M;
-		break;
-	case OTX_VF_LINK_SPEED_1000:
-		link.link_speed = RTE_ETH_SPEED_NUM_1G;
-		break;
-	case OTX_VF_LINK_SPEED_2500:
-		link.link_speed = RTE_ETH_SPEED_NUM_2_5G;
-		break;
-	case OTX_VF_LINK_SPEED_5000:
-		link.link_speed = RTE_ETH_SPEED_NUM_5G;
-		break;
-	case OTX_VF_LINK_SPEED_10000:
-		link.link_speed = RTE_ETH_SPEED_NUM_10G;
-		break;
-	case OTX_VF_LINK_SPEED_20000:
-		link.link_speed = RTE_ETH_SPEED_NUM_20G;
-		break;
-	case OTX_VF_LINK_SPEED_25000:
-		link.link_speed = RTE_ETH_SPEED_NUM_25G;
-		break;
-	case OTX_VF_LINK_SPEED_40000:
-		link.link_speed = RTE_ETH_SPEED_NUM_40G;
-		break;
-	case OTX_VF_LINK_SPEED_50000:
-		link.link_speed = RTE_ETH_SPEED_NUM_50G;
-		break;
-	case OTX_VF_LINK_SPEED_100000:
-		link.link_speed = RTE_ETH_SPEED_NUM_100G;
-		break;
-	default:
-		link.link_speed = RTE_ETH_SPEED_NUM_NONE;
-		otx_ep_err("Link speed none\n");
-	}
+
 	otx_ep_dbg("link status resp link %d duplex %d autoneg %d link_speed %d\n",
 		   link.link_status, link.link_duplex, link.link_autoneg, link.link_speed);
 	return rte_eth_linkstatus_set(eth_dev, &link);
@@ -185,11 +92,7 @@ otx_ep_dev_link_update(struct rte_eth_dev *eth_dev,
 static int
 otx_ep_dev_mtu_set(struct rte_eth_dev *eth_dev, uint16_t mtu)
 {
-	struct otx_ep_device *otx_epvf =
-			(struct otx_ep_device *)OTX_EP_DEV(eth_dev);
 	int32_t frame_size = mtu + OTX_EP_ETH_OVERHEAD;
-	union otx_vf_mbox_word cmd;
-	union otx_vf_mbox_word rsp;
 	int32_t ret = 0;
 
 	/* Check if MTU is within the allowed range */
@@ -198,19 +101,13 @@ otx_ep_dev_mtu_set(struct rte_eth_dev *eth_dev, uint16_t mtu)
 		return -EINVAL;
 	}
 
-	if ((frame_size - RTE_ETHER_CRC_LEN) > ((int32_t)otx_ep_dev_get_max_pkt_len(eth_dev))) {
+	if ((frame_size - RTE_ETHER_CRC_LEN) > ((int32_t)otx_ep_mbox_get_max_pkt_len(eth_dev))) {
 		otx_ep_err("MTU is greater than maximum");
 		return -EINVAL;
 	}
 
-	cmd.u64 = 0;
-	cmd.s_set_mtu.opcode = OTX_VF_MBOX_CMD_SET_MTU;
-	cmd.s_set_mtu.mtu = mtu;
-
-	ret = otx_ep_send_mbox_cmd(otx_epvf, cmd, &rsp);
+	ret = otx_ep_mbox_set_mtu(eth_dev, mtu);
 	if (ret)
-		return ret;
-	if (rsp.s_set_mtu.type != OTX_VF_MBOX_TYPE_RSP_ACK)
 		return -EINVAL;
 
 	if (frame_size > RTE_ETHER_MAX_LEN)
@@ -224,165 +121,17 @@ otx_ep_dev_mtu_set(struct rte_eth_dev *eth_dev, uint16_t mtu)
 	return 0;
 }
 
-int
-otx_ep_send_vf_pf_config_data(struct rte_eth_dev *eth_dev,
-				otx_vf_mbox_opcode_t opcode,
-				uint8_t *data, int32_t size)
-{
-	struct otx_ep_device *otx_epvf = OTX_EP_DEV(eth_dev);
-	union otx_vf_mbox_word cmd;
-	union otx_vf_mbox_word rsp;
-	int32_t read_cnt, num_bytes_written = 0, ret;
-
-	cmd.u64 = 0;
-	cmd.s_data.opcode = opcode;
-	cmd.s_data.frag = 0;
-	rte_spinlock_lock(&otx_epvf->mbox_lock);
-	cmd.s_data.frag = MBOX_MORE_FRAG_FLAG;
-	*((int32_t *)cmd.s_data.data) = size;
-	ret = otx_ep_send_mbox_cmd_nolock(otx_epvf, cmd, &rsp);
-	if (ret) {
-		otx_ep_err("send mbox cmd fail for length\n");
-		rte_spinlock_unlock(&otx_epvf->mbox_lock);
-		return ret;
-	}
-	if (rsp.s_data.type != OTX_VF_MBOX_TYPE_RSP_ACK) {
-		otx_ep_err("send mbox cmd ACK receive fail for length\n");
-		rte_spinlock_unlock(&otx_epvf->mbox_lock);
-		return -EINVAL;
-	}
-	cmd.u64 = 0;
-	cmd.s_data.opcode = opcode;
-	cmd.s_data.frag = 0;
-
-	for (read_cnt = 0; read_cnt < size; read_cnt++) {
-		cmd.s_data.data[num_bytes_written] = data[read_cnt];
-		num_bytes_written++;
-		if (num_bytes_written == MBOX_MAX_DATA_SIZE ||
-				(read_cnt == (size - 1))) {
-			if (num_bytes_written == MBOX_MAX_DATA_SIZE &&
-					(read_cnt != (size - 1))) {
-				cmd.s_data.frag = MBOX_MORE_FRAG_FLAG;
-				num_bytes_written = 0;
-			}
-			ret = otx_ep_send_mbox_cmd_nolock(otx_epvf, cmd, &rsp);
-			if (ret) {
-				otx_ep_err("send mbox cmd nolock fail\n");
-				rte_spinlock_unlock(&otx_epvf->mbox_lock);
-				return ret;
-			}
-			if (rsp.s_set_mac.type != OTX_VF_MBOX_TYPE_RSP_ACK) {
-				otx_ep_err("send mbox cmd nolock ACK fail\n");
-				rte_spinlock_unlock(&otx_epvf->mbox_lock);
-				return -EINVAL;
-			}
-			cmd.u64 = 0;
-			cmd.s_data.opcode = OTX_VF_MBOX_CMD_BULK_SEND;
-			cmd.s_data.frag = 0;
-		}
-	}
-	rte_spinlock_unlock(&otx_epvf->mbox_lock);
-	return 0;
-}
-
-int
-otx_ep_get_pf_vf_data(struct rte_eth_dev *eth_dev,
-			otx_vf_mbox_opcode_t opcode,
-			uint8_t *data, int32_t *size)
-{
-	struct otx_ep_device *otx_epvf = OTX_EP_DEV(eth_dev);
-	union otx_vf_mbox_word cmd;
-	union otx_vf_mbox_word rsp;
-	int32_t read_cnt, i = 0, ret;
-	int32_t data_len = 0, tmp_len = 0;
-
-	cmd.u64 = 0;
-	cmd.s_data.opcode = opcode;
-	cmd.s_data.frag = 0;
-	rte_spinlock_lock(&otx_epvf->mbox_lock);
-
-	/* Send cmd to read data from PF */
-	ret = otx_ep_send_mbox_cmd_nolock(otx_epvf, cmd, &rsp);
-	if (ret) {
-		otx_ep_err("send mbox cmd fail for data request\n");
-		rte_spinlock_unlock(&otx_epvf->mbox_lock);
-		return ret;
-	}
-	if (rsp.s_data.type != OTX_VF_MBOX_TYPE_RSP_ACK) {
-		otx_ep_err("send mbox cmd ACK receive fail for data request\n");
-		rte_spinlock_unlock(&otx_epvf->mbox_lock);
-		return -EINVAL;
-	}
-	/*  PF sends the data length of requested CMD
-	 *  in  ACK
-	 */
-	data_len = *((int32_t *)rsp.s_data.data);
-	tmp_len = data_len;
-	otx_ep_err("data length %d:\n", data_len);
-	cmd.u64 = 0;
-	rsp.u64 = 0;
-	cmd.s_data.opcode = opcode;
-	cmd.s_data.frag = 1;
-	while (data_len) {
-		ret = otx_ep_send_mbox_cmd_nolock(otx_epvf, cmd, &rsp);
-		if (ret) {
-			otx_ep_err("send mbox cmd fail for data request\n");
-			rte_spinlock_unlock(&otx_epvf->mbox_lock);
-			return ret;
-		}
-		if (rsp.s_set_mac.type != OTX_VF_MBOX_TYPE_RSP_ACK) {
-			otx_ep_err("send mbox cmd ACK receive fail for data request\n");
-			rte_spinlock_unlock(&otx_epvf->mbox_lock);
-			return -EINVAL;
-		}
-		if (data_len > MBOX_MAX_DATA_SIZE) {
-			data_len -= MBOX_MAX_DATA_SIZE;
-			read_cnt = MBOX_MAX_DATA_SIZE;
-		} else {
-			read_cnt = data_len;
-			data_len = 0;
-		}
-		for (i = 0; i < read_cnt; i++) {
-			otx_epvf->mbox_data_buf[otx_epvf->mbox_data_index] = rsp.s_data.data[i];
-			otx_epvf->mbox_data_index++;
-		}
-		cmd.u64 = 0;
-		rsp.u64 = 0;
-		cmd.s_data.opcode = opcode;
-		cmd.s_data.frag = 1;
-	}
-	memcpy(data, otx_epvf->mbox_data_buf, tmp_len);
-	*size = tmp_len;
-	otx_epvf->mbox_data_index = 0;
-	memset(otx_epvf->mbox_data_buf, 0, MBOX_MAX_DATA_BUF_SIZE);
-	rte_spinlock_unlock(&otx_epvf->mbox_lock);
-	return 0;
-}
-
 static int
 otx_ep_dev_set_default_mac_addr(struct rte_eth_dev *eth_dev,
 				struct rte_ether_addr *mac_addr)
 {
-	struct otx_ep_device *otx_epvf = OTX_EP_DEV(eth_dev);
-	union otx_vf_mbox_word cmd;
-	union otx_vf_mbox_word rsp;
-	int i, ret;
-
-	cmd.u64 = 0;
-	cmd.s_set_mac.opcode = OTX_VF_MBOX_CMD_SET_MAC_ADDR;
-	for (i = 0; i < RTE_ETHER_ADDR_LEN; i++)
-		cmd.s_set_mac.mac_addr[i] = mac_addr->addr_bytes[i];
-	ret = otx_ep_send_mbox_cmd(otx_epvf, cmd, &rsp);
-	if (ret) {
-		otx_ep_err("%s Sending Mbox message fails ret val:%d\n", __func__, ret);
-		return ret;
-	}
-	if (rsp.s_set_mac.type != OTX_VF_MBOX_TYPE_RSP_ACK) {
-		otx_ep_err("%s Received NACK Mbox message\n", __func__);
+	int ret;
+
+	ret = otx_ep_mbox_set_mac_addr(eth_dev, mac_addr);
+	if (ret)
 		return -EINVAL;
-	}
-	otx_ep_dbg("%s VF MAC " RTE_ETHER_ADDR_PRT_FMT "\n",
-		    __func__, RTE_ETHER_ADDR_BYTES(mac_addr));
+	otx_ep_dbg("Default MAC address " RTE_ETHER_ADDR_PRT_FMT "\n",
+		    RTE_ETHER_ADDR_BYTES(mac_addr));
 	rte_ether_addr_copy(mac_addr, eth_dev->data->mac_addrs);
 	return 0;
 }
@@ -391,26 +140,13 @@ static int
 otx_ep_dev_get_mac_addr(struct rte_eth_dev *eth_dev,
 			struct rte_ether_addr *mac_addr)
 {
-	struct otx_ep_device *otx_epvf = OTX_EP_DEV(eth_dev);
-	union otx_vf_mbox_word cmd;
-	union otx_vf_mbox_word rsp;
-	int i, ret;
+	int ret;
 
-	cmd.u64 = 0;
-	cmd.s_set_mac.opcode = OTX_VF_MBOX_CMD_GET_MAC_ADDR;
-	ret = otx_ep_send_mbox_cmd(otx_epvf, cmd, &rsp);
-	if (ret) {
-		otx_ep_err("%s Sending Mbox message fails ret val:%d\n", __func__, ret);
-		return ret;
-	}
-	if (rsp.s_set_mac.type != OTX_VF_MBOX_TYPE_RSP_ACK) {
-		otx_ep_err("%s Received NACK Mbox message\n", __func__);
+	ret = otx_ep_mbox_get_mac_addr(eth_dev, mac_addr);
+	if (ret)
 		return -EINVAL;
-	}
-	for (i = 0; i < RTE_ETHER_ADDR_LEN; i++)
-		mac_addr->addr_bytes[i] = rsp.s_set_mac.mac_addr[i];
-	otx_ep_dbg("%s VF MAC " RTE_ETHER_ADDR_PRT_FMT "\n",
-		    __func__, RTE_ETHER_ADDR_BYTES(mac_addr));
+	otx_ep_dbg("Get MAC address " RTE_ETHER_ADDR_PRT_FMT "\n",
+		    RTE_ETHER_ADDR_BYTES(mac_addr));
 	return 0;
 }
 
@@ -577,9 +313,9 @@ otx_epdev_init(struct otx_ep_device *otx_epvf)
 	ethdev_queues = (uint32_t)(otx_epvf->sriov_info.rings_per_vf);
 	otx_epvf->max_rx_queues = ethdev_queues;
 	otx_epvf->max_tx_queues = ethdev_queues;
-	otx_epvf->fn_list.register_interrupt(otx_epvf, otx_ep_interrupt_handler,
+	otx_ep_register_irq(otx_epvf, otx_ep_interrupt_handler,
 						(void *)otx_epvf, vec);
-	otx_epvf->fn_list.enable_mbox_interrupt(otx_epvf);
+	otx_ep_mbox_enable_interrupt(otx_epvf);
 	otx_ep_info("OTX_EP Device is Ready\n");
 setup_fail:
 	return ret;
@@ -853,8 +589,8 @@ otx_epdev_exit(struct rte_eth_dev *eth_dev)
 	otx_ep_info("%s:\n", __func__);
 
 	otx_epvf = OTX_EP_DEV(eth_dev);
-	otx_epvf->fn_list.disable_mbox_interrupt(otx_epvf);
-	otx_epvf->fn_list.unregister_interrupt(otx_epvf, otx_ep_interrupt_handler,
+	otx_ep_mbox_disable_interrupt(otx_epvf);
+	otx_ep_unregister_irq(otx_epvf, otx_ep_interrupt_handler,
 						(void *)otx_epvf);
 	otx_epvf->fn_list.disable_io_queues(otx_epvf);
 	num_queues = otx_epvf->nb_rx_queues;
@@ -950,20 +686,20 @@ static int otx_ep_eth_dev_query_set_vf_mac(struct rte_eth_dev *eth_dev,
 			otx_ep_dbg("PF doesn't have valid VF MAC addr" RTE_ETHER_ADDR_PRT_FMT "\n",
 				    RTE_ETHER_ADDR_BYTES(mac_addr));
 			rte_eth_random_addr(mac_addr->addr_bytes);
-			otx_ep_dbg("%s VF setting Random MAC address" RTE_ETHER_ADDR_PRT_FMT "\n",
-				    __func__, RTE_ETHER_ADDR_BYTES(mac_addr));
+			otx_ep_dbg("Setting Random MAC address" RTE_ETHER_ADDR_PRT_FMT "\n",
+				    RTE_ETHER_ADDR_BYTES(mac_addr));
 			ret_val = otx_ep_dev_set_default_mac_addr(eth_dev, mac_addr);
 			if (ret_val) {
-				otx_ep_err("%s Setting VF MAC " RTE_ETHER_ADDR_PRT_FMT "fails\n",
-					     __func__, RTE_ETHER_ADDR_BYTES(mac_addr));
+				otx_ep_err("Setting MAC address " RTE_ETHER_ADDR_PRT_FMT "fails\n",
+					    RTE_ETHER_ADDR_BYTES(mac_addr));
 				return ret_val;
 			}
 		}
-		otx_ep_dbg("VF received valid MAC addr from PF" RTE_ETHER_ADDR_PRT_FMT "\n",
+		otx_ep_dbg("Received valid MAC addr from PF" RTE_ETHER_ADDR_PRT_FMT "\n",
 			    RTE_ETHER_ADDR_BYTES(mac_addr));
 	} else {
-		otx_ep_err("%s Getting VF MAC from PF via Mbox fails with ret_val: %d\n",
-			    __func__, ret_val);
+		otx_ep_err("Getting MAC address from PF via Mbox fails with ret_val: %d\n",
+			    ret_val);
 		return ret_val;
 	}
 	return 0;
diff --git a/drivers/net/octeon_ep/otx_ep_irq.c b/drivers/net/octeon_ep/otx_ep_irq.c
index 36fc0056e3cda..1e912d95319bf 100644
--- a/drivers/net/octeon_ep/otx_ep_irq.c
+++ b/drivers/net/octeon_ep/otx_ep_irq.c
@@ -10,6 +10,7 @@
 #include <sys/eventfd.h>
 #include <sys/ioctl.h>
 #include "otx_ep_common.h"
+#include "otx_ep_irq.h"
 
 
 #define MAX_INTR_VEC_ID RTE_MAX_RXTX_INTR_VEC_ID
diff --git a/drivers/net/octeon_ep/otx_ep_irq.h b/drivers/net/octeon_ep/otx_ep_irq.h
new file mode 100644
index 0000000000000..d490e484ad5d3
--- /dev/null
+++ b/drivers/net/octeon_ep/otx_ep_irq.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(C) 2021 Marvell.
+ */
+
+#ifndef _OTX_EP_IRQ_H_
+#define _OTX_EP_IRQ_H_
+
+int otx_ep_register_irq(struct otx_ep_device *otx_ep,
+			rte_intr_callback_fn cb, void *data, unsigned int vec);
+int otx_ep_unregister_irq(struct otx_ep_device *otx_ep,
+			  rte_intr_callback_fn cb, void *data);
+#endif
diff --git a/drivers/net/octeon_ep/otx_ep_mbox.c b/drivers/net/octeon_ep/otx_ep_mbox.c
new file mode 100644
index 0000000000000..1c63e82c5529d
--- /dev/null
+++ b/drivers/net/octeon_ep/otx_ep_mbox.c
@@ -0,0 +1,271 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(C) 2021 Marvell.
+ */
+
+#include <ethdev_pci.h>
+#include <rte_ether.h>
+#include <rte_kvargs.h>
+#include <rte_spinlock.h>
+
+#include "common/cnxk/roc_api.h"
+#include "otx_ep_common.h"
+#include "otx_ep_vf.h"
+#include "otx2_ep_vf.h"
+#include "cnxk_ep_vf.h"
+#include "otx_ep_mbox.h"
+
+static int
+__otx_ep_send_mbox_cmd(struct otx_ep_device *otx_ep,
+		       union otx_ep_mbox_word cmd,
+		       union otx_ep_mbox_word *rsp)
+{
+	volatile uint64_t reg_val = 0ull;
+	int count = 0;
+
+	cmd.s.type = OTX_EP_MBOX_TYPE_CMD;
+	otx2_write64(cmd.u64, otx_ep->hw_addr + SDP_VF_R_MBOX_VF_PF_DATA(0));
+	for (count = 0; count < OTX_EP_MBOX_TIMEOUT_MS; count++) {
+		rte_delay_ms(1);
+		reg_val = otx2_read64(otx_ep->hw_addr + SDP_VF_R_MBOX_VF_PF_DATA(0));
+		if (reg_val != cmd.u64) {
+			rsp->u64 = reg_val;
+			break;
+		}
+	}
+	if (count == OTX_EP_MBOX_TIMEOUT_MS) {
+		otx_ep_err("mbox send Timeout count:%d\n", count);
+		return OTX_EP_MBOX_TIMEOUT_MS;
+	}
+	if (rsp->s.type != OTX_EP_MBOX_TYPE_RSP_ACK) {
+		otx_ep_err("mbox received  NACK from PF\n");
+		return OTX_EP_MBOX_CMD_STATUS_NACK;
+	}
+
+	rsp->u64 = reg_val;
+	return 0;
+}
+
+static int
+otx_ep_send_mbox_cmd(struct otx_ep_device *otx_ep,
+		     union otx_ep_mbox_word cmd,
+		     union otx_ep_mbox_word *rsp)
+{
+	int ret;
+
+	rte_spinlock_lock(&otx_ep->mbox_lock);
+	ret = __otx_ep_send_mbox_cmd(otx_ep, cmd, rsp);
+	rte_spinlock_unlock(&otx_ep->mbox_lock);
+	return ret;
+}
+
+static int
+otx_ep_mbox_bulk_read(struct otx_ep_device *otx_ep,
+		      enum otx_ep_mbox_opcode opcode,
+		      uint8_t *data, int32_t *size)
+{
+	union otx_ep_mbox_word cmd;
+	union otx_ep_mbox_word rsp;
+	int read_cnt, i = 0, ret;
+	int data_len = 0, tmp_len = 0;
+
+	rte_spinlock_lock(&otx_ep->mbox_lock);
+	cmd.u64 = 0;
+	cmd.s_data.opcode = opcode;
+	cmd.s_data.frag = 0;
+	/* Send cmd to read data from PF */
+	ret = __otx_ep_send_mbox_cmd(otx_ep, cmd, &rsp);
+	if (ret) {
+		otx_ep_err("mbox bulk read data request failed\n");
+		rte_spinlock_unlock(&otx_ep->mbox_lock);
+		return ret;
+	}
+	/*  PF sends the data length of requested CMD
+	 *  in  ACK
+	 */
+	data_len = *((int32_t *)rsp.s_data.data);
+	tmp_len = data_len;
+	cmd.u64 = 0;
+	rsp.u64 = 0;
+	cmd.s_data.opcode = opcode;
+	cmd.s_data.frag = 1;
+	while (data_len) {
+		ret = __otx_ep_send_mbox_cmd(otx_ep, cmd, &rsp);
+		if (ret) {
+			otx_ep_err("mbox bulk read data request failed\n");
+			otx_ep->mbox_data_index = 0;
+			memset(otx_ep->mbox_data_buf, 0, OTX_EP_MBOX_MAX_DATA_BUF_SIZE);
+			rte_spinlock_unlock(&otx_ep->mbox_lock);
+			return ret;
+		}
+		if (data_len > OTX_EP_MBOX_MAX_DATA_SIZE) {
+			data_len -= OTX_EP_MBOX_MAX_DATA_SIZE;
+			read_cnt = OTX_EP_MBOX_MAX_DATA_SIZE;
+		} else {
+			read_cnt = data_len;
+			data_len = 0;
+		}
+		for (i = 0; i < read_cnt; i++) {
+			otx_ep->mbox_data_buf[otx_ep->mbox_data_index] =
+				rsp.s_data.data[i];
+			otx_ep->mbox_data_index++;
+		}
+		cmd.u64 = 0;
+		rsp.u64 = 0;
+		cmd.s_data.opcode = opcode;
+		cmd.s_data.frag = 1;
+	}
+	memcpy(data, otx_ep->mbox_data_buf, tmp_len);
+	*size = tmp_len;
+	otx_ep->mbox_data_index = 0;
+	memset(otx_ep->mbox_data_buf, 0, OTX_EP_MBOX_MAX_DATA_BUF_SIZE);
+	rte_spinlock_unlock(&otx_ep->mbox_lock);
+	return 0;
+}
+
+int
+otx_ep_mbox_set_mtu(struct rte_eth_dev *eth_dev, uint16_t mtu)
+{
+	struct otx_ep_device *otx_ep =
+		(struct otx_ep_device *)(eth_dev)->data->dev_private;
+	union otx_ep_mbox_word cmd;
+	union otx_ep_mbox_word rsp;
+	int ret = 0;
+
+	cmd.u64 = 0;
+	cmd.s_set_mtu.opcode = OTX_EP_MBOX_CMD_SET_MTU;
+	cmd.s_set_mtu.mtu = mtu;
+
+	ret = otx_ep_send_mbox_cmd(otx_ep, cmd, &rsp);
+	if (ret) {
+		otx_ep_err("set MTU failed\n");
+		return -EINVAL;
+	}
+	otx_ep_dbg("mtu set  success mtu %u\n", mtu);
+
+	return 0;
+}
+
+int
+otx_ep_mbox_set_mac_addr(struct rte_eth_dev *eth_dev,
+			 struct rte_ether_addr *mac_addr)
+{
+	struct otx_ep_device *otx_ep =
+		(struct otx_ep_device *)(eth_dev)->data->dev_private;
+	union otx_ep_mbox_word cmd;
+	union otx_ep_mbox_word rsp;
+	int i, ret;
+
+	cmd.u64 = 0;
+	cmd.s_set_mac.opcode = OTX_EP_MBOX_CMD_SET_MAC_ADDR;
+	for (i = 0; i < RTE_ETHER_ADDR_LEN; i++)
+		cmd.s_set_mac.mac_addr[i] = mac_addr->addr_bytes[i];
+	ret = otx_ep_send_mbox_cmd(otx_ep, cmd, &rsp);
+	if (ret) {
+		otx_ep_err("set MAC address failed\n");
+		return -EINVAL;
+	}
+	otx_ep_dbg("%s VF MAC " RTE_ETHER_ADDR_PRT_FMT "\n",
+		    __func__, RTE_ETHER_ADDR_BYTES(mac_addr));
+	rte_ether_addr_copy(mac_addr, eth_dev->data->mac_addrs);
+	return 0;
+}
+
+int
+otx_ep_mbox_get_mac_addr(struct rte_eth_dev *eth_dev,
+			 struct rte_ether_addr *mac_addr)
+{
+	struct otx_ep_device *otx_ep =
+		(struct otx_ep_device *)(eth_dev)->data->dev_private;
+	union otx_ep_mbox_word cmd;
+	union otx_ep_mbox_word rsp;
+	int i, ret;
+
+	cmd.u64 = 0;
+	cmd.s_set_mac.opcode = OTX_EP_MBOX_CMD_GET_MAC_ADDR;
+	ret = otx_ep_send_mbox_cmd(otx_ep, cmd, &rsp);
+	if (ret) {
+		otx_ep_err("get MAC address failed\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < RTE_ETHER_ADDR_LEN; i++)
+		mac_addr->addr_bytes[i] = rsp.s_set_mac.mac_addr[i];
+	otx_ep_dbg("%s VF MAC " RTE_ETHER_ADDR_PRT_FMT "\n",
+		    __func__, RTE_ETHER_ADDR_BYTES(mac_addr));
+	return 0;
+}
+
+int otx_ep_mbox_get_link_status(struct rte_eth_dev *eth_dev,
+				uint8_t *oper_up)
+{
+	struct otx_ep_device *otx_ep =
+		(struct otx_ep_device *)(eth_dev)->data->dev_private;
+	union otx_ep_mbox_word cmd;
+	union otx_ep_mbox_word rsp;
+	int ret;
+
+	cmd.u64 = 0;
+	cmd.s_link_status.opcode = OTX_EP_MBOX_CMD_GET_LINK_STATUS;
+	ret = otx_ep_send_mbox_cmd(otx_ep, cmd, &rsp);
+	if (ret) {
+		otx_ep_err("Get link status failed\n");
+		return -EINVAL;
+	}
+	*oper_up = rsp.s_link_status.status;
+	return 0;
+}
+
+int otx_ep_mbox_get_link_info(struct rte_eth_dev *eth_dev,
+			      struct rte_eth_link *link)
+{
+	int32_t ret, size;
+	struct otx_ep_iface_link_info link_info;
+	struct otx_ep_device *otx_ep =
+		(struct otx_ep_device *)(eth_dev)->data->dev_private;
+	memset(&link_info, 0, sizeof(struct otx_ep_iface_link_info));
+	ret = otx_ep_mbox_bulk_read(otx_ep, OTX_EP_MBOX_CMD_GET_LINK_INFO,
+				      (uint8_t *)&link_info, (int32_t *)&size);
+	if (ret) {
+		otx_ep_err("Get link info failed\n");
+		return ret;
+	}
+	link->link_status = RTE_ETH_LINK_UP;
+	link->link_duplex = RTE_ETH_LINK_FULL_DUPLEX;
+	link->link_autoneg = (link_info.autoneg ==
+			      OTX_EP_LINK_AUTONEG) ? RTE_ETH_LINK_AUTONEG : RTE_ETH_LINK_FIXED;
+
+	link->link_autoneg = link_info.autoneg;
+	link->link_speed = link_info.speed;
+	return 0;
+}
+
+void
+otx_ep_mbox_enable_interrupt(struct otx_ep_device *otx_ep)
+{
+	rte_write64(0x2, (uint8_t *)otx_ep->hw_addr +
+		   OTX_EP_R_MBOX_PF_VF_INT(0));
+}
+
+void
+otx_ep_mbox_disable_interrupt(struct otx_ep_device *otx_ep)
+{
+	rte_write64(0x00, (uint8_t *)otx_ep->hw_addr +
+		   OTX_EP_R_MBOX_PF_VF_INT(0));
+}
+
+int
+otx_ep_mbox_get_max_pkt_len(struct rte_eth_dev *eth_dev)
+{
+	struct otx_ep_device *otx_ep =
+		(struct otx_ep_device *)(eth_dev)->data->dev_private;
+	union otx_ep_mbox_word cmd;
+	union otx_ep_mbox_word rsp;
+	int ret;
+
+	cmd.u64 = 0;
+	cmd.s_get_mtu.opcode = OTX_EP_MBOX_CMD_GET_MTU;
+
+	ret = otx_ep_send_mbox_cmd(otx_ep, cmd, &rsp);
+	if (ret)
+		return ret;
+	return rsp.s_get_mtu.mtu;
+}
diff --git a/drivers/net/octeon_ep/otx_ep_mbox.h b/drivers/net/octeon_ep/otx_ep_mbox.h
new file mode 100644
index 0000000000000..453117f0d7173
--- /dev/null
+++ b/drivers/net/octeon_ep/otx_ep_mbox.h
@@ -0,0 +1,163 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Marvell Octeon EP (EndPoint) Ethernet Driver
+ *
+ * Copyright (C) 2020 Marvell.
+ *
+ */
+#ifndef _OTX_EP_MBOX_H_
+#define _OTX_EP_MBOX_H_
+
+
+#define OTX_EP_MBOX_VERSION 0
+
+enum otx_ep_mbox_opcode {
+	OTX_EP_MBOX_CMD_VERSION,
+	OTX_EP_MBOX_CMD_SET_MTU,
+	OTX_EP_MBOX_CMD_SET_MAC_ADDR,
+	OTX_EP_MBOX_CMD_GET_MAC_ADDR,
+	OTX_EP_MBOX_CMD_GET_LINK_INFO,
+	OTX_EP_MBOX_CMD_GET_STATS,
+	OTX_EP_MBOX_CMD_SET_RX_STATE,
+	OTX_EP_MBOX_CMD_SET_LINK_STATUS,
+	OTX_EP_MBOX_CMD_GET_LINK_STATUS,
+	OTX_EP_MBOX_CMD_GET_MTU,
+	OTX_EP_MBOX_CMD_LAST,
+};
+
+enum otx_ep_mbox_word_type {
+	OTX_EP_MBOX_TYPE_CMD,
+	OTX_EP_MBOX_TYPE_RSP_ACK,
+	OTX_EP_MBOX_TYPE_RSP_NACK,
+};
+
+enum otx_ep_mbox_cmd_status {
+	OTX_EP_MBOX_CMD_STATUS_NOT_SETUP = 1,
+	OTX_EP_MBOX_CMD_STATUS_TIMEDOUT = 2,
+	OTX_EP_MBOX_CMD_STATUS_NACK = 3,
+	OTX_EP_MBOX_CMD_STATUS_BUSY = 4
+};
+
+enum otx_ep_mbox_state {
+	OTX_EP_MBOX_STATE_IDLE = 0,
+	OTX_EP_MBOX_STATE_BUSY = 1,
+};
+
+enum otx_ep_link_status {
+	OTX_EP_LINK_STATUS_DOWN,
+	OTX_EP_LINK_STATUS_UP,
+};
+
+enum otx_ep_link_duplex {
+	OTX_EP_LINK_HALF_DUPLEX,
+	OTX_EP_LINK_FULL_DUPLEX,
+};
+
+enum otx_ep_link_autoneg {
+	OTX_EP_LINK_FIXED,
+	OTX_EP_LINK_AUTONEG,
+};
+
+#define OTX_EP_MBOX_TIMEOUT_MS     1200
+#define OTX_EP_MBOX_MAX_RETRIES    2
+#define OTX_EP_MBOX_VERSION        0
+#define OTX_EP_MBOX_MAX_DATA_SIZE  6
+#define OTX_EP_MBOX_MAX_DATA_BUF_SIZE 256
+#define OTX_EP_MBOX_MORE_FRAG_FLAG 1
+#define OTX_EP_MBOX_WRITE_WAIT_TIME msecs_to_jiffies(1)
+
+union otx_ep_mbox_word {
+	uint64_t u64;
+	struct {
+		uint64_t opcode:8;
+		uint64_t type:2;
+		uint64_t rsvd:6;
+		uint64_t data:48;
+	} s;
+	struct {
+		uint64_t opcode:8;
+		uint64_t type:2;
+		uint64_t frag:1;
+		uint64_t rsvd:5;
+		uint8_t data[6];
+	} s_data;
+	struct {
+		uint64_t opcode:8;
+		uint64_t type:2;
+		uint64_t rsvd:6;
+		uint64_t version:48;
+	} s_version;
+	struct {
+		uint64_t opcode:8;
+		uint64_t type:2;
+		uint64_t rsvd:6;
+		uint8_t mac_addr[6];
+	} s_set_mac;
+	struct {
+		uint64_t opcode:8;
+		uint64_t type:2;
+		uint64_t rsvd:6;
+		uint64_t mtu:48;
+	} s_set_mtu;
+	struct {
+		uint64_t opcode:8;
+		uint64_t type:2;
+		uint64_t rsvd:6;
+		uint64_t mtu:48;
+	} s_get_mtu;
+	struct {
+		uint64_t opcode:8;
+		uint64_t type:2;
+		uint64_t state:1;
+		uint64_t rsvd:53;
+	} s_link_state;
+	struct {
+		uint64_t opcode:8;
+		uint64_t type:2;
+		uint64_t status:1;
+		uint64_t rsvd:53;
+	} s_link_status;
+} __rte_packed;
+
+/* Hardware interface link state information. */
+struct otx_ep_iface_link_info {
+	/* Bitmap of Supported link speeds/modes. */
+	uint64_t supported_modes;
+
+	/* Bitmap of Advertised link speeds/modes. */
+	uint64_t advertised_modes;
+
+	/* Negotiated link speed in Mbps. */
+	uint32_t speed;
+
+	/* MTU */
+	uint16_t mtu;
+
+	/* Autonegotiation state. */
+#define OCTEP_VF_LINK_MODE_AUTONEG_SUPPORTED   BIT(0)
+#define OCTEP_VF_LINK_MODE_AUTONEG_ADVERTISED  BIT(1)
+	uint8_t autoneg;
+
+	/* Pause frames setting. */
+#define OCTEP_VF_LINK_MODE_PAUSE_SUPPORTED   BIT(0)
+#define OCTEP_VF_LINK_MODE_PAUSE_ADVERTISED  BIT(1)
+	uint8_t pause;
+
+	/* Admin state of the link (ifconfig <iface> up/down */
+	uint8_t  admin_up;
+
+	/* Operational state of the link: physical link is up down */
+	uint8_t  oper_up;
+};
+
+int otx_ep_mbox_set_mtu(struct rte_eth_dev *eth_dev, uint16_t mtu);
+int otx_ep_mbox_set_mac_addr(struct rte_eth_dev *eth_dev,
+			     struct rte_ether_addr *mac_addr);
+int otx_ep_mbox_get_mac_addr(struct rte_eth_dev *eth_dev,
+			     struct rte_ether_addr *mac_addr);
+int otx_ep_mbox_get_link_status(struct rte_eth_dev *eth_dev,
+				uint8_t *oper_up);
+int otx_ep_mbox_get_link_info(struct rte_eth_dev *eth_dev, struct rte_eth_link *link);
+void otx_ep_mbox_enable_interrupt(struct otx_ep_device *otx_ep);
+void otx_ep_mbox_disable_interrupt(struct otx_ep_device *otx_ep);
+int otx_ep_mbox_get_max_pkt_len(struct rte_eth_dev *eth_dev);
+#endif
diff --git a/drivers/net/octeon_ep/otx_ep_vf.c b/drivers/net/octeon_ep/otx_ep_vf.c
index 7de44d0eddb40..5b29fd95be3db 100644
--- a/drivers/net/octeon_ep/otx_ep_vf.c
+++ b/drivers/net/octeon_ep/otx_ep_vf.c
@@ -388,130 +388,6 @@ otx_ep_get_defconf(struct otx_ep_device *otx_ep_dev __rte_unused)
 	return default_conf;
 }
 
-static int
-otx_vf_send_mbox_cmd(struct otx_ep_device *otx_ep,
-			 union otx_vf_mbox_word cmd,
-			 union otx_vf_mbox_word *rsp)
-{
-	volatile uint64_t reg_val = 0ull;
-	int retry_count = 0;
-	int count = 0;
-
-	rsp->u64 = 0;
-	cmd.s.type = OTX_VF_MBOX_TYPE_CMD;
-	cmd.s.version = OTX_VF_MBOX_VERSION;
-	rte_spinlock_lock(&otx_ep->mbox_lock);
-	/* only 1 outstanding cmd at a time */
-	otx_ep->mbox_cmd_id = ~otx_ep->mbox_cmd_id;
-	cmd.s.id = otx_ep->mbox_cmd_id;
-retry:
-	otx_ep_dbg("send mbox cmd %p\n", (void *)cmd.u64);
-	otx_ep_write64(cmd.u64, otx_ep->hw_addr, OTX_EP_R_MBOX_VF_PF_DATA(0));
-	for (count = 0; count < OTX_VF_MBOX_TIMEOUT_MS; count++) {
-		rte_delay_ms(1);
-		reg_val = rte_read64(otx_ep->hw_addr +
-				      OTX_EP_R_MBOX_VF_PF_DATA(0));
-		if (reg_val != cmd.u64) {
-			rsp->u64 = reg_val;
-			if (rsp->s.id == cmd.s.id)
-				break;
-			/* resp for previous cmd. retry */
-			retry_count++;
-			if (retry_count == OTX_VF_MBOX_MAX_RETRIES)
-				break;
-			goto retry;
-		}
-	}
-	rte_spinlock_unlock(&otx_ep->mbox_lock);
-	if (count == OTX_VF_MBOX_TIMEOUT_MS ||
-	    retry_count == OTX_VF_MBOX_MAX_RETRIES) {
-		otx_ep_err("mbox timeout failure\n");
-		return -ETIMEDOUT;
-	}
-	rsp->u64 = reg_val;
-	otx_ep_dbg("mbox success\n");
-	return 0;
-}
-
-static int
-otx_vf_send_mbox_cmd_nolock(struct otx_ep_device *otx_ep,
-			 union otx_vf_mbox_word cmd,
-			 union otx_vf_mbox_word *rsp)
-{
-	volatile uint64_t reg_val = 0ull;
-	int retry_count = 0;
-	int count = 0;
-
-	rsp->u64 = 0;
-	cmd.s.type = OTX_VF_MBOX_TYPE_CMD;
-	cmd.s.version = OTX_VF_MBOX_VERSION;
-	/* only 1 outstanding cmd at a time */
-	otx_ep->mbox_cmd_id = ~otx_ep->mbox_cmd_id;
-	cmd.s.id = otx_ep->mbox_cmd_id;
-retry:
-	otx_ep_dbg("send mbox cmd nolock %p\n", (void *)cmd.u64);
-	otx_ep_write64(cmd.u64, otx_ep->hw_addr, OTX_EP_R_MBOX_VF_PF_DATA(0));
-	for (count = 0; count < OTX_VF_MBOX_TIMEOUT_MS; count++) {
-		rte_delay_ms(1);
-		reg_val = rte_read64(otx_ep->hw_addr +
-				      OTX_EP_R_MBOX_VF_PF_DATA(0));
-		if (reg_val != cmd.u64) {
-			rsp->u64 = reg_val;
-			if (rsp->s.id == cmd.s.id)
-				break;
-			/* resp for previous cmd. retry */
-			retry_count++;
-			if (retry_count == OTX_VF_MBOX_MAX_RETRIES)
-				break;
-			goto retry;
-		}
-	}
-	if (count == OTX_VF_MBOX_TIMEOUT_MS ||
-	    retry_count == OTX_VF_MBOX_MAX_RETRIES) {
-		otx_ep_err("mbox timeout failure\n");
-		return -ETIMEDOUT;
-	}
-	rsp->u64 = reg_val;
-	otx_ep_dbg("mbox success\n");
-	return 0;
-}
-
-static void
-otx_ep_vf_enable_mbox_interrupt(struct otx_ep_device *otx_ep)
-{
-	rte_write64(0x2, (uint8_t *)otx_ep->hw_addr +
-		   OTX_EP_R_MBOX_PF_VF_INT(0));
-}
-
-static void
-otx_ep_vf_disable_mbox_interrupt(struct otx_ep_device *otx_ep)
-{
-	rte_write64(0x00, (uint8_t *)otx_ep->hw_addr +
-		   OTX_EP_R_MBOX_PF_VF_INT(0));
-}
-
-static int
-otx_ep_register_interrupt(struct otx_ep_device *otx_ep,
-			rte_intr_callback_fn cb,
-			void *data, unsigned int vec)
-{
-	int rc = -1;
-
-	rc = otx_ep_register_irq(otx_ep, cb, data, vec);
-	return rc;
-}
-
-static int
-otx_ep_unregister_interrupt(struct otx_ep_device *otx_ep,
-				rte_intr_callback_fn cb,
-				void *data)
-{
-	int rc = -1;
-
-	rc = otx_ep_unregister_irq(otx_ep, cb, data);
-	return rc;
-}
-
 int
 otx_ep_vf_setup_device(struct otx_ep_device *otx_ep)
 {
@@ -548,13 +424,5 @@ otx_ep_vf_setup_device(struct otx_ep_device *otx_ep)
 
 	otx_ep->fn_list.enable_oq           = otx_ep_enable_oq;
 	otx_ep->fn_list.disable_oq          = otx_ep_disable_oq;
-
-	otx_ep->fn_list.send_mbox_cmd       =  otx_vf_send_mbox_cmd;
-	otx_ep->fn_list.send_mbox_cmd_nolock    = otx_vf_send_mbox_cmd_nolock;
-
-	otx_ep->fn_list.enable_mbox_interrupt   = otx_ep_vf_enable_mbox_interrupt;
-	otx_ep->fn_list.disable_mbox_interrupt  = otx_ep_vf_disable_mbox_interrupt;
-	otx_ep->fn_list.register_interrupt        = otx_ep_register_interrupt;
-	otx_ep->fn_list.unregister_interrupt      = otx_ep_unregister_interrupt;
 	return 0;
 }
-- 
2.25.1

