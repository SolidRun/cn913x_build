From f8249beb529aee96313d97e02a5825fe3a04bc70 Mon Sep 17 00:00:00 2001
From: Volodymyr Fialko <vfialko@marvell.com>
Date: Wed, 9 Nov 2022 16:09:10 +0100
Subject: [PATCH 031/955] common/cnxk: skip hmac hash precomputation

Operations with FC opcode requires precomputed ipad and opad hashes, but
for auth only (HMAC opcode) this is not required, thus could be skipped.

Signed-off-by: Volodymyr Fialko <vfialko@marvell.com>
Change-Id: Ia6da148ee6d247b0d610a3a4964a2c2ff3ae5b82
---
 drivers/common/cnxk/roc_se.c | 33 ++++++++++++++++++++-------------
 1 file changed, 20 insertions(+), 13 deletions(-)

diff --git a/drivers/common/cnxk/roc_se.c b/drivers/common/cnxk/roc_se.c
index 22df61f5f0894..aba7f9416d965 100644
--- a/drivers/common/cnxk/roc_se.c
+++ b/drivers/common/cnxk/roc_se.c
@@ -308,6 +308,7 @@ roc_se_auth_key_set(struct roc_se_ctx *se_ctx, roc_se_auth_type type,
 	struct roc_se_context *fctx;
 	uint8_t opcode_minor;
 	uint8_t pdcp_alg;
+	bool chained_op;
 	int ret;
 
 	if (se_ctx == NULL)
@@ -318,12 +319,12 @@ roc_se_auth_key_set(struct roc_se_ctx *se_ctx, roc_se_auth_type type,
 	k_ctx = &se_ctx->se_ctx.k_ctx;
 	fctx = &se_ctx->se_ctx.fctx;
 
+	chained_op = se_ctx->ciph_then_auth || se_ctx->auth_then_ciph;
+
 	if ((type >= ROC_SE_ZUC_EIA3) && (type <= ROC_SE_KASUMI_F9_ECB)) {
 		uint8_t *zuc_const;
 		uint32_t keyx[4];
 		uint8_t *ci_key;
-		bool chained_op =
-			se_ctx->ciph_then_auth || se_ctx->auth_then_ciph;
 
 		if (!key_len)
 			return -1;
@@ -470,19 +471,25 @@ roc_se_auth_key_set(struct roc_se_ctx *se_ctx, roc_se_auth_type type,
 	se_ctx->mac_len = mac_len;
 
 	if (key_len) {
-		se_ctx->hmac = 1;
-
-		se_ctx->auth_key = plt_zmalloc(key_len, 8);
-		if (se_ctx->auth_key == NULL)
-			return -1;
+		/*
+		 * Chained operation (FC opcode) requires precomputed ipad and opad hashes, but for
+		 * auth only (HMAC opcode) this is not required
+		 */
+		if (chained_op) {
+			memset(fctx->hmac.ipad, 0, sizeof(fctx->hmac.ipad));
+			memset(fctx->hmac.opad, 0, sizeof(fctx->hmac.opad));
+			cpt_hmac_opad_ipad_gen(type, key, key_len, &fctx->hmac);
+			fctx->enc.auth_input_type = 0;
+		} else {
+			se_ctx->hmac = 1;
 
-		memcpy(se_ctx->auth_key, key, key_len);
-		se_ctx->auth_key_len = key_len;
-		memset(fctx->hmac.ipad, 0, sizeof(fctx->hmac.ipad));
-		memset(fctx->hmac.opad, 0, sizeof(fctx->hmac.opad));
+			se_ctx->auth_key = plt_zmalloc(key_len, 8);
+			if (se_ctx->auth_key == NULL)
+				return -1;
 
-		cpt_hmac_opad_ipad_gen(type, key, key_len, &fctx->hmac);
-		fctx->enc.auth_input_type = 0;
+			memcpy(se_ctx->auth_key, key, key_len);
+			se_ctx->auth_key_len = key_len;
+		}
 	}
 	return 0;
 }
-- 
2.25.1

