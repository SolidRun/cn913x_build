From 5adcd759fa459acba4bba68d397792ad9e9f75ab Mon Sep 17 00:00:00 2001
From: Akhil Goyal <gakhil@marvell.com>
Date: Fri, 14 Jul 2023 23:47:22 +0530
Subject: [PATCH 538/955] net/cnxk: fix usage of mbuf rearm data

mbuf->rearm_data is a zero length array and it is being
used to set data from that location. This shows an error
in static code analysis.
Hence it is typecast to a pointer which can be used to
set values accordingly.

Fixes: c062f5726f61 ("net/cnxk: support IP reassembly")

Signed-off-by: Akhil Goyal <gakhil@marvell.com>
Change-Id: Ic11bb4134d94eac158d2b7258fb1623b6b580100
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/107564
Reviewed-by: Nithin Kumar Dabilpuram <ndabilpuram@marvell.com>
Tested-by: Jerin Jacob Kollanukkaran <jerinj@marvell.com>
---
 drivers/net/cnxk/cn10k_rx.h | 20 ++++++++++++++------
 1 file changed, 14 insertions(+), 6 deletions(-)

diff --git a/drivers/net/cnxk/cn10k_rx.h b/drivers/net/cnxk/cn10k_rx.h
index 0bc0adda67a02..1ace246af0166 100644
--- a/drivers/net/cnxk/cn10k_rx.h
+++ b/drivers/net/cnxk/cn10k_rx.h
@@ -561,6 +561,7 @@ nix_sec_meta_to_mbuf(uint64_t cq_w1, uint64_t cq_w5, uintptr_t inb_sa,
 		(const struct cpt_parse_hdr_s *)cpth;
 	uint64_t mbuf_init = vgetq_lane_u64(*rearm, 0);
 	struct cn10k_inb_priv_data *inb_priv;
+	uintptr_t p;
 
 	/* Clear checksum flags */
 	*ol_flags &= ~(RTE_MBUF_F_RX_L4_CKSUM_MASK |
@@ -583,7 +584,8 @@ nix_sec_meta_to_mbuf(uint64_t cq_w1, uint64_t cq_w5, uintptr_t inb_sa,
 			/* First frag len */
 			inner->pkt_len = vgetq_lane_u16(*rx_desc_field1, 2);
 			inner->data_len = vgetq_lane_u16(*rx_desc_field1, 4);
-			*(uint64_t *)(&inner->rearm_data) = mbuf_init;
+			p = (uintptr_t)&inner->rearm_data;
+			*(uint64_t *)p = mbuf_init;
 
 			/* Reassembly success */
 			nix_sec_reassemble_frags(hdr, inner, cq_w1, cq_w5, mbuf_init);
@@ -598,7 +600,7 @@ nix_sec_meta_to_mbuf(uint64_t cq_w1, uint64_t cq_w5, uintptr_t inb_sa,
 							 *rx_desc_field1, 4);
 
 			/* Data offset might be updated */
-			mbuf_init = *(uint64_t *)(&inner->rearm_data);
+			mbuf_init = *(uint64_t *)p;
 			*rearm = vsetq_lane_u64(mbuf_init, *rearm, 0);
 		} else {
 			/* Reassembly failure */
@@ -694,6 +696,7 @@ nix_cqe_xtract_mseg(const union nix_rx_parse_u *rx, struct rte_mbuf *mbuf,
 	uint64_t cq_w1;
 	int64_t len;
 	uint64_t sg;
+	uintptr_t p;
 
 	cq_w1 = *(const uint64_t *)rx;
 	if (flags & NIX_RX_REAS_F)
@@ -771,7 +774,8 @@ nix_cqe_xtract_mseg(const union nix_rx_parse_u *rx, struct rte_mbuf *mbuf,
 
 		mbuf->data_len = sg_len;
 		sg = sg >> 16;
-		*(uint64_t *)(&mbuf->rearm_data) = rearm & ~0xFFFF;
+		p = (uintptr_t)&mbuf->rearm_data;
+		*(uint64_t *)p = rearm & ~0xFFFF;
 		nb_segs--;
 		iova_list++;
 
@@ -821,7 +825,8 @@ nix_cqe_xtract_mseg(const union nix_rx_parse_u *rx, struct rte_mbuf *mbuf,
 			head->nb_segs = nb_segs;
 		}
 		mbuf = next_frag;
-		*(uint64_t *)(&mbuf->rearm_data) = rearm + ldptr;
+		p = (uintptr_t)&mbuf->rearm_data;
+		*(uint64_t *)p = rearm + ldptr;
 		mbuf->data_len = (sg & 0xFFFF) - ldptr -
 				 (flags & NIX_RX_OFFLOAD_TSTAMP_F ?
 				  CNXK_NIX_TIMESYNC_RX_OFFSET : 0);
@@ -844,7 +849,8 @@ nix_cqe_xtract_mseg(const union nix_rx_parse_u *rx, struct rte_mbuf *mbuf,
 
 
 		len = mbuf->pkt_len;
-		*(uint64_t *)(&mbuf->rearm_data) = rearm;
+		p = (uintptr_t)&mbuf->rearm_data;
+		*(uint64_t *)p = rearm;
 		mbuf->data_len = (sg & 0xFFFF) -
 				 (flags & NIX_RX_OFFLOAD_TSTAMP_F ?
 				  CNXK_NIX_TIMESYNC_RX_OFFSET : 0);
@@ -873,6 +879,7 @@ cn10k_nix_cqe_to_mbuf(const struct nix_cqe_hdr_s *cq, const uint32_t tag,
 	const uint64_t w1 = *(const uint64_t *)rx;
 	uint16_t len = rx->pkt_lenm1 + 1;
 	uint64_t ol_flags = 0;
+	uintptr_t p;
 
 	if (flag & NIX_RX_OFFLOAD_PTYPE_F)
 		mbuf->packet_type = nix_ptype_get(lookup_mem, w1);
@@ -910,7 +917,8 @@ cn10k_nix_cqe_to_mbuf(const struct nix_cqe_hdr_s *cq, const uint32_t tag,
 		mbuf->ol_flags = ol_flags;
 		mbuf->pkt_len = len;
 		mbuf->data_len = len;
-		*(uint64_t *)(&mbuf->rearm_data) = val;
+		p = (uintptr_t)&mbuf->rearm_data;
+		*(uint64_t *)p = val;
 	}
 
 	if (flag & NIX_RX_MULTI_SEG_F)
-- 
2.25.1

