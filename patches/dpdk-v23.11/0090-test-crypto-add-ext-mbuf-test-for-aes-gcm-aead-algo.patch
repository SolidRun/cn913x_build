From 9ea0247f76c6f7524b31287d32aabcf0e7a4d193 Mon Sep 17 00:00:00 2001
From: Aakash Sasidharan <asasidharan@marvell.com>
Date: Tue, 19 Sep 2023 15:39:46 +0530
Subject: [PATCH 090/513] test/crypto: add ext mbuf test for aes-gcm aead algo

Add external mbuf test for AES GCM aead algo.

Signed-off-by: Aakash Sasidharan <asasidharan@marvell.com>
Change-Id: I03fde9f574788d85fbe3ea155b318090c1bbf85e
Reviewed-by: Anoob Joseph <anoobj@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/117729
Base-Builds: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Base-Tests: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
---
 app/test/test_cryptodev.c                   | 335 ++++++++++++--------
 app/test/test_cryptodev_aead_test_vectors.h |   5 +-
 2 files changed, 202 insertions(+), 138 deletions(-)

diff --git a/app/test/test_cryptodev.c b/app/test/test_cryptodev.c
index 074decb530131..d05ec9deb177c 100644
--- a/app/test/test_cryptodev.c
+++ b/app/test/test_cryptodev.c
@@ -1526,6 +1526,136 @@ ut_setup_security_rx_inject(void)
 	return dev_configure_and_start(0);
 }
 
+static inline void
+ext_mbuf_callback_fn_free(void *addr __rte_unused, void *opaque __rte_unused)
+{
+}
+
+static inline void
+ext_mbuf_memzone_free(int nb_segs)
+{
+	int i;
+
+	for (i = 0; i <= nb_segs; i++) {
+		char mz_name[RTE_MEMZONE_NAMESIZE];
+		const struct rte_memzone *memzone;
+		snprintf(mz_name, RTE_MEMZONE_NAMESIZE, "ext_buf_%d", i);
+		memzone = rte_memzone_lookup(mz_name);
+		if (memzone != NULL) {
+			rte_memzone_free(memzone);
+			memzone = NULL;
+		}
+	}
+}
+
+static inline struct rte_mbuf *
+ext_mbuf_create(struct rte_mempool *mbuf_pool, int pkt_len,
+		int nb_segs, const void *input_text)
+{
+	struct rte_mbuf *m = NULL, *mbuf = NULL;
+	size_t data_off = 0;
+	uint8_t *dst;
+	int i, size;
+	int t_len;
+
+	if (pkt_len < 1) {
+		printf("Packet size must be 1 or more (is %d)\n", pkt_len);
+		return NULL;
+	}
+
+	if (nb_segs < 1) {
+		printf("Number of segments must be 1 or more (is %d)\n",
+				nb_segs);
+		return NULL;
+	}
+
+	t_len = pkt_len >= nb_segs ? pkt_len / nb_segs : 1;
+	size = pkt_len;
+
+	/* Create chained mbuf_src with external buffer */
+	for (i = 0; size > 0; i++) {
+		struct rte_mbuf_ext_shared_info *ret_shinfo = NULL;
+		uint16_t data_len = RTE_MIN(size, t_len);
+		char mz_name[RTE_MEMZONE_NAMESIZE];
+		const struct rte_memzone *memzone;
+		void *ext_buf_addr = NULL;
+		rte_iova_t buf_iova;
+		bool freed = false;
+		uint16_t buf_len;
+
+		buf_len = RTE_ALIGN_CEIL(data_len + 1024 +
+			sizeof(struct rte_mbuf_ext_shared_info), 8);
+
+		snprintf(mz_name, RTE_MEMZONE_NAMESIZE, "ext_buf_%d", i);
+		memzone = rte_memzone_lookup(mz_name);
+		if (memzone != NULL && memzone->len != buf_len) {
+			rte_memzone_free(memzone);
+			memzone = NULL;
+		}
+		if (memzone == NULL) {
+			memzone = rte_memzone_reserve_aligned(mz_name, buf_len, SOCKET_ID_ANY,
+				RTE_MEMZONE_IOVA_CONTIG, RTE_CACHE_LINE_SIZE);
+			if (memzone == NULL) {
+				printf("Can't allocate memory zone %s\n", mz_name);
+				return NULL;
+			}
+		}
+
+		ext_buf_addr = memzone->addr;
+		if (input_text)
+			memcpy(ext_buf_addr, RTE_PTR_ADD(input_text, data_off), data_len);
+
+		/* Create buffer to hold rte_mbuf header */
+		m = rte_pktmbuf_alloc(mbuf_pool);
+		if (i == 0)
+			mbuf = m;
+
+		if (m == NULL) {
+			printf("Cannot create segment for source mbuf");
+			goto fail;
+		}
+
+		/* Save shared data (like callback function) in external bufferâ€™s end */
+		ret_shinfo = rte_pktmbuf_ext_shinfo_init_helper(ext_buf_addr, &buf_len,
+			ext_mbuf_callback_fn_free, &freed);
+		if (ret_shinfo == NULL) {
+			printf("Shared mem initialization failed!\n");
+			goto fail;
+		}
+
+		buf_iova = rte_mem_virt2iova(ext_buf_addr);
+
+		/* Attach external buffer to mbuf */
+		rte_pktmbuf_attach_extbuf(m, ext_buf_addr, buf_iova, buf_len,
+			ret_shinfo);
+		if (m->ol_flags != RTE_MBUF_F_EXTERNAL) {
+			printf("External buffer is not attached to mbuf\n");
+			goto fail;
+		}
+
+		if (input_text) {
+			dst = (uint8_t *)rte_pktmbuf_append(m, data_len);
+			if (dst == NULL) {
+				printf("Cannot append %d bytes to the mbuf\n", data_len);
+				goto fail;
+			}
+		}
+
+		if (mbuf != m)
+			rte_pktmbuf_chain(mbuf, m);
+
+		size -= data_len;
+		data_off += data_len;
+	}
+
+	return mbuf;
+
+fail:
+	rte_pktmbuf_free(mbuf);
+	ext_mbuf_memzone_free(nb_segs);
+	return NULL;
+}
+
 void
 ut_teardown(void)
 {
@@ -1566,6 +1696,7 @@ ut_teardown(void)
 		ut_params->obuf = 0;
 	}
 	if (ut_params->ibuf) {
+		ext_mbuf_memzone_free(1);
 		rte_pktmbuf_free(ut_params->ibuf);
 		ut_params->ibuf = 0;
 	}
@@ -9003,7 +9134,7 @@ create_aead_operation(enum rte_crypto_aead_operation op,
 }
 
 static int
-test_authenticated_encryption(const struct aead_test_data *tdata)
+test_authenticated_encryption_helper(const struct aead_test_data *tdata, bool use_ext_mbuf)
 {
 	struct crypto_testsuite_params *ts_params = &testsuite_params;
 	struct crypto_unittest_params *ut_params = &unittest_params;
@@ -9048,12 +9179,27 @@ test_authenticated_encryption(const struct aead_test_data *tdata)
 		return retval;
 
 	if (tdata->aad.len > MBUF_SIZE) {
-		ut_params->ibuf = rte_pktmbuf_alloc(ts_params->large_mbuf_pool);
+		if (use_ext_mbuf) {
+			ut_params->ibuf = ext_mbuf_create(ts_params->large_mbuf_pool,
+							  AEAD_TEXT_MAX_LENGTH,
+							  1 /* nb_segs */,
+							  NULL);
+		} else {
+			ut_params->ibuf = rte_pktmbuf_alloc(ts_params->large_mbuf_pool);
+		}
 		/* Populate full size of add data */
 		for (i = 32; i < MAX_AAD_LENGTH; i += 32)
 			memcpy(&tdata->aad.data[i], &tdata->aad.data[0], 32);
-	} else
-		ut_params->ibuf = rte_pktmbuf_alloc(ts_params->mbuf_pool);
+	} else {
+		if (use_ext_mbuf) {
+			ut_params->ibuf = ext_mbuf_create(ts_params->mbuf_pool,
+							  AEAD_TEXT_MAX_LENGTH,
+							  1 /* nb_segs */,
+							  NULL);
+		} else {
+			ut_params->ibuf = rte_pktmbuf_alloc(ts_params->mbuf_pool);
+		}
+	}
 
 	/* clear mbuf payload */
 	memset(rte_pktmbuf_mtod(ut_params->ibuf, uint8_t *), 0,
@@ -9118,6 +9264,12 @@ test_authenticated_encryption(const struct aead_test_data *tdata)
 
 }
 
+static int
+test_authenticated_encryption(const struct aead_test_data *tdata)
+{
+	return test_authenticated_encryption_helper(tdata, false);
+}
+
 #ifdef RTE_LIB_SECURITY
 static int
 security_proto_supported(enum rte_security_session_action_type action,
@@ -9946,133 +10098,6 @@ test_PDCP_SDAP_PROTO_decap_all(void)
 	return (all_err == TEST_SUCCESS) ? TEST_SUCCESS : TEST_FAILED;
 }
 
-static inline void
-ext_mbuf_callback_fn_free(void *addr __rte_unused, void *opaque __rte_unused)
-{
-}
-
-static inline void
-ext_mbuf_memzone_free(int nb_segs)
-{
-	int i;
-
-	for (i = 0; i <= nb_segs; i++) {
-		char mz_name[RTE_MEMZONE_NAMESIZE];
-		const struct rte_memzone *memzone;
-		snprintf(mz_name, RTE_MEMZONE_NAMESIZE, "ext_buf_%d", i);
-		memzone = rte_memzone_lookup(mz_name);
-		if (memzone != NULL) {
-			rte_memzone_free(memzone);
-			memzone = NULL;
-		}
-	}
-}
-
-static inline struct rte_mbuf *
-ext_mbuf_create(struct rte_mempool *mbuf_pool, int pkt_len,
-		int nb_segs, const void *input_text)
-{
-	struct rte_mbuf *m = NULL, *mbuf = NULL;
-	size_t data_off = 0;
-	uint8_t *dst;
-	int i, size;
-	int t_len;
-
-	if (pkt_len < 1) {
-		printf("Packet size must be 1 or more (is %d)\n", pkt_len);
-		return NULL;
-	}
-
-	if (nb_segs < 1) {
-		printf("Number of segments must be 1 or more (is %d)\n",
-				nb_segs);
-		return NULL;
-	}
-
-	t_len = pkt_len >= nb_segs ? pkt_len / nb_segs : 1;
-	size = pkt_len;
-
-	/* Create chained mbuf_src with external buffer */
-	for (i = 0; size > 0; i++) {
-		struct rte_mbuf_ext_shared_info *ret_shinfo = NULL;
-		uint16_t data_len = RTE_MIN(size, t_len);
-		char mz_name[RTE_MEMZONE_NAMESIZE];
-		const struct rte_memzone *memzone;
-		void *ext_buf_addr = NULL;
-		rte_iova_t buf_iova;
-		bool freed = false;
-		uint16_t buf_len;
-
-		buf_len = RTE_ALIGN_CEIL(data_len + 1024 +
-			sizeof(struct rte_mbuf_ext_shared_info), 8);
-
-		snprintf(mz_name, RTE_MEMZONE_NAMESIZE, "ext_buf_%d", i);
-		memzone = rte_memzone_lookup(mz_name);
-		if (memzone != NULL && memzone->len != buf_len) {
-			rte_memzone_free(memzone);
-			memzone = NULL;
-		}
-		if (memzone == NULL) {
-			memzone = rte_memzone_reserve_aligned(mz_name, buf_len, SOCKET_ID_ANY,
-				RTE_MEMZONE_IOVA_CONTIG, RTE_CACHE_LINE_SIZE);
-			if (memzone == NULL) {
-				printf("Can't allocate memory zone %s\n", mz_name);
-				return NULL;
-			}
-		}
-
-		ext_buf_addr = memzone->addr;
-		memcpy(ext_buf_addr, RTE_PTR_ADD(input_text, data_off), data_len);
-
-		/* Create buffer to hold rte_mbuf header */
-		m = rte_pktmbuf_alloc(mbuf_pool);
-		if (i == 0)
-			mbuf = m;
-
-		if (m == NULL) {
-			printf("Cannot create segment for source mbuf");
-			goto fail;
-		}
-
-		/* Save shared data (like callback function) in external buffer's end */
-		ret_shinfo = rte_pktmbuf_ext_shinfo_init_helper(ext_buf_addr, &buf_len,
-			ext_mbuf_callback_fn_free, &freed);
-		if (ret_shinfo == NULL) {
-			printf("Shared mem initialization failed!\n");
-			goto fail;
-		}
-
-		buf_iova = rte_mem_virt2iova(ext_buf_addr);
-
-		/* Attach external buffer to mbuf */
-		rte_pktmbuf_attach_extbuf(m, ext_buf_addr, buf_iova, buf_len,
-			ret_shinfo);
-		if (m->ol_flags != RTE_MBUF_F_EXTERNAL) {
-			printf("External buffer is not attached to mbuf\n");
-			goto fail;
-		}
-
-		dst = (uint8_t *)rte_pktmbuf_append(m, data_len);
-		if (dst == NULL) {
-			printf("Cannot append %d bytes to the mbuf\n", data_len);
-			goto fail;
-		}
-
-		if (mbuf != m)
-			rte_pktmbuf_chain(mbuf, m);
-
-		size -= data_len;
-		data_off += data_len;
-	}
-
-	return mbuf;
-
-fail:
-	rte_pktmbuf_free(mbuf);
-	ext_mbuf_memzone_free(nb_segs);
-	return NULL;
-}
-
 static int
 test_ipsec_proto_crypto_op_enq(struct crypto_testsuite_params *ts_params,
 			       struct crypto_unittest_params *ut_params,
@@ -12068,6 +12093,12 @@ test_AES_GCM_authenticated_encryption_test_case_3(void)
 	return test_authenticated_encryption(&gcm_test_case_3);
 }
 
+static int
+test_AES_GCM_authenticated_encryption_test_case_3_ext_mbuf(void)
+{
+	return test_authenticated_encryption_helper(&gcm_test_case_3, true);
+}
+
 static int
 test_AES_GCM_authenticated_encryption_test_case_4(void)
 {
@@ -12300,7 +12331,7 @@ test_AES_GCM_auth_encryption_fail_tag_corrupt(void)
 }
 
 static int
-test_authenticated_decryption(const struct aead_test_data *tdata)
+test_authenticated_decryption_helper(const struct aead_test_data *tdata, bool use_ext_mbuf)
 {
 	struct crypto_testsuite_params *ts_params = &testsuite_params;
 	struct crypto_unittest_params *ut_params = &unittest_params;
@@ -12345,13 +12376,27 @@ test_authenticated_decryption(const struct aead_test_data *tdata)
 
 	/* alloc mbuf and set payload */
 	if (tdata->aad.len > MBUF_SIZE) {
-		ut_params->ibuf = rte_pktmbuf_alloc(ts_params->large_mbuf_pool);
+		if (use_ext_mbuf) {
+			ut_params->ibuf = ext_mbuf_create(ts_params->large_mbuf_pool,
+							  AEAD_TEXT_MAX_LENGTH,
+							  1 /* nb_segs */,
+							  NULL);
+		} else {
+			ut_params->ibuf = rte_pktmbuf_alloc(ts_params->large_mbuf_pool);
+		}
 		/* Populate full size of add data */
 		for (i = 32; i < MAX_AAD_LENGTH; i += 32)
 			memcpy(&tdata->aad.data[i], &tdata->aad.data[0], 32);
-	} else
-		ut_params->ibuf = rte_pktmbuf_alloc(ts_params->mbuf_pool);
-
+	} else {
+		if (use_ext_mbuf) {
+			ut_params->ibuf = ext_mbuf_create(ts_params->mbuf_pool,
+							  AEAD_TEXT_MAX_LENGTH,
+							  1 /* nb_segs */,
+							  NULL);
+		} else {
+			ut_params->ibuf = rte_pktmbuf_alloc(ts_params->mbuf_pool);
+		}
+	}
 	memset(rte_pktmbuf_mtod(ut_params->ibuf, uint8_t *), 0,
 			rte_pktmbuf_tailroom(ut_params->ibuf));
 
@@ -12404,6 +12449,12 @@ test_authenticated_decryption(const struct aead_test_data *tdata)
 	return 0;
 }
 
+static int
+test_authenticated_decryption(const struct aead_test_data *tdata)
+{
+	return test_authenticated_decryption_helper(tdata, false);
+}
+
 static int
 test_AES_GCM_authenticated_decryption_test_case_1(void)
 {
@@ -12422,6 +12473,12 @@ test_AES_GCM_authenticated_decryption_test_case_3(void)
 	return test_authenticated_decryption(&gcm_test_case_3);
 }
 
+static int
+test_AES_GCM_authenticated_decryption_test_case_3_ext_mbuf(void)
+{
+	return test_authenticated_decryption_helper(&gcm_test_case_3, true);
+}
+
 static int
 test_AES_GCM_authenticated_decryption_test_case_4(void)
 {
@@ -17488,6 +17545,12 @@ static struct unit_test_suite cryptodev_aes_gcm_auth_testsuite  = {
 		TEST_CASE_ST(ut_setup, ut_teardown,
 			test_AES_GCM_authenticated_decryption_sessionless_test_case_1),
 
+		/** AES GCM external mbuf tests */
+		TEST_CASE_ST(ut_setup, ut_teardown,
+			test_AES_GCM_authenticated_encryption_test_case_3_ext_mbuf),
+		TEST_CASE_ST(ut_setup, ut_teardown,
+			test_AES_GCM_authenticated_decryption_test_case_3_ext_mbuf),
+
 		TEST_CASES_END()
 	}
 };
diff --git a/app/test/test_cryptodev_aead_test_vectors.h b/app/test/test_cryptodev_aead_test_vectors.h
index 07292620a4b75..9213e496db6c7 100644
--- a/app/test/test_cryptodev_aead_test_vectors.h
+++ b/app/test/test_cryptodev_aead_test_vectors.h
@@ -8,6 +8,7 @@
 #define GMAC_LARGE_PLAINTEXT_LENGTH		65344
 #define MAX_AAD_LENGTH				65536
 #define GCM_LARGE_AAD_LENGTH			65296
+#define AEAD_TEXT_MAX_LENGTH			8096
 
 static uint8_t gcm_aad_zero_text[MAX_AAD_LENGTH] = { 0 };
 
@@ -46,12 +47,12 @@ struct aead_test_data {
 	} aad;
 
 	struct {
-		uint8_t data[8096];
+		uint8_t data[AEAD_TEXT_MAX_LENGTH];
 		unsigned len;
 	} plaintext;
 
 	struct {
-		uint8_t data[8096];
+		uint8_t data[AEAD_TEXT_MAX_LENGTH];
 		unsigned len;
 	} ciphertext;
 
-- 
2.25.1

