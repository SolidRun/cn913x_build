From cf0b53034f750a9ff258a0bc5f38ad4142a5e522 Mon Sep 17 00:00:00 2001
From: Akhil Goyal <gakhil@marvell.com>
Date: Wed, 22 May 2024 17:59:33 +0530
Subject: [PATCH 341/513] test/crypto: fix enqueue dequeue callback case

The enqueue/dequeue callback test cases were using the
test_null_burst_operation() for doing enqueue/dequeue.
But this function is only designed to be run for NULL PMD.
Hence for other PMDs, the callback was not getting called.
Now, separate processing thread is removed, instead NULL crypto
operation is created and processed so that callbacks are called.
Also added a check on a global static variable to verify
that the callback is actually called and fail the case if
it is not getting called.

Fixes: 5523a75af539 ("test/crypto: add case for enqueue/dequeue callbacks")
Cc: stable@dpdk.org

Signed-off-by: Akhil Goyal <gakhil@marvell.com>
Change-Id: I29642ed5fcb3e4758318f77a25c516b54e5f3a85
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/128251
Reviewed-by: Anoob Joseph <anoobj@marvell.com>
Tested-by: Anoob Joseph <anoobj@marvell.com>
---
 app/test/test_cryptodev.c | 107 ++++++++++++++++++++++++++++++--------
 1 file changed, 86 insertions(+), 21 deletions(-)

diff --git a/app/test/test_cryptodev.c b/app/test/test_cryptodev.c
index 2f6b668ede8d2..2e3ae7ba3d51c 100644
--- a/app/test/test_cryptodev.c
+++ b/app/test/test_cryptodev.c
@@ -199,6 +199,8 @@ post_process_raw_dp_op(void *user_data,	uint32_t index __rte_unused,
 static struct crypto_testsuite_params testsuite_params = { NULL };
 struct crypto_testsuite_params *p_testsuite_params = &testsuite_params;
 static struct crypto_unittest_params unittest_params;
+static bool enq_cb_called;
+static bool deq_cb_called;
 
 int
 process_sym_raw_dp_op(uint8_t dev_id, uint16_t qp_id,
@@ -14791,6 +14793,7 @@ test_enq_callback(uint16_t dev_id, uint16_t qp_id, struct rte_crypto_op **ops,
 	RTE_SET_USED(ops);
 	RTE_SET_USED(user_param);
 
+	enq_cb_called = true;
 	printf("crypto enqueue callback called\n");
 	return nb_ops;
 }
@@ -14804,21 +14807,58 @@ test_deq_callback(uint16_t dev_id, uint16_t qp_id, struct rte_crypto_op **ops,
 	RTE_SET_USED(ops);
 	RTE_SET_USED(user_param);
 
+	deq_cb_called = true;
 	printf("crypto dequeue callback called\n");
 	return nb_ops;
 }
 
 /*
- * Thread using enqueue/dequeue callback with RCU.
+ * Process enqueue/dequeue NULL crypto request to verify callback with RCU.
  */
 static int
-test_enqdeq_callback_thread(void *arg)
+test_enqdeq_callback_null_cipher(void)
 {
-	RTE_SET_USED(arg);
-	/* DP thread calls rte_cryptodev_enqueue_burst()/
-	 * rte_cryptodev_dequeue_burst() and invokes callback.
-	 */
-	test_null_burst_operation();
+	struct crypto_testsuite_params *ts_params = &testsuite_params;
+	struct crypto_unittest_params *ut_params = &unittest_params;
+
+	/* Setup Cipher Parameters */
+	ut_params->cipher_xform.type = RTE_CRYPTO_SYM_XFORM_CIPHER;
+	ut_params->cipher_xform.next = &ut_params->auth_xform;
+
+	ut_params->cipher_xform.cipher.algo = RTE_CRYPTO_CIPHER_NULL;
+	ut_params->cipher_xform.cipher.op = RTE_CRYPTO_CIPHER_OP_ENCRYPT;
+
+	/* Setup Auth Parameters */
+	ut_params->auth_xform.type = RTE_CRYPTO_SYM_XFORM_AUTH;
+	ut_params->auth_xform.next = NULL;
+
+	ut_params->auth_xform.auth.algo = RTE_CRYPTO_AUTH_NULL;
+	ut_params->auth_xform.auth.op = RTE_CRYPTO_AUTH_OP_GENERATE;
+
+	/* Create Crypto session */
+	ut_params->sess = rte_cryptodev_sym_session_create(ts_params->valid_devs[0],
+				&ut_params->auth_xform, ts_params->session_mpool);
+	TEST_ASSERT_NOT_NULL(ut_params->sess, "Session creation failed");
+
+	ut_params->op = rte_crypto_op_alloc(ts_params->op_mpool, RTE_CRYPTO_OP_TYPE_SYMMETRIC);
+	TEST_ASSERT_NOT_NULL(ut_params->op, "Failed to allocate symmetric crypto op");
+
+	/* Allocate mbuf */
+	ut_params->ibuf = rte_pktmbuf_alloc(ts_params->mbuf_pool);
+	TEST_ASSERT_NOT_NULL(ut_params->ibuf, "Failed to allocate mbuf");
+
+	/* Append some random data */
+	TEST_ASSERT_NOT_NULL(rte_pktmbuf_append(ut_params->ibuf, sizeof(unsigned int)),
+			"no room to append data");
+
+	rte_crypto_op_attach_sym_session(ut_params->op, ut_params->sess);
+
+	ut_params->op->sym->m_src = ut_params->ibuf;
+
+	/* Process crypto operation */
+	TEST_ASSERT_NOT_NULL(process_crypto_request(ts_params->valid_devs[0], ut_params->op),
+			"failed to process sym crypto op");
+
 	return 0;
 }
 
@@ -14826,6 +14866,7 @@ static int
 test_enq_callback_setup(void)
 {
 	struct crypto_testsuite_params *ts_params = &testsuite_params;
+	struct rte_cryptodev_sym_capability_idx cap_idx;
 	struct rte_cryptodev_info dev_info;
 	struct rte_cryptodev_qp_conf qp_conf = {
 		.nb_descriptors = MAX_NUM_OPS_INFLIGHT
@@ -14833,12 +14874,18 @@ test_enq_callback_setup(void)
 
 	struct rte_cryptodev_cb *cb;
 	uint16_t qp_id = 0;
+	int j = 0;
 
-	if (gbl_driver_id == rte_cryptodev_driver_id_get(
-			RTE_STR(CRYPTODEV_NAME_CN9K_PMD)))
+	/* Verify the crypto capabilities for which enqueue/dequeue is done. */
+	cap_idx.type = RTE_CRYPTO_SYM_XFORM_AUTH;
+	cap_idx.algo.auth = RTE_CRYPTO_AUTH_NULL;
+	if (rte_cryptodev_sym_capability_get(ts_params->valid_devs[0],
+			&cap_idx) == NULL)
 		return TEST_SKIPPED;
-	else if (gbl_driver_id == rte_cryptodev_driver_id_get(
-			RTE_STR(CRYPTODEV_NAME_CN10K_PMD)))
+	cap_idx.type = RTE_CRYPTO_SYM_XFORM_CIPHER;
+	cap_idx.algo.cipher = RTE_CRYPTO_CIPHER_NULL;
+	if (rte_cryptodev_sym_capability_get(ts_params->valid_devs[0],
+			&cap_idx) == NULL)
 		return TEST_SKIPPED;
 
 	/* Stop the device in case it's started so it can be configured */
@@ -14863,6 +14910,7 @@ test_enq_callback_setup(void)
 			qp_conf.nb_descriptors, qp_id,
 			ts_params->valid_devs[0]);
 
+	enq_cb_called = false;
 	/* Test with invalid crypto device */
 	cb = rte_cryptodev_add_enq_callback(RTE_CRYPTO_MAX_DEVS,
 			qp_id, test_enq_callback, NULL);
@@ -14895,12 +14943,11 @@ test_enq_callback_setup(void)
 
 	rte_cryptodev_start(ts_params->valid_devs[0]);
 
-	/* Launch a thread */
-	rte_eal_remote_launch(test_enqdeq_callback_thread, NULL,
-				rte_get_next_lcore(-1, 1, 0));
+	TEST_ASSERT_SUCCESS(test_enqdeq_callback_null_cipher(), "Crypto Processing failed");
 
-	/* Wait until reader exited. */
-	rte_eal_mp_wait_lcore();
+	/* Wait until callback not called. */
+	while (!enq_cb_called && (j++ < 10))
+		rte_delay_ms(10);
 
 	/* Test with invalid crypto device */
 	TEST_ASSERT_FAIL(rte_cryptodev_remove_enq_callback(
@@ -14925,6 +14972,8 @@ test_enq_callback_setup(void)
 			"qp %u on cryptodev %u",
 			qp_id, ts_params->valid_devs[0]);
 
+	TEST_ASSERT(enq_cb_called == true, "Crypto enqueue callback not called");
+
 	return TEST_SUCCESS;
 }
 
@@ -14932,6 +14981,7 @@ static int
 test_deq_callback_setup(void)
 {
 	struct crypto_testsuite_params *ts_params = &testsuite_params;
+	struct rte_cryptodev_sym_capability_idx cap_idx;
 	struct rte_cryptodev_info dev_info;
 	struct rte_cryptodev_qp_conf qp_conf = {
 		.nb_descriptors = MAX_NUM_OPS_INFLIGHT
@@ -14939,6 +14989,19 @@ test_deq_callback_setup(void)
 
 	struct rte_cryptodev_cb *cb;
 	uint16_t qp_id = 0;
+	int j = 0;
+
+	/* Verify the crypto capabilities for which enqueue/dequeue is done. */
+	cap_idx.type = RTE_CRYPTO_SYM_XFORM_AUTH;
+	cap_idx.algo.auth = RTE_CRYPTO_AUTH_NULL;
+	if (rte_cryptodev_sym_capability_get(ts_params->valid_devs[0],
+			&cap_idx) == NULL)
+		return TEST_SKIPPED;
+	cap_idx.type = RTE_CRYPTO_SYM_XFORM_CIPHER;
+	cap_idx.algo.cipher = RTE_CRYPTO_CIPHER_NULL;
+	if (rte_cryptodev_sym_capability_get(ts_params->valid_devs[0],
+			&cap_idx) == NULL)
+		return TEST_SKIPPED;
 
 	/* Stop the device in case it's started so it can be configured */
 	rte_cryptodev_stop(ts_params->valid_devs[0]);
@@ -14962,6 +15025,7 @@ test_deq_callback_setup(void)
 			qp_conf.nb_descriptors, qp_id,
 			ts_params->valid_devs[0]);
 
+	deq_cb_called = false;
 	/* Test with invalid crypto device */
 	cb = rte_cryptodev_add_deq_callback(RTE_CRYPTO_MAX_DEVS,
 			qp_id, test_deq_callback, NULL);
@@ -14994,12 +15058,11 @@ test_deq_callback_setup(void)
 
 	rte_cryptodev_start(ts_params->valid_devs[0]);
 
-	/* Launch a thread */
-	rte_eal_remote_launch(test_enqdeq_callback_thread, NULL,
-				rte_get_next_lcore(-1, 1, 0));
+	TEST_ASSERT_SUCCESS(test_enqdeq_callback_null_cipher(), "Crypto processing failed");
 
-	/* Wait until reader exited. */
-	rte_eal_mp_wait_lcore();
+	/* Wait until callback not called. */
+	while (!deq_cb_called && (j++ < 10))
+		rte_delay_ms(10);
 
 	/* Test with invalid crypto device */
 	TEST_ASSERT_FAIL(rte_cryptodev_remove_deq_callback(
@@ -15024,6 +15087,8 @@ test_deq_callback_setup(void)
 			"qp %u on cryptodev %u",
 			qp_id, ts_params->valid_devs[0]);
 
+	TEST_ASSERT(deq_cb_called == true, "Crypto dequeue callback not called");
+
 	return TEST_SUCCESS;
 }
 
-- 
2.25.1

