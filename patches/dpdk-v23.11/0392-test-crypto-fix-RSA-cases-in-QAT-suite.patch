From bbfa99ad0d65f78c9a4e0c588d17820705bb8054 Mon Sep 17 00:00:00 2001
From: Arkadiusz Kusztal <arkadiuszx.kusztal@intel.com>
Date: Thu, 21 Mar 2024 08:35:02 +0000
Subject: [PATCH 392/513] test/crypto: fix RSA cases in QAT suite

This commit fixes following issues in the QAT testsuite for
the RSA algorithm:

1) Incorrectly set keys in the internal functions are now
set in the calling function.
2) Camel case functions were changed to the snake case.

Fixes: 9b5465867fb8 ("test/crypto: add RSA none padding cases")
Cc: stable@dpdk.org

Signed-off-by: Arkadiusz Kusztal <arkadiuszx.kusztal@intel.com>
Acked-by: Ciara Power <ciara.power@intel.com>
Change-Id: I8898ee6db43926756c9a7384868a49102aac642c
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/131235
Base-Builds: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Reviewed-by: Anoob Joseph <anoobj@marvell.com>
---
 app/test/test_cryptodev_asym.c             | 102 ++++++++++-----------
 app/test/test_cryptodev_rsa_test_vectors.h |   2 +-
 2 files changed, 52 insertions(+), 52 deletions(-)

diff --git a/app/test/test_cryptodev_asym.c b/app/test/test_cryptodev_asym.c
index 0d37b499d5ed1..1daca03c32615 100644
--- a/app/test/test_cryptodev_asym.c
+++ b/app/test/test_cryptodev_asym.c
@@ -3069,11 +3069,8 @@ modular_multiplicative_inverse(const void *test_data)
 	arg.qt.coef.data = coef; \
 	arg.qt.coef.length = vector->coef.len
 
-typedef void (*rsa_key_init_t)(struct rte_crypto_asym_xform *,
-	const struct rsa_test_data_2 *);
-
 static int
-RSA_Encrypt(const struct rsa_test_data_2 *vector, uint8_t *cipher_buf)
+rsa_encrypt(const struct rsa_test_data_2 *vector, uint8_t *cipher_buf)
 {
 	self->result_op = NULL;
 	/* Compute encryption on the test vector */
@@ -3091,7 +3088,7 @@ RSA_Encrypt(const struct rsa_test_data_2 *vector, uint8_t *cipher_buf)
 }
 
 static int
-RSA_Decrypt(const struct rsa_test_data_2 *vector, uint8_t *plaintext,
+rsa_decrypt(const struct rsa_test_data_2 *vector, uint8_t *plaintext,
 		const int use_op)
 {
 	uint8_t cipher[TEST_DATA_SIZE] = { 0 };
@@ -3112,41 +3109,14 @@ RSA_Decrypt(const struct rsa_test_data_2 *vector, uint8_t *plaintext,
 	return 0;
 }
 
-static void
-RSA_key_init_Exp(struct rte_crypto_asym_xform *xform,
-		const struct rsa_test_data_2 *vector)
-{
-	SET_RSA_PARAM(xform->rsa, vector, n);
-	SET_RSA_PARAM(xform->rsa, vector, e);
-	SET_RSA_PARAM(xform->rsa, vector, d);
-	xform->rsa.key_type = RTE_RSA_KEY_TYPE_EXP;
-}
-
-static void
-RSA_key_init_CRT(struct rte_crypto_asym_xform *xform,
-		const struct rsa_test_data_2 *vector)
-{
-	SET_RSA_PARAM(xform->rsa, vector, n);
-	SET_RSA_PARAM(xform->rsa, vector, e);
-	SET_RSA_PARAM_QT(xform->rsa, vector, p);
-	SET_RSA_PARAM_QT(xform->rsa, vector, q);
-	SET_RSA_PARAM_QT(xform->rsa, vector, dP);
-	SET_RSA_PARAM_QT(xform->rsa, vector, dQ);
-	SET_RSA_PARAM_QT(xform->rsa, vector, qInv);
-	xform->rsa.key_type = RTE_RSA_KEY_TYPE_QT;
-}
-
 static int
-RSA_Init_Session(const struct rsa_test_data_2 *vector,
-	rsa_key_init_t key_init)
+rsa_init_session(struct rte_crypto_asym_xform *xform)
 {
 	const uint8_t dev_id = params->valid_devs[0];
 	struct rte_cryptodev_info dev_info;
-	struct rte_crypto_asym_xform xform = { };
 	int ret = 0;
 
-	key_init(&xform, vector);
-	xform.xform_type = RTE_CRYPTO_ASYM_XFORM_RSA;
+	xform->xform_type = RTE_CRYPTO_ASYM_XFORM_RSA;
 
 	rte_cryptodev_info_get(dev_id, &dev_info);
 	if (!(dev_info.feature_flags & RTE_CRYPTODEV_FF_RSA_PRIV_OP_KEY_QT)) {
@@ -3154,7 +3124,7 @@ RSA_Init_Session(const struct rsa_test_data_2 *vector,
 			"Device doesn't support decrypt op with quintuple key type. Test skipped\n");
 		return TEST_SKIPPED;
 	}
-	ret = rte_cryptodev_asym_session_create(dev_id, &xform,
+	ret = rte_cryptodev_asym_session_create(dev_id, xform,
 		params->session_mpool, &self->sess);
 	if (ret < 0) {
 		RTE_LOG(ERR, USER1,
@@ -3165,17 +3135,23 @@ RSA_Init_Session(const struct rsa_test_data_2 *vector,
 }
 
 static int
-KAT_RSA_Encrypt(const void *data)
+kat_rsa_encrypt(const void *data)
 {
 	uint8_t cipher_buf[TEST_DATA_SIZE] = {0};
 	const struct rsa_test_data_2 *vector = data;
-	int ret = RSA_Init_Session(vector, RSA_key_init_Exp);
+	struct rte_crypto_asym_xform xform = { };
+
+	SET_RSA_PARAM(xform.rsa, vector, n);
+	SET_RSA_PARAM(xform.rsa, vector, e);
+	SET_RSA_PARAM(xform.rsa, vector, d);
+	xform.rsa.key_type = RTE_RSA_KEY_TYPE_EXP;
+	int ret = rsa_init_session(&xform);
 
 	if (ret) {
 		RTE_LOG(ERR, USER1, "Failed to init session for RSA\n");
 		return ret;
 	}
-	TEST_ASSERT_SUCCESS(RSA_Encrypt(vector, cipher_buf),
+	TEST_ASSERT_SUCCESS(rsa_encrypt(vector, cipher_buf),
 		"RSA: Failed to encrypt");
 	TEST_ASSERT_BUFFERS_ARE_EQUAL(vector->cipher.data,
 		self->result_op->asym->rsa.cipher.data,
@@ -3185,17 +3161,26 @@ KAT_RSA_Encrypt(const void *data)
 }
 
 static int
-KAT_RSA_Encrypt_CRT(const void *data)
+kat_rsa_encrypt_crt(const void *data)
 {
 	uint8_t cipher_buf[TEST_DATA_SIZE] = {0};
 	const struct rsa_test_data_2 *vector = data;
-	int ret = RSA_Init_Session(vector, RSA_key_init_CRT);
+	struct rte_crypto_asym_xform xform = { };
 
+	SET_RSA_PARAM(xform.rsa, vector, n);
+	SET_RSA_PARAM(xform.rsa, vector, e);
+	SET_RSA_PARAM_QT(xform.rsa, vector, p);
+	SET_RSA_PARAM_QT(xform.rsa, vector, q);
+	SET_RSA_PARAM_QT(xform.rsa, vector, dP);
+	SET_RSA_PARAM_QT(xform.rsa, vector, dQ);
+	SET_RSA_PARAM_QT(xform.rsa, vector, qInv);
+	xform.rsa.key_type = RTE_RSA_KEY_TYPE_QT;
+	int ret = rsa_init_session(&xform);
 	if (ret) {
 		RTE_LOG(ERR, USER1, "Failed to init session for RSA\n");
 		return ret;
 	}
-	TEST_ASSERT_SUCCESS(RSA_Encrypt(vector, cipher_buf),
+	TEST_ASSERT_SUCCESS(rsa_encrypt(vector, cipher_buf),
 		"RSA: Failed to encrypt");
 	TEST_ASSERT_BUFFERS_ARE_EQUAL(vector->cipher.data,
 		self->result_op->asym->rsa.cipher.data,
@@ -3205,17 +3190,23 @@ KAT_RSA_Encrypt_CRT(const void *data)
 }
 
 static int
-KAT_RSA_Decrypt(const void *data)
+kat_rsa_decrypt(const void *data)
 {
 	uint8_t message[TEST_DATA_SIZE] = {0};
 	const struct rsa_test_data_2 *vector = data;
-	int ret = RSA_Init_Session(vector, RSA_key_init_Exp);
+	struct rte_crypto_asym_xform xform = { };
+
+	SET_RSA_PARAM(xform.rsa, vector, n);
+	SET_RSA_PARAM(xform.rsa, vector, e);
+	SET_RSA_PARAM(xform.rsa, vector, d);
+	xform.rsa.key_type = RTE_RSA_KEY_TYPE_EXP;
+	int ret = rsa_init_session(&xform);
 
 	if (ret) {
 		RTE_LOG(ERR, USER1, "Failed to init session for RSA\n");
 		return ret;
 	}
-	TEST_ASSERT_SUCCESS(RSA_Decrypt(vector, message, 0),
+	TEST_ASSERT_SUCCESS(rsa_decrypt(vector, message, 0),
 		"RSA: Failed to encrypt");
 	TEST_ASSERT_BUFFERS_ARE_EQUAL(vector->message.data,
 		self->result_op->asym->rsa.message.data,
@@ -3225,17 +3216,26 @@ KAT_RSA_Decrypt(const void *data)
 }
 
 static int
-KAT_RSA_Decrypt_CRT(const void *data)
+kat_rsa_decrypt_crt(const void *data)
 {
 	uint8_t message[TEST_DATA_SIZE] = {0};
 	const struct rsa_test_data_2 *vector = data;
-	int ret = RSA_Init_Session(vector, RSA_key_init_CRT);
+	struct rte_crypto_asym_xform xform = { };
 
+	SET_RSA_PARAM(xform.rsa, vector, n);
+	SET_RSA_PARAM(xform.rsa, vector, e);
+	SET_RSA_PARAM_QT(xform.rsa, vector, p);
+	SET_RSA_PARAM_QT(xform.rsa, vector, q);
+	SET_RSA_PARAM_QT(xform.rsa, vector, dP);
+	SET_RSA_PARAM_QT(xform.rsa, vector, dQ);
+	SET_RSA_PARAM_QT(xform.rsa, vector, qInv);
+	xform.rsa.key_type = RTE_RSA_KEY_TYPE_QT;
+	int ret = rsa_init_session(&xform);
 	if (ret) {
 		RTE_LOG(ERR, USER1, "Failed to init session for RSA\n");
 		return ret;
 	}
-	TEST_ASSERT_SUCCESS(RSA_Decrypt(vector, message, 0),
+	TEST_ASSERT_SUCCESS(rsa_decrypt(vector, message, 0),
 		"RSA: Failed to encrypt");
 	TEST_ASSERT_BUFFERS_ARE_EQUAL(vector->message.data,
 		self->result_op->asym->rsa.message.data,
@@ -3322,20 +3322,20 @@ static struct unit_test_suite cryptodev_qat_asym_testsuite  = {
 		TEST_CASE_NAMED_WITH_DATA(
 			"RSA Encryption (n=128, pt=20, e=3) EXP, Padding: NONE",
 			ut_setup_asym, ut_teardown_asym,
-			KAT_RSA_Encrypt, &RSA_vector_128_20_3_None),
+			kat_rsa_encrypt, &rsa_vector_128_20_3_none),
 		TEST_CASE_NAMED_WITH_DATA(
 			"RSA Decryption (n=128, pt=20, e=3) EXP, Padding: NONE",
 			ut_setup_asym, ut_teardown_asym,
-			KAT_RSA_Decrypt, &RSA_vector_128_20_3_None),
+			kat_rsa_decrypt, &rsa_vector_128_20_3_none),
 		/* RSA CRT */
 		TEST_CASE_NAMED_WITH_DATA(
 			"RSA Encryption (n=128, pt=20, e=3) CRT, Padding: NONE",
 			ut_setup_asym, ut_teardown_asym,
-			KAT_RSA_Encrypt_CRT, &RSA_vector_128_20_3_None),
+			kat_rsa_encrypt_crt, &rsa_vector_128_20_3_none),
 		TEST_CASE_NAMED_WITH_DATA(
 			"RSA Decryption (n=128, pt=20, e=3) CRT, Padding: NONE",
 			ut_setup_asym, ut_teardown_asym,
-			KAT_RSA_Decrypt_CRT, &RSA_vector_128_20_3_None),
+			kat_rsa_decrypt_crt, &rsa_vector_128_20_3_none),
 		TEST_CASES_END() /**< NULL terminate unit test array */
 	}
 };
diff --git a/app/test/test_cryptodev_rsa_test_vectors.h b/app/test/test_cryptodev_rsa_test_vectors.h
index b4982014a2462..89981f13f0a18 100644
--- a/app/test/test_cryptodev_rsa_test_vectors.h
+++ b/app/test/test_cryptodev_rsa_test_vectors.h
@@ -72,7 +72,7 @@ struct rsa_test_data_2 {
 };
 
 static const struct
-rsa_test_data_2 RSA_vector_128_20_3_None = {
+rsa_test_data_2 rsa_vector_128_20_3_none = {
 	.description =
 		"RSA Encryption Decryption (n=128, pt=20, e=3) EXP, QT",
 	.xform_type = RTE_CRYPTO_ASYM_XFORM_RSA,
-- 
2.25.1

