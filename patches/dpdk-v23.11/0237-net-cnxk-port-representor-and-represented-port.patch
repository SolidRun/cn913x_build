From 898412c84b536e7871157b3b3a23ff2a9841b5a9 Mon Sep 17 00:00:00 2001
From: Harman Kalra <hkalra@marvell.com>
Date: Thu, 15 Feb 2024 15:51:49 +0530
Subject: [PATCH 237/513] net/cnxk: port representor and represented port

Supporting different combinations of port_representor and
represented_port as pattern and action.

Change-Id: I64bf0d4fc96faa93109914ca6588165e2e80e3dc
Signed-off-by: Harman Kalra <hkalra@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/122484
Base-Builds: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Reviewed-by: Kiran Kumar Kokkilagadda <kirankumark@marvell.com>
---
 drivers/net/cnxk/cnxk_flow.c | 312 +++++++++++++++++++++++++++++++----
 1 file changed, 284 insertions(+), 28 deletions(-)

diff --git a/drivers/net/cnxk/cnxk_flow.c b/drivers/net/cnxk/cnxk_flow.c
index 418c18da83147..7943ce02b5b78 100644
--- a/drivers/net/cnxk/cnxk_flow.c
+++ b/drivers/net/cnxk/cnxk_flow.c
@@ -4,6 +4,7 @@
 #include <cnxk_flow.h>
 #include <cnxk_rep.h>
 
+#define IS_REP_BIT 7
 const struct cnxk_rte_flow_term_info term[] = {
 	[RTE_FLOW_ITEM_TYPE_ETH] = {ROC_NPC_ITEM_TYPE_ETH, sizeof(struct rte_flow_item_eth)},
 	[RTE_FLOW_ITEM_TYPE_VLAN] = {ROC_NPC_ITEM_TYPE_VLAN, sizeof(struct rte_flow_item_vlan)},
@@ -185,17 +186,162 @@ roc_npc_parse_sample_subaction(struct rte_eth_dev *eth_dev, const struct rte_flo
 	return 0;
 }
 
+static int
+representor_rep_portid_action(struct roc_npc_action *in_actions, struct rte_eth_dev *eth_dev,
+			      struct rte_eth_dev *portid_eth_dev,
+			      enum rte_flow_action_type act_type, uint8_t rep_pattern,
+			      uint16_t *dst_pf_func, bool is_rep, uint64_t *free_allocs,
+			      int *act_cnt)
+{
+	struct cnxk_eth_dev *dev = cnxk_eth_pmd_priv(eth_dev);
+	struct rte_eth_dev *rep_eth_dev = portid_eth_dev;
+	struct rte_flow_action_of_set_vlan_vid *vlan_vid;
+	struct rte_flow_action_of_set_vlan_pcp *vlan_pcp;
+	struct rte_flow_action_of_push_vlan *push_vlan;
+	struct rte_flow_action_queue *act_q = NULL;
+	struct cnxk_rep_dev *rep_dev;
+	struct roc_npc *npc;
+	uint16_t vlan_tci;
+	int j = 0;
+
+	/* For inserting an action in the list */
+	int i = *act_cnt;
+
+	rep_dev = cnxk_rep_pmd_priv(rep_eth_dev);
+	if (!is_rep) {
+		dev = cnxk_eth_pmd_priv(eth_dev);
+		npc = &dev->npc;
+	} else {
+		npc = &rep_dev->parent_dev->npc;
+	}
+	if (rep_pattern >> IS_REP_BIT) { /* Check for normal/representor port as action */
+		if ((rep_pattern & 0x7f) == RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR) {
+			/* Case: Repr port pattern -> Default TX rule -> LBK ->
+			 *  Pattern RX LBK rule hit -> Action: send to new pf_func
+			 */
+			if (act_type == RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR) {
+				/* New pf_func corresponds to ESW + queue corresponding to rep_id */
+				act_q = plt_zmalloc(sizeof(struct rte_flow_action_queue), 0);
+				if (!act_q) {
+					plt_err("Error allocation memory");
+					return -ENOMEM;
+				}
+				act_q->index = rep_dev->rep_id;
+
+				while (free_allocs[j] != 0)
+					j++;
+				free_allocs[j] = (uint64_t)act_q;
+				in_actions[i].type = ROC_NPC_ACTION_TYPE_QUEUE;
+				in_actions[i].conf = (struct rte_flow_action_queue *)act_q;
+				npc->rep_act_pf_func = rep_dev->parent_dev->npc.pf_func;
+			} else {
+				/* New pf_func corresponds to hw_func of representee */
+				in_actions[i].type = ROC_NPC_ACTION_TYPE_PORT_ID;
+				npc->rep_act_pf_func = rep_dev->hw_func;
+				*dst_pf_func = rep_dev->hw_func;
+			}
+			/* Additional action to strip the VLAN from packets received by LBK */
+			i++;
+			in_actions[i].type = ROC_NPC_ACTION_TYPE_VLAN_STRIP;
+			goto done;
+		}
+		/* Case: Repd port pattern -> TX Rule with VLAN -> LBK -> Default RX LBK rule hit
+		 * base on vlan, if packet goes to ESW or actual pf_func -> Action :
+		 *    act port_representor: send to ESW respective using 1<<8 | rep_id as tci value
+		 *    act represented_port: send to actual port using rep_id as tci value.
+		 */
+		/* Add RTE_FLOW_ACTION_TYPE_OF_PUSH_VLAN action */
+		push_vlan = plt_zmalloc(sizeof(struct rte_flow_action_of_push_vlan), 0);
+		if (!push_vlan) {
+			plt_err("Error allocation memory");
+			return -ENOMEM;
+		}
+
+		while (free_allocs[j] != 0)
+			j++;
+		free_allocs[j] = (uint64_t)push_vlan;
+		push_vlan->ethertype = ntohs(ROC_ESWITCH_VLAN_TPID);
+		in_actions[i].type = ROC_NPC_ACTION_TYPE_VLAN_ETHTYPE_INSERT;
+		in_actions[i].conf = (struct rte_flow_action_of_push_vlan *)push_vlan;
+		i++;
+
+		/* Add RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_PCP action */
+		vlan_pcp = plt_zmalloc(sizeof(struct rte_flow_action_of_set_vlan_pcp), 0);
+		if (!vlan_pcp) {
+			plt_err("Error allocation memory");
+			return -ENOMEM;
+		}
+
+		free_allocs[j + 1] = (uint64_t)vlan_pcp;
+		vlan_pcp->vlan_pcp = 0;
+		in_actions[i].type = ROC_NPC_ACTION_TYPE_VLAN_PCP_INSERT;
+		in_actions[i].conf = (struct rte_flow_action_of_set_vlan_pcp *)vlan_pcp;
+		i++;
+
+		/* Add RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_VID action */
+		vlan_vid = plt_zmalloc(sizeof(struct rte_flow_action_of_set_vlan_vid), 0);
+		if (!vlan_vid) {
+			plt_err("Error allocation memory");
+			return -ENOMEM;
+		}
+
+		free_allocs[j + 2] = (uint64_t)vlan_vid;
+		if (act_type == RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR)
+			vlan_tci = rep_dev->rep_id | (1ULL << CNXK_ESWITCH_VFPF_SHIFT);
+		else
+			vlan_tci = rep_dev->rep_id;
+		vlan_vid->vlan_vid = ntohs(vlan_tci);
+		in_actions[i].type = ROC_NPC_ACTION_TYPE_VLAN_INSERT;
+		in_actions[i].conf = (struct rte_flow_action_of_set_vlan_vid *)vlan_vid;
+
+		/* Change default channel to UCAST_CHAN (63) while sending */
+		npc->rep_act_rep = true;
+	} else {
+		if (act_type == RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR) {
+			/* Case: Pattern wire port ->  Pattern RX rule->
+			 * Action: pf_func = ESW. queue = rep_id
+			 */
+			act_q = plt_zmalloc(sizeof(struct rte_flow_action_queue), 0);
+			if (!act_q) {
+				plt_err("Error allocation memory");
+				return -ENOMEM;
+			}
+			while (free_allocs[j] != 0)
+				j++;
+			free_allocs[j] = (uint64_t)act_q;
+			act_q->index = rep_dev->rep_id;
+
+			in_actions[i].type = ROC_NPC_ACTION_TYPE_QUEUE;
+			in_actions[i].conf = (struct rte_flow_action_queue *)act_q;
+			npc->rep_act_pf_func = rep_dev->parent_dev->npc.pf_func;
+		} else {
+			/* Case: Pattern wire port -> Pattern RX rule->
+			 * Action: Receive at actual hw_func
+			 */
+			in_actions[i].type = ROC_NPC_ACTION_TYPE_PORT_ID;
+			npc->rep_act_pf_func = rep_dev->hw_func;
+			*dst_pf_func = rep_dev->hw_func;
+		}
+	}
+done:
+	*act_cnt = i;
+
+	return 0;
+}
+
 static int
 representor_portid_action(struct roc_npc_action *in_actions, struct rte_eth_dev *portid_eth_dev,
-			  uint16_t *dst_pf_func, uint8_t has_tunnel_pattern, int *act_cnt)
+			  uint16_t *dst_pf_func, uint8_t has_tunnel_pattern, uint64_t *free_allocs,
+			  int *act_cnt)
 {
 	struct rte_eth_dev *rep_eth_dev = portid_eth_dev;
 	struct rte_flow_action_mark *act_mark;
 	struct cnxk_rep_dev *rep_dev;
 	/* For inserting an action in the list */
-	int i = *act_cnt;
+	int i = *act_cnt, j = 0;
 
 	rep_dev = cnxk_rep_pmd_priv(rep_eth_dev);
+
 	*dst_pf_func = rep_dev->hw_func;
 
 	/* Add Mark action */
@@ -206,6 +352,9 @@ representor_portid_action(struct roc_npc_action *in_actions, struct rte_eth_dev
 		return -ENOMEM;
 	}
 
+	while (free_allocs[j] != 0)
+		j++;
+	free_allocs[j] = (uint64_t)act_mark;
 	/* Mark ID format: (tunnel type - VxLAN, Geneve << 6) | Tunnel decap */
 	act_mark->id = has_tunnel_pattern ? ((has_tunnel_pattern << 6) | 5) : 1;
 	in_actions[i].type = ROC_NPC_ACTION_TYPE_MARK;
@@ -222,7 +371,8 @@ static int
 cnxk_map_actions(struct rte_eth_dev *eth_dev, const struct rte_flow_attr *attr,
 		 const struct rte_flow_action actions[], struct roc_npc_action in_actions[],
 		 struct roc_npc_action_sample *in_sample_actions, uint32_t *flowkey_cfg,
-		 uint16_t *dst_pf_func, uint8_t has_tunnel_pattern, bool is_rep)
+		 uint16_t *dst_pf_func, uint8_t has_tunnel_pattern, bool is_rep,
+		 uint8_t rep_pattern, uint64_t *free_allocs)
 {
 	struct cnxk_eth_dev *dev = cnxk_eth_pmd_priv(eth_dev);
 	const struct rte_flow_action_queue *act_q = NULL;
@@ -272,6 +422,35 @@ cnxk_map_actions(struct rte_eth_dev *eth_dev, const struct rte_flow_attr *attr,
 
 		case RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT:
 		case RTE_FLOW_ACTION_TYPE_PORT_REPRESENTOR:
+			in_actions[i].conf = actions->conf;
+			act_ethdev = (const struct rte_flow_action_ethdev *)actions->conf;
+			if (rte_eth_dev_get_name_by_port(act_ethdev->port_id, if_name)) {
+				plt_err("Name not found for output port id");
+				goto err_exit;
+			}
+			portid_eth_dev = rte_eth_dev_allocated(if_name);
+			if (!portid_eth_dev) {
+				plt_err("eth_dev not found for output port id");
+				goto err_exit;
+			}
+
+			plt_rep_dbg("Rule installed by port %d if_name %s act_ethdev->port_id %d",
+				    eth_dev->data->port_id, if_name, act_ethdev->port_id);
+			if (cnxk_ethdev_is_representor(if_name)) {
+				if (representor_rep_portid_action(in_actions, eth_dev,
+								  portid_eth_dev, actions->type,
+								  rep_pattern, dst_pf_func, is_rep,
+								  free_allocs, &i)) {
+					plt_err("Representor port action set failed");
+					goto err_exit;
+				}
+			} else {
+				if (actions->type == RTE_FLOW_ACTION_TYPE_REPRESENTED_PORT)
+					continue;
+				/* Normal port as represented_port as action not supported*/
+				return -ENOTSUP;
+			}
+			break;
 		case RTE_FLOW_ACTION_TYPE_PORT_ID:
 			/* No port ID action on representor ethdevs */
 			if (is_rep)
@@ -299,7 +478,7 @@ cnxk_map_actions(struct rte_eth_dev *eth_dev, const struct rte_flow_attr *attr,
 					    act_ethdev->port_id);
 				if (representor_portid_action(in_actions, portid_eth_dev,
 							      dst_pf_func, has_tunnel_pattern,
-							      &i)) {
+							      free_allocs, &i)) {
 					plt_err("Representor port action set failed");
 					goto err_exit;
 				}
@@ -402,7 +581,8 @@ cnxk_map_actions(struct rte_eth_dev *eth_dev, const struct rte_flow_attr *attr,
 
 static int
 cnxk_map_pattern(struct rte_eth_dev *eth_dev, const struct rte_flow_item pattern[],
-		 struct roc_npc_item_info in_pattern[], uint8_t *has_tunnel_pattern, bool is_rep)
+		 struct roc_npc_item_info in_pattern[], uint8_t *has_tunnel_pattern, bool is_rep,
+		 uint8_t *rep_pattern, uint64_t *free_allocs)
 {
 	const struct rte_flow_item_ethdev *rep_eth_dev;
 	struct rte_eth_dev *portid_eth_dev;
@@ -411,7 +591,7 @@ cnxk_map_pattern(struct rte_eth_dev *eth_dev, const struct rte_flow_item pattern
 	struct cnxk_rep_dev *rdev;
 	struct cnxk_eth_dev *dev;
 	struct roc_npc *npc;
-	int i = 0;
+	int i = 0, j = 0;
 
 	if (!is_rep) {
 		dev = cnxk_eth_pmd_priv(eth_dev);
@@ -443,6 +623,7 @@ cnxk_map_pattern(struct rte_eth_dev *eth_dev, const struct rte_flow_item pattern
 				plt_err("eth_dev not found for output port id");
 				goto fail;
 			}
+			*rep_pattern = pattern->type;
 			if (cnxk_ethdev_is_representor(if_name)) {
 				/* Case where represented port not part of same
 				 * app and represented by a representor port.
@@ -455,6 +636,34 @@ cnxk_map_pattern(struct rte_eth_dev *eth_dev, const struct rte_flow_item pattern
 				npc->rep_npc = &eswitch_dev->npc;
 				npc->rep_port_id = rep_eth_dev->port_id;
 				npc->rep_pf_func = rep_dev->hw_func;
+
+				if (pattern->type == RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR) {
+					struct rte_flow_item_vlan *vlan;
+
+					npc->rep_pf_func = eswitch_dev->npc.pf_func;
+					/* Add VLAN pattern corresponding to rep_id */
+					i++;
+					vlan = plt_zmalloc(sizeof(struct rte_flow_item_vlan), 0);
+					if (!vlan) {
+						plt_err("error allocation memory");
+						return -ENOMEM;
+					}
+
+					while (free_allocs[j] != 0)
+						j++;
+					free_allocs[j] = (uint64_t)vlan;
+
+					npc->rep_rx_channel = ROC_ESWITCH_LBK_CHAN;
+					vlan->hdr.vlan_tci = RTE_BE16(rep_dev->rep_id);
+					in_pattern[i].spec = (struct rte_flow_item_vlan *)vlan;
+					in_pattern[i].last = NULL;
+					in_pattern[i].mask = &rte_flow_item_vlan_mask;
+					in_pattern[i].type =
+						term[RTE_FLOW_ITEM_TYPE_VLAN].item_type;
+					in_pattern[i].size =
+						term[RTE_FLOW_ITEM_TYPE_VLAN].item_size;
+				}
+				*rep_pattern |= 1 << IS_REP_BIT;
 				plt_rep_dbg("Represented port %d act port %d rep_dev->hw_func 0x%x",
 					    rep_eth_dev->port_id, eth_dev->data->port_id,
 					    rep_dev->hw_func);
@@ -464,6 +673,9 @@ cnxk_map_pattern(struct rte_eth_dev *eth_dev, const struct rte_flow_item pattern
 					plt_err("Output port not under same driver");
 					goto fail;
 				}
+				/* Normal port as port_representor pattern can't be supported */
+				if (pattern->type == RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR)
+					return -ENOTSUP;
 				/* Case where represented port part of same app
 				 * as PF.
 				 */
@@ -494,30 +706,45 @@ cnxk_map_flow_data(struct rte_eth_dev *eth_dev, const struct rte_flow_attr *attr
 		   struct roc_npc_attr *in_attr, struct roc_npc_item_info in_pattern[],
 		   struct roc_npc_action in_actions[],
 		   struct roc_npc_action_sample *in_sample_actions, uint32_t *flowkey_cfg,
-		   uint16_t *dst_pf_func, bool is_rep)
+		   uint16_t *dst_pf_func, bool is_rep, uint64_t *free_allocs)
 {
-	uint8_t has_tunnel_pattern = 0;
+	uint8_t has_tunnel_pattern = 0, rep_pattern = 0;
 	int rc;
 
 	in_attr->priority = attr->priority;
 	in_attr->ingress = attr->ingress;
 	in_attr->egress = attr->egress;
-	if (attr->transfer) {
-		/* For representor ethdevs transfer attribute corresponds to egress rule */
-		if (is_rep)
-			in_attr->egress = attr->transfer;
-		else
-			in_attr->ingress = attr->transfer;
-	}
 
-	rc = cnxk_map_pattern(eth_dev, pattern, in_pattern, &has_tunnel_pattern, is_rep);
+	rc = cnxk_map_pattern(eth_dev, pattern, in_pattern, &has_tunnel_pattern, is_rep,
+			      &rep_pattern, free_allocs);
 	if (rc) {
 		plt_err("Failed to map pattern list");
 		return rc;
 	}
 
+	if (attr->transfer) {
+		/* rep_pattern is used to identify if RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT
+		 * OR RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR is defined + if pattern's portid is
+		 * normal port or representor port.
+		 * For normal port_id, rep_pattern = pattern-> type
+		 * For representor port, rep_pattern = pattern-> type | 1 << IS_REP_BIT
+		 */
+		if (is_rep || rep_pattern) {
+			if (rep_pattern == RTE_FLOW_ITEM_TYPE_REPRESENTED_PORT ||
+			    ((rep_pattern & 0x7f) == RTE_FLOW_ITEM_TYPE_PORT_REPRESENTOR))
+				/* If pattern is port_representor or pattern has normal port as
+				 * represented port, install ingress rule.
+				 */
+				in_attr->ingress = attr->transfer;
+			else
+				in_attr->egress = attr->transfer;
+		} else {
+			in_attr->ingress = attr->transfer;
+		}
+	}
+
 	return cnxk_map_actions(eth_dev, attr, actions, in_actions, in_sample_actions, flowkey_cfg,
-				dst_pf_func, has_tunnel_pattern, is_rep);
+				dst_pf_func, has_tunnel_pattern, is_rep, rep_pattern, free_allocs);
 }
 
 int
@@ -531,12 +758,13 @@ cnxk_flow_validate_common(struct rte_eth_dev *eth_dev, const struct rte_flow_att
 	struct roc_npc_action_sample in_sample_action;
 	struct cnxk_rep_dev *rep_dev;
 	struct roc_npc_attr in_attr;
+	uint64_t *free_allocs, sz;
 	struct cnxk_eth_dev *dev;
 	struct roc_npc_flow flow;
 	uint32_t flowkey_cfg = 0;
 	uint16_t dst_pf_func = 0;
 	struct roc_npc *npc;
-	int rc;
+	int rc, j;
 
 	/* is_rep set for operation performed via representor ports */
 	if (!is_rep) {
@@ -555,12 +783,19 @@ cnxk_flow_validate_common(struct rte_eth_dev *eth_dev, const struct rte_flow_att
 	memset(&in_sample_action, 0, sizeof(in_sample_action));
 	flow.is_validate = true;
 
+	sz = ROC_NPC_MAX_ACTION_COUNT + ROC_NPC_ITEM_TYPE_END + 1;
+	free_allocs = plt_zmalloc(sz * sizeof(uint64_t), 0);
+	if (!free_allocs) {
+		rte_flow_error_set(error, -ENOMEM, RTE_FLOW_ERROR_TYPE_ACTION_NUM, NULL,
+				   "Failed to map flow data");
+		return -ENOMEM;
+	}
 	rc = cnxk_map_flow_data(eth_dev, attr, pattern, actions, &in_attr, in_pattern, in_actions,
-				&in_sample_action, &flowkey_cfg, &dst_pf_func, is_rep);
+				&in_sample_action, &flowkey_cfg, &dst_pf_func, is_rep, free_allocs);
 	if (rc) {
 		rte_flow_error_set(error, 0, RTE_FLOW_ERROR_TYPE_ACTION_NUM, NULL,
 				   "Failed to map flow data");
-		return rc;
+		goto clean;
 	}
 
 	rc = roc_npc_flow_parse(npc, &in_attr, in_pattern, in_actions, &flow);
@@ -568,9 +803,15 @@ cnxk_flow_validate_common(struct rte_eth_dev *eth_dev, const struct rte_flow_att
 	if (rc) {
 		rte_flow_error_set(error, 0, rc, NULL,
 				   "Flow validation failed");
-		return rc;
+		goto clean;
 	}
-	return 0;
+clean:
+	/* Freeing the allocations done for additional patterns/actions */
+	for (j = 0; (j < (int)sz) && free_allocs[j]; j++)
+		plt_free((void *)free_allocs[j]);
+	plt_free(free_allocs);
+
+	return rc;
 }
 
 static int
@@ -591,13 +832,14 @@ cnxk_flow_create_common(struct rte_eth_dev *eth_dev, const struct rte_flow_attr
 	struct roc_npc_action in_actions[ROC_NPC_MAX_ACTION_COUNT];
 	struct roc_npc_action_sample in_sample_action;
 	struct cnxk_rep_dev *rep_dev = NULL;
+	struct roc_npc_flow *flow = NULL;
 	struct cnxk_eth_dev *dev = NULL;
 	struct roc_npc_attr in_attr;
-	struct roc_npc_flow *flow;
+	uint64_t *free_allocs, sz;
 	uint16_t dst_pf_func = 0;
 	struct roc_npc *npc;
 	int errcode = 0;
-	int rc;
+	int rc, j;
 
 	/* is_rep set for operation performed via representor ports */
 	if (!is_rep) {
@@ -608,22 +850,36 @@ cnxk_flow_create_common(struct rte_eth_dev *eth_dev, const struct rte_flow_attr
 		npc = &rep_dev->parent_dev->npc;
 	}
 
+	sz = ROC_NPC_MAX_ACTION_COUNT + ROC_NPC_ITEM_TYPE_END + 1;
+	free_allocs = plt_zmalloc(sz * sizeof(uint64_t), 0);
+	if (!free_allocs) {
+		rte_flow_error_set(error, -ENOMEM, RTE_FLOW_ERROR_TYPE_ACTION_NUM, NULL,
+				   "Failed to map flow data");
+		return NULL;
+	}
 	memset(&in_sample_action, 0, sizeof(in_sample_action));
 	memset(&in_attr, 0, sizeof(struct roc_npc_attr));
 	rc = cnxk_map_flow_data(eth_dev, attr, pattern, actions, &in_attr, in_pattern, in_actions,
-				&in_sample_action, &npc->flowkey_cfg_state, &dst_pf_func, is_rep);
+				&in_sample_action, &npc->flowkey_cfg_state, &dst_pf_func, is_rep,
+				free_allocs);
 	if (rc) {
-		rte_flow_error_set(error, 0, RTE_FLOW_ERROR_TYPE_ACTION_NUM, NULL,
+		rte_flow_error_set(error, rc, RTE_FLOW_ERROR_TYPE_ACTION_NUM, NULL,
 				   "Failed to map flow data");
-		return NULL;
+		goto clean;
 	}
 
 	flow = roc_npc_flow_create(npc, &in_attr, in_pattern, in_actions, dst_pf_func, &errcode);
 	if (errcode != 0) {
 		rte_flow_error_set(error, errcode, errcode, NULL, roc_error_msg_get(errcode));
-		return NULL;
+		goto clean;
 	}
 
+clean:
+	/* Freeing the allocations done for additional patterns/actions */
+	for (j = 0; (j < (int)sz) && free_allocs[j]; j++)
+		plt_free((void *)free_allocs[j]);
+	plt_free(free_allocs);
+
 	return flow;
 }
 
-- 
2.25.1

