From ba132d0805c3f092f3ea07729b1250476e869fbe Mon Sep 17 00:00:00 2001
From: Harman Kalra <hkalra@marvell.com>
Date: Fri, 2 Feb 2024 19:53:00 +0530
Subject: [PATCH 194/513] ethdev: parsing multiple representors

Updating the logic to support parsing multiple representors.
Adding test cases to demonstrate valid and invalid representor
patterns.

Change-Id: I29e42e42f35e6e3383b3f60c6f4086ad3132d610
Signed-off-by: Harman Kalra <hkalra@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/121047
Reviewed-by: Jerin Jacob <jerinj@marvell.com>
Tested-by: Jerin Jacob <jerinj@marvell.com>
---
 app/test/test_devargs.c    |  97 +++++++++++++++++++++++
 lib/ethdev/ethdev_driver.c | 155 +++++++++++++++++++++++++++----------
 2 files changed, 210 insertions(+), 42 deletions(-)

diff --git a/app/test/test_devargs.c b/app/test/test_devargs.c
index f977d44448f9a..251f43266a842 100644
--- a/app/test/test_devargs.c
+++ b/app/test/test_devargs.c
@@ -6,6 +6,7 @@
 #include <stdio.h>
 #include <string.h>
 
+#include <ethdev_driver.h>
 #include <rte_common.h>
 #include <rte_devargs.h>
 #include <rte_kvargs.h>
@@ -201,6 +202,96 @@ test_invalid_devargs(void)
 	return fail;
 }
 
+struct devargs_parse_case {
+	const char *devargs;
+	uint8_t devargs_count;
+};
+
+static int
+test_valid_devargs_parsing(void)
+{
+	static const struct devargs_parse_case list[] = {
+		/* Single representors patterns */
+		{"representor=1", 1},
+		{"representor=[1,2,3]", 1},
+		{"representor=[0-3,5,7]", 1},
+		{"representor=vf[0-1]", 1},
+		{"representor=sf[0-1]", 1},
+		{"representor=pf1vf[0-1]", 1},
+		{"representor=pf[0-1]vf[1-2]", 1},
+		{"representor=pf[0-1]sf[1-2]", 1},
+		{"representor=c0pf[0-1]", 1},
+		{"representor=sf[1,2]vf[2]", 1},
+		{"representor=c[0-1]pf[0-1]vf[1-2]", 1},
+		/* Multiple representors patterns */
+		{"representor=[vf0,3]", 2},
+		{"representor=[vf0,vf1]", 2},
+		{"representor=[vf[0],vf[1]]", 2},
+		{"representor=[vf[0,1],3]", 2},
+		{"representor=[vf[0,1],[3]]", 2},
+		{"representor=[pf1vf[0-1],3]", 2},
+		{"representor=[pf1vf[0-1],pf[0-1]]", 2},
+		{"representor=[pf1,pf3,pf1vf[0-1],vf[0],vf[1],vf0,vf1,vf2]", 8},
+		{"representor=[1,3,5,pf1,pf2,pf3,pf1vf[0-1],vf[0],vf[1],vf0,vf1,vf2]", 12},
+		{"representor=[[1,3,5],pf1,pf2,pf3,pf1vf[0-1],vf[0],vf[1],vf0,vf1,vf2]", 10},
+		{"representor=[c[0,2-4]pf[1,6]vf[0-1],vf[0],vf4,[3-5,7],pf1vf[0-1,6],pf[2,4,6]]", 6}
+	};
+	struct rte_eth_devargs eth_da[RTE_MAX_ETHPORTS];
+	uint32_t i;
+	int ret;
+	int fail = 0;
+
+	for (i = 0; i < RTE_DIM(list); i++) {
+		ret = rte_eth_devargs_parse(list[i].devargs, eth_da, RTE_MAX_ETHPORTS);
+		if (ret <= 0) {
+			printf("rte_devargs_parse(%s) returned %d (but should not)\n",
+			       list[i].devargs, ret);
+			fail = ret;
+			break;
+		}
+
+		if (ret != list[i].devargs_count) {
+			printf("Devargs returned count %d != expected count %d\n", ret,
+			       list[i].devargs_count);
+			fail = -1;
+			break;
+		}
+	}
+	return fail;
+}
+
+static int
+test_invalid_devargs_parsing(void)
+{
+	static const char * const list[] = {
+		"representor=1,2,3,4", /* Out [] missing */
+		"representor=[1 2 3]", /* , missing */
+		"representor=c[1,2]", /* Only controller no valid */
+		"representor=c0vf[0-1]", /* Controller wth vf alone not valid */
+		"representor=c0sf[0-1]", /* Controller wth sf alone not valid */
+		"representor=vf[0-1],vf3", /* Out [] missing */
+		"representor=[[vf0,3]]",   /* Double [] is invalid */
+		"representor=pfvf[1-2]",   /* No PF index provided */
+		"representor=[pf1vf[0-1], pf[0-1]]", /* Space between two devargs is invalid */
+		"representor=[pf1vf[0-1], 3]", /* Space between two devargs is invalid */
+	};
+	struct rte_eth_devargs eth_da[RTE_MAX_ETHPORTS];
+	uint32_t i;
+	int ret;
+	int fail = 0;
+
+	for (i = 0; i < RTE_DIM(list); i++) {
+		ret = rte_eth_devargs_parse(list[i], eth_da, RTE_MAX_ETHPORTS);
+		if (ret > 0) {
+			printf("rte_devargs_parse(%s) returned %d (but should not)\n",
+			       list[i], ret);
+			fail = ret;
+			break;
+		}
+	}
+	return fail;
+}
+
 static int
 test_devargs(void)
 {
@@ -210,6 +301,12 @@ test_devargs(void)
 	printf("== test invalid case ==\n");
 	if (test_invalid_devargs() < 0)
 		return -1;
+	printf("== test devargs parsing valid case ==\n");
+	if (test_valid_devargs_parsing() < 0)
+		return -1;
+	printf("== test devargs parsing invalid case ==\n");
+	if (test_invalid_devargs_parsing() < 0)
+		return -1;
 	return 0;
 }
 
diff --git a/lib/ethdev/ethdev_driver.c b/lib/ethdev/ethdev_driver.c
index f407ad2b66221..01b1825562b4a 100644
--- a/lib/ethdev/ethdev_driver.c
+++ b/lib/ethdev/ethdev_driver.c
@@ -468,16 +468,20 @@ eth_dev_devargs_tokenise(struct rte_kvargs *arglist, const char *str_in)
 				 * pair value.
 				 */
 				if ((strcmp("representor", pair->key) == 0) &&
+				    (*(letter + 1) != '\0' && *(letter + 2) != '\0' &&
+				     *(letter + 3) != '\0')			    &&
 				    ((*(letter + 2) == 'p' && *(letter + 3) == 'f')   ||
 				     (*(letter + 2) == 'v' && *(letter + 3) == 'f')   ||
 				     (*(letter + 2) == 's' && *(letter + 3) == 'f')   ||
 				     (*(letter + 2) == 'c' && isdigit(*(letter + 3))) ||
-				     (*(letter + 2) == '[' && isdigit(*(letter + 3)))))
+				     (*(letter + 2) == '[' && isdigit(*(letter + 3))) ||
+				     (isdigit(*(letter + 2)))))
 					state = 3;
 				else
 					state = 2;
-			} else if (*letter == '\0')
+			} else if (*letter == '\0') {
 				return -EINVAL;
+			}
 			break;
 		}
 		letter++;
@@ -485,48 +489,123 @@ eth_dev_devargs_tokenise(struct rte_kvargs *arglist, const char *str_in)
 }
 
 static int
-eth_dev_tokenise_representor_list(char *p_val, struct rte_eth_devargs *eth_devargs,
-				  uint8_t nb_da)
+devargs_parse_representor_ports(struct rte_eth_devargs *eth_devargs, char
+				*da_val, uint8_t da_idx, uint8_t nb_da)
 {
 	struct rte_eth_devargs *eth_da;
-	char da_val[BUFSIZ];
-	char delim[] = "]";
-	int devargs = 0;
 	int result = 0;
-	char *token;
-
-	token = strtok(&p_val[1], delim);
-	while (token != NULL) {
-		eth_da = &eth_devargs[devargs];
-		memset(eth_da, 0, sizeof(*eth_da));
-		snprintf(da_val, BUFSIZ, "%s%c", (token[0] == ',') ? ++token : token, ']');
-		/* Parse the tokenised devarg value */
-		result = rte_eth_devargs_parse_representor_ports(da_val, eth_da);
-		if (result < 0)
-			goto parse_cleanup;
+
+	if (da_idx + 1 > nb_da) {
+		RTE_ETHDEV_LOG(ERR, "Devargs parsed %d > max array size %d\n",
+			       da_idx + 1, nb_da);
+		result = -1;
+		goto parse_cleanup;
+	}
+	eth_da = &eth_devargs[da_idx];
+	memset(eth_da, 0, sizeof(*eth_da));
+	RTE_ETHDEV_LOG(DEBUG, "	  Devargs idx %d value %s\n", da_idx, da_val);
+	result = rte_eth_devargs_parse_representor_ports(da_val, eth_da);
+
+parse_cleanup:
+	return result;
+}
+
+static int
+eth_dev_tokenise_representor_list(char *p_val, struct rte_eth_devargs *eth_devargs,
+				  uint8_t nb_da)
+{
+	int result = 0, len = 0, devargs = 0;
+	char da_val[BUFSIZ], str[BUFSIZ];
+	bool is_rep_portid_list = true;
+	int i = 0, j = 0;
+	char *pos;
+
+	pos = p_val;
+	/* Length of consolidated list */
+	while (*pos++ != '\0') {
+		len++;
+		if (isalpha(*pos))
+			is_rep_portid_list = false;
+	}
+
+	/* List of representor portIDs i.e.[1,2,3] should be considered as single representor case*/
+	if (is_rep_portid_list) {
+		devargs = devargs_parse_representor_ports(eth_devargs, p_val, 0, 1);
+		if (devargs < 0)
+			return devargs;
+
 		devargs++;
-		if (devargs > nb_da) {
-			RTE_ETHDEV_LOG(ERR,
-				       "Devargs parsed %d > max array size %d\n",
-				       devargs, nb_da);
-			result = -1;
-			goto parse_cleanup;
-		}
-		token = strtok(NULL, delim);
+		return devargs;
 	}
 
+	memset(str, 0, BUFSIZ);
+	/* Remove the exterior [] of the consolidated list */
+	strncpy(str, &p_val[1], len - 2);
+	while (1) {
+		if (str[i] == '\0') {
+			if (da_val[0] != '\0') {
+				result =
+					devargs_parse_representor_ports(eth_devargs, da_val,
+									 devargs, nb_da);
+				if (result < 0)
+					goto parse_cleanup;
+
+				devargs++;
+			}
+			break;
+		}
+		if (str[i] == ',' || str[i] == '[') {
+			if (str[i] == ',') {
+				if (da_val[0] != '\0') {
+					da_val[j + 1] = '\0';
+					result =
+						devargs_parse_representor_ports(eth_devargs,
+										da_val,
+										 devargs, nb_da);
+					if (result < 0)
+						goto parse_cleanup;
+
+					devargs++;
+					j = 0;
+					memset(da_val, 0, BUFSIZ);
+				}
+			}
+
+			if (str[i] == '[') {
+				while (str[i] != ']' || isalpha(str[i + 1])) {
+					da_val[j] = str[i];
+					j++;
+					i++;
+				}
+				da_val[j] = ']';
+				da_val[j + 1] = '\0';
+				result =
+					devargs_parse_representor_ports(eth_devargs,
+									da_val,
+									 devargs, nb_da);
+				if (result < 0)
+					goto parse_cleanup;
+
+				devargs++;
+				j = 0;
+				memset(da_val, 0, BUFSIZ);
+			}
+		} else {
+			da_val[j] = str[i];
+			j++;
+		}
+		i++;
+	}
 	result = devargs;
 
 parse_cleanup:
 	return result;
-
 }
 
 int
 rte_eth_devargs_parse(const char *dargs, struct rte_eth_devargs *eth_devargs,
 		      uint8_t nb_da)
 {
-	struct rte_eth_devargs *eth_da;
 	struct rte_kvargs_pair *pair;
 	struct rte_kvargs args;
 	bool dup_rep = false;
@@ -548,7 +627,8 @@ rte_eth_devargs_parse(const char *dargs, struct rte_eth_devargs *eth_devargs,
 				goto parse_cleanup;
 			}
 
-			if (pair->value[0] == '[' && !isdigit(pair->value[1])) {
+			RTE_ETHDEV_LOG(DEBUG, "\nDevarg pattern: %s\n", pair->value);
+			if (pair->value[0] == '[') {
 				/* Multiple representor list case */
 				devargs = eth_dev_tokenise_representor_list(pair->value,
 									    eth_devargs, nb_da);
@@ -556,25 +636,16 @@ rte_eth_devargs_parse(const char *dargs, struct rte_eth_devargs *eth_devargs,
 					goto parse_cleanup;
 			} else {
 				/* Single representor case */
-				eth_da = &eth_devargs[devargs];
-				memset(eth_da, 0, sizeof(*eth_da));
-				result =
-					rte_eth_devargs_parse_representor_ports(pair->value,
-										eth_da);
-				if (result < 0)
+				devargs = devargs_parse_representor_ports(eth_devargs, pair->value,
+									  0, 1);
+				if (devargs < 0)
 					goto parse_cleanup;
 				devargs++;
-				if (devargs > nb_da) {
-					RTE_ETHDEV_LOG(ERR,
-						       "Devargs parsed %d > max array size %d\n",
-						       devargs, nb_da);
-					result = -1;
-					goto parse_cleanup;
-				}
 			}
 			dup_rep = true;
 		}
 	}
+	RTE_ETHDEV_LOG(DEBUG, "Total devargs parsed %d\n", devargs);
 	result = devargs;
 
 parse_cleanup:
-- 
2.25.1

