From 7b24b1764a842c9acd7e7ffb3e37b58f8d9782ef Mon Sep 17 00:00:00 2001
From: Anoob Joseph <anoobj@marvell.com>
Date: Mon, 22 Jul 2024 09:05:33 +0000
Subject: [PATCH 465/513] cnxk-test/cpt_raw_test: use flush API

Use PMD API for flush + invalidate.

Signed-off-by: Anoob Joseph <anoobj@marvell.com>
Change-Id: Ib4e856975811c225cd3424126bab6433968147ad
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/131703
Base-Builds: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Base-Tests: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/134280
---
 .../test/cnxk-tests/cpt_raw_test/main.c       | 156 ++----------------
 1 file changed, 18 insertions(+), 138 deletions(-)

diff --git a/marvell-ci/test/cnxk-tests/cpt_raw_test/main.c b/marvell-ci/test/cnxk-tests/cpt_raw_test/main.c
index f6691d9d554c9..b2b63fecfa308 100644
--- a/marvell-ci/test/cnxk-tests/cpt_raw_test/main.c
+++ b/marvell-ci/test/cnxk-tests/cpt_raw_test/main.c
@@ -36,14 +36,6 @@ enum cdev_type {
 	CDEV_TYPE_CRYPTO_CN10K,
 };
 
-#define CPT_CTX_CACHE_SIZE 256
-
-struct ctx_cache_mirror {
-	void *cptrs[CPT_CTX_CACHE_SIZE];
-	uint16_t head;
-	uint16_t tail;
-};
-
 struct test_ctx {
 	struct lcore_conf lconf[RTE_MAX_LCORE];
 	struct rte_mempool *cptr_mp;
@@ -52,7 +44,6 @@ struct test_ctx {
 	uint8_t nb_cryptodevs;
 	uint8_t enabled_cdevs[RTE_CRYPTO_MAX_DEVS];
 	enum cdev_type cdev_type;
-	struct ctx_cache_mirror ctx_cache;
 };
 
 static struct test_ctx ctx;
@@ -183,9 +174,7 @@ mempool_init(struct test_ctx *ctx)
 	/* Allocate CPTR mempool. */
 
 	len = MAX_CPTR_LEN;
-
-	/* Increment by 1 to make sure we can allocate all buffers. */
-	nb_elt = RTE_MAX(NB_CPTR, CPT_CTX_CACHE_SIZE) + 1;
+	nb_elt = NB_CPTR;
 
 	mp = rte_mempool_create("test_cptr_mp", nb_elt, len, 0, 0, NULL,
 				NULL, NULL, NULL, SOCKET_ID_ANY, 0);
@@ -374,137 +363,15 @@ inst_populate(struct cpt_inst_s *inst, struct test_case_params *tc_params)
 	};
 }
 
-static int
-cptr_get(struct test_ctx *ctx, void *cptrs[], int nb_cptr)
-{
-	uint16_t ctx_in_use, head, tail;
-	int ret, avail_count, i;
-
-	head = ctx->ctx_cache.head;
-	tail = ctx->ctx_cache.tail;
-
-	ctx_in_use = (CPT_CTX_CACHE_SIZE + head - ctx->ctx_cache.tail) &
-		     (CPT_CTX_CACHE_SIZE - 1);
-
-	/* Decrement avail_count by 1 since allocation fails when avail_count is 1*/
-	avail_count = rte_mempool_avail_count(ctx->cptr_mp) - 1;
-
-	if (avail_count + ctx_in_use < nb_cptr) {
-		printf("Invalid number of CPTRs requested.\n");
-		return -ENOENT;
-	}
-
-	if (avail_count >= nb_cptr) {
-		ret = rte_mempool_get_bulk(ctx->cptr_mp, cptrs, nb_cptr);
-		if (ret) {
-			printf("Could not allocate context buffers from the pool\n");
-			return ret;
-		}
-	} else {
-		if (avail_count > 0) {
-			ret = rte_mempool_get_bulk(ctx->cptr_mp, cptrs, avail_count);
-			if (ret) {
-				printf("Could not allocate context buffers from available pool\n");
-				return ret;
-			}
-		}
-
-		for (i = 0; i < nb_cptr - avail_count; i++) {
-			rte_mempool_put(ctx->cptr_mp, ctx->ctx_cache.cptrs[tail]);
-			tail = (tail + 1) & (CPT_CTX_CACHE_SIZE - 1);
-		}
-
-		ret = rte_mempool_get_bulk(ctx->cptr_mp,
-					   RTE_PTR_ADD(cptrs, sizeof(void *) * avail_count),
-					   nb_cptr - avail_count);
-		if (ret) {
-			printf("Could not allocate context buffers after freeing cache buffers\n");
-			rte_mempool_put_bulk(ctx->cptr_mp, cptrs, avail_count);
-			return ret;
-		}
-	}
-
-	ctx->ctx_cache.head = head;
-	ctx->ctx_cache.tail = tail;
-
-	return 0;
-}
-
-static void
-cptr_put(struct test_ctx *ctx, void **cptrs, int nb_cptr)
-{
-	uint16_t free_slot, ctx_in_use, head, tail, i, nb_release;
-
-	head = ctx->ctx_cache.head;
-	tail = ctx->ctx_cache.tail;
-
-	ctx_in_use = (CPT_CTX_CACHE_SIZE + head - tail) & (CPT_CTX_CACHE_SIZE - 1);
-	free_slot = CPT_CTX_CACHE_SIZE - ctx_in_use;
-
-	if (free_slot > nb_cptr) {
-		for (i = 0; i < nb_cptr; i++) {
-			ctx->ctx_cache.cptrs[head] = cptrs[i];
-			head = (head + 1) & (CPT_CTX_CACHE_SIZE - 1);
-		}
-	} else {
-		if ((ctx_in_use + nb_cptr) > CPT_CTX_CACHE_SIZE)
-			nb_release = ctx_in_use + nb_cptr - CPT_CTX_CACHE_SIZE;
-		else
-			nb_release = 0;
-
-		/* Release the ones in CTX cache to mempool. */
-		for (i = 0; i < RTE_MIN(nb_release, ctx_in_use); i++) {
-			rte_mempool_put(ctx->cptr_mp, ctx->ctx_cache.cptrs[tail]);
-			tail = (tail + 1) & (CPT_CTX_CACHE_SIZE - 1);
-		}
-
-		ctx_in_use -= i;
-		nb_release -= i;
-
-		/* Release the exceeding ones to mempool directly. */
-		if (nb_release)
-			rte_mempool_put_bulk(ctx->cptr_mp, cptrs, nb_release);
-
-		/* Keep the remaining ones in the CTX cache. */
-		for (i = 0; i < RTE_MIN(nb_release, ctx_in_use); i++) {
-			ctx->ctx_cache.cptrs[head] = cptrs[nb_release + i];
-			head = (head + 1) & (CPT_CTX_CACHE_SIZE - 1);
-		}
-	}
-
-	ctx->ctx_cache.head = head;
-	ctx->ctx_cache.tail = tail;
-}
-
-static void
-cptr_flush(struct test_ctx *ctx)
-{
-	uint16_t ctx_in_use, head, tail, i;
-
-	head = ctx->ctx_cache.head;
-	tail = ctx->ctx_cache.tail;
-
-	ctx_in_use = (CPT_CTX_CACHE_SIZE + head - tail) & (CPT_CTX_CACHE_SIZE - 1);
-
-	/* Release the ones in CTX cache to mempool. */
-	for (i = 0; i < ctx_in_use; i++) {
-		rte_mempool_put(ctx->cptr_mp, ctx->ctx_cache.cptrs[tail]);
-		tail = (tail + 1) & (CPT_CTX_CACHE_SIZE - 1);
-	}
-
-	ctx->ctx_cache.head = head;
-	ctx->ctx_cache.tail = tail;
-}
-
 static int
 test_cpt_raw_api(struct test_ctx *ctx, struct test_case_params *tc_params, int nb_dptrs)
 {
 	void *data_ptrs[NB_DESC], *rptrs[NB_DESC], *cptrs[NB_CPTR];
 	uint64_t timeout, tsc_start, tsc_end, tsc_cycles;
 	double test_us, throughput_gbps, ops_per_second;
+	int ret, i, retries, status = TEST_SUCCESS;
 	struct rte_pmd_cnxk_crypto_qptr *qptr;
 	struct cpt_inst_s *inst_mem, *inst;
-	int ret, i, status = TEST_SUCCESS;
 	union cpt_res_s res, *hw_res;
 	void *dptr;
 
@@ -548,7 +415,7 @@ test_cpt_raw_api(struct test_ctx *ctx, struct test_case_params *tc_params, int n
 		goto dptrs_free;
 	}
 
-	ret = cptr_get(ctx, cptrs, NB_CPTR);
+	ret = rte_mempool_get_bulk(ctx->cptr_mp, cptrs, NB_CPTR);
 	if (ret) {
 		printf("Could not allocate context buffers\n");
 		status = TEST_FAILED;
@@ -620,7 +487,21 @@ test_cpt_raw_api(struct test_ctx *ctx, struct test_case_params *tc_params, int n
 		status = TEST_FAILED;
 	}
 
-	cptr_put(ctx, cptrs, NB_CPTR);
+	for (i = 0; i < NB_CPTR; i++) {
+		for (retries = 0; retries < 100; retries++) {
+			ret = rte_pmd_cnxk_crypto_cptr_flush(qptr, cptrs[i], true);
+			if (ret == 0)
+				break;
+			rte_delay_ms(1);
+		}
+		if (ret < 0)
+			break;
+	}
+
+	if (ret < 0)
+		status = TEST_FAILED;
+
+	rte_mempool_put_bulk(ctx->cptr_mp, cptrs, i);
 
 rptrs_free:
 	rte_mempool_put_bulk(ctx->rptr_mp, rptrs, nb_dptrs);
@@ -690,7 +571,6 @@ int main(int argc, char **argv)
 	else
 		printf("Overall status		: [SUCCESS]\n");
 
-	cptr_flush(&ctx);
 	cryptodev_fini(&ctx);
 	mempool_fini(&ctx);
 
-- 
2.25.1

