From e26794c83905202654299f196f9e67340380e93e Mon Sep 17 00:00:00 2001
From: Gowrishankar Muthukrishnan <gmuthukrishn@marvell.com>
Date: Tue, 12 Mar 2024 21:26:20 +0530
Subject: [PATCH 279/513] test/crypto: use common test function for mod tests

Use common test function for modex and modinv tests.

Signed-off-by: Gowrishankar Muthukrishnan <gmuthukrishn@marvell.com>
Change-Id: I3684753246b26c303ebcba6709692921cb4f7535
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/123663
Reviewed-by: Anoob Joseph <anoobj@marvell.com>
Base-Builds: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
---
 app/test/test_cryptodev_asym.c             | 238 ++-------------------
 app/test/test_cryptodev_asym_util.h        |  18 --
 app/test/test_cryptodev_mod_test_vectors.h | 206 ++++++++++--------
 3 files changed, 131 insertions(+), 331 deletions(-)

diff --git a/app/test/test_cryptodev_asym.c b/app/test/test_cryptodev_asym.c
index 17daf734e8c46..566ab2b8b7f59 100644
--- a/app/test/test_cryptodev_asym.c
+++ b/app/test/test_cryptodev_asym.c
@@ -988,229 +988,6 @@ test_dh_gen_kp(struct rte_crypto_asym_xform *xfrm)
 	return status;
 }
 
-static int
-test_mod_inv(void)
-{
-	struct crypto_testsuite_params_asym *ts_params = &testsuite_params;
-	struct rte_mempool *op_mpool = ts_params->op_mpool;
-	struct rte_mempool *sess_mpool = ts_params->session_mpool;
-	uint8_t dev_id = ts_params->valid_devs[0];
-	struct rte_crypto_asym_op *asym_op = NULL;
-	struct rte_crypto_op *op = NULL, *result_op = NULL;
-	void *sess = NULL;
-	int status = TEST_SUCCESS;
-	struct rte_cryptodev_asym_capability_idx cap_idx;
-	const struct rte_cryptodev_asymmetric_xform_capability *capability;
-	uint8_t input[TEST_DATA_SIZE] = {0};
-	int ret = 0;
-	uint8_t result[sizeof(mod_p)] = { 0 };
-
-	if (rte_cryptodev_asym_get_xform_enum(
-		&modinv_xform.xform_type, "modinv") < 0) {
-		RTE_LOG(ERR, USER1,
-				 "Invalid ASYM algorithm specified\n");
-		return -1;
-	}
-
-	cap_idx.type = modinv_xform.xform_type;
-	capability = rte_cryptodev_asym_capability_get(dev_id,
-					&cap_idx);
-
-	if (capability == NULL) {
-		RTE_LOG(INFO, USER1,
-			"Device doesn't support MOD INV. Test Skipped\n");
-		return TEST_SKIPPED;
-	}
-
-	if (rte_cryptodev_asym_xform_capability_check_modlen(
-		capability,
-		modinv_xform.modinv.modulus.length)) {
-		RTE_LOG(ERR, USER1,
-				 "Invalid MODULUS length specified\n");
-				return TEST_SKIPPED;
-		}
-
-	ret = rte_cryptodev_asym_session_create(dev_id, &modinv_xform, sess_mpool, &sess);
-	if (ret < 0) {
-		RTE_LOG(ERR, USER1, "line %u "
-				"FAILED: %s", __LINE__,
-				"Session creation failed");
-		status = (ret == -ENOTSUP) ? TEST_SKIPPED : TEST_FAILED;
-		goto error_exit;
-	}
-
-	/* generate crypto op data structure */
-	op = rte_crypto_op_alloc(op_mpool, RTE_CRYPTO_OP_TYPE_ASYMMETRIC);
-	if (!op) {
-		RTE_LOG(ERR, USER1,
-			"line %u FAILED: %s",
-			__LINE__, "Failed to allocate asymmetric crypto "
-			"operation struct");
-		status = TEST_FAILED;
-		goto error_exit;
-	}
-
-	asym_op = op->asym;
-	memcpy(input, base, sizeof(base));
-	asym_op->modinv.base.data = input;
-	asym_op->modinv.base.length = sizeof(base);
-	asym_op->modinv.result.data = result;
-	asym_op->modinv.result.length = sizeof(result);
-
-	/* attach asymmetric crypto session to crypto operations */
-	rte_crypto_op_attach_asym_session(op, sess);
-
-	RTE_LOG(DEBUG, USER1, "Process ASYM operation");
-
-	/* Process crypto operation */
-	if (rte_cryptodev_enqueue_burst(dev_id, 0, &op, 1) != 1) {
-		RTE_LOG(ERR, USER1,
-			"line %u FAILED: %s",
-			__LINE__, "Error sending packet for operation");
-		status = TEST_FAILED;
-		goto error_exit;
-	}
-
-	while (rte_cryptodev_dequeue_burst(dev_id, 0, &result_op, 1) == 0)
-		rte_pause();
-
-	if (result_op == NULL) {
-		RTE_LOG(ERR, USER1,
-				"line %u FAILED: %s",
-				__LINE__, "Failed to process asym crypto op");
-		status = TEST_FAILED;
-		goto error_exit;
-	}
-
-	ret = verify_modinv(mod_inv, result_op);
-	if (ret) {
-		RTE_LOG(ERR, USER1,
-			 "operation verification failed\n");
-		status = TEST_FAILED;
-	}
-
-error_exit:
-	if (sess)
-		rte_cryptodev_asym_session_free(dev_id, sess);
-
-	rte_crypto_op_free(op);
-
-	TEST_ASSERT_EQUAL(status, 0, "Test failed");
-
-	return status;
-}
-
-static int
-test_mod_exp(void)
-{
-	struct crypto_testsuite_params_asym *ts_params = &testsuite_params;
-	struct rte_mempool *op_mpool = ts_params->op_mpool;
-	struct rte_mempool *sess_mpool = ts_params->session_mpool;
-	uint8_t dev_id = ts_params->valid_devs[0];
-	struct rte_crypto_asym_op *asym_op = NULL;
-	struct rte_crypto_op *op = NULL, *result_op = NULL;
-	void *sess = NULL;
-	int status = TEST_SUCCESS;
-	struct rte_cryptodev_asym_capability_idx cap_idx;
-	const struct rte_cryptodev_asymmetric_xform_capability *capability;
-	uint8_t input[TEST_DATA_SIZE] = {0};
-	int ret = 0;
-	uint8_t result[sizeof(mod_p)] = { 0 };
-
-	if (rte_cryptodev_asym_get_xform_enum(&modex_xform.xform_type,
-		"modexp")
-		< 0) {
-		RTE_LOG(ERR, USER1,
-				"Invalid ASYM algorithm specified\n");
-		return -1;
-	}
-
-	/* check for modlen capability */
-	cap_idx.type = modex_xform.xform_type;
-	capability = rte_cryptodev_asym_capability_get(dev_id, &cap_idx);
-
-	if (capability == NULL) {
-		RTE_LOG(INFO, USER1,
-			"Device doesn't support MOD EXP. Test Skipped\n");
-		return TEST_SKIPPED;
-	}
-
-	if (rte_cryptodev_asym_xform_capability_check_modlen(
-			capability, modex_xform.modex.modulus.length)) {
-		RTE_LOG(ERR, USER1,
-				"Invalid MODULUS length specified\n");
-				return TEST_SKIPPED;
-		}
-
-	/* Create op, create session, and process packets. 8< */
-	op = rte_crypto_op_alloc(op_mpool, RTE_CRYPTO_OP_TYPE_ASYMMETRIC);
-	if (!op) {
-		RTE_LOG(ERR, USER1,
-			"line %u FAILED: %s",
-			__LINE__, "Failed to allocate asymmetric crypto "
-			"operation struct");
-		status = TEST_FAILED;
-		goto error_exit;
-	}
-
-	ret = rte_cryptodev_asym_session_create(dev_id, &modex_xform, sess_mpool, &sess);
-	if (ret < 0) {
-		RTE_LOG(ERR, USER1,
-				 "line %u "
-				"FAILED: %s", __LINE__,
-				"Session creation failed");
-		status = (ret == -ENOTSUP) ? TEST_SKIPPED : TEST_FAILED;
-		goto error_exit;
-	}
-
-	asym_op = op->asym;
-	memcpy(input, base, sizeof(base));
-	asym_op->modex.base.data = input;
-	asym_op->modex.base.length = sizeof(base);
-	asym_op->modex.result.data = result;
-	asym_op->modex.result.length = sizeof(result);
-	/* attach asymmetric crypto session to crypto operations */
-	rte_crypto_op_attach_asym_session(op, sess);
-
-	RTE_LOG(DEBUG, USER1, "Process ASYM operation");
-	/* Process crypto operation */
-	if (rte_cryptodev_enqueue_burst(dev_id, 0, &op, 1) != 1) {
-		RTE_LOG(ERR, USER1,
-				"line %u FAILED: %s",
-				__LINE__, "Error sending packet for operation");
-		status = TEST_FAILED;
-		goto error_exit;
-	}
-
-	while (rte_cryptodev_dequeue_burst(dev_id, 0, &result_op, 1) == 0)
-		rte_pause();
-
-	if (result_op == NULL) {
-		RTE_LOG(ERR, USER1,
-				"line %u FAILED: %s",
-				__LINE__, "Failed to process asym crypto op");
-		status = TEST_FAILED;
-		goto error_exit;
-	}
-	/* >8 End of create op, create session, and process packets section. */
-	ret = verify_modexp(mod_exp, result_op);
-	if (ret) {
-		RTE_LOG(ERR, USER1,
-			 "operation verification failed\n");
-		status = TEST_FAILED;
-	}
-
-error_exit:
-	if (sess != NULL)
-		rte_cryptodev_asym_session_free(dev_id, sess);
-
-	rte_crypto_op_free(op);
-
-	TEST_ASSERT_EQUAL(status, 0, "Test failed");
-
-	return status;
-}
-
 static int
 test_dh_key_generation(void)
 {
@@ -3487,8 +3264,14 @@ static struct unit_test_suite cryptodev_openssl_asym_testsuite  = {
 				test_rsa_enc_dec_crt),
 		TEST_CASE_ST(ut_setup_asym, ut_teardown_asym,
 				test_rsa_sign_verify_crt),
-		TEST_CASE_ST(ut_setup_asym, ut_teardown_asym, test_mod_inv),
-		TEST_CASE_ST(ut_setup_asym, ut_teardown_asym, test_mod_exp),
+		TEST_CASE_NAMED_WITH_DATA(
+			"Modular Inverse",
+			ut_setup_asym, ut_teardown_asym,
+			modular_multiplicative_inverse, &modinv_test_cases[0]),
+		TEST_CASE_NAMED_WITH_DATA(
+			"Modex test",
+			ut_setup_asym, ut_teardown_asym,
+			modular_exponentiation, &modex_test_cases[0]),
 		TEST_CASE_NAMED_WITH_DATA(
 			"Modex Group 5 test",
 			ut_setup_asym, ut_teardown_asym,
@@ -3563,7 +3346,10 @@ static struct unit_test_suite cryptodev_octeontx_asym_testsuite  = {
 				test_rsa_enc_dec_crt),
 		TEST_CASE_ST(ut_setup_asym, ut_teardown_asym,
 				test_rsa_sign_verify_crt),
-		TEST_CASE_ST(ut_setup_asym, ut_teardown_asym, test_mod_exp),
+		TEST_CASE_NAMED_WITH_DATA(
+			"Modex test",
+			ut_setup_asym, ut_teardown_asym,
+			modular_exponentiation, &modex_test_cases[0]),
 		TEST_CASE_NAMED_WITH_DATA(
 			"Modex Group 5 test",
 			ut_setup_asym, ut_teardown_asym,
diff --git a/app/test/test_cryptodev_asym_util.h b/app/test/test_cryptodev_asym_util.h
index 07e6e831e82e4..72908055cf075 100644
--- a/app/test/test_cryptodev_asym_util.h
+++ b/app/test/test_cryptodev_asym_util.h
@@ -17,24 +17,6 @@ static inline int rsa_verify(struct rsa_test_data *rsa_param,
 	return 0;
 }
 
-static inline int verify_modinv(uint8_t *mod_inv,
-		struct rte_crypto_op *result_op)
-{
-	if (memcmp(mod_inv, result_op->asym->modinv.result.data,
-				result_op->asym->modinv.result.length))
-		return -1;
-	return 0;
-}
-
-static inline int verify_modexp(uint8_t *mod_exp,
-		struct rte_crypto_op *result_op)
-{
-	if (memcmp(mod_exp, result_op->asym->modex.result.data,
-				result_op->asym->modex.result.length))
-		return -1;
-	return 0;
-}
-
 static inline int verify_ecdsa_sign(uint8_t *sign_r,
 		uint8_t *sign_s, struct rte_crypto_op *result_op)
 {
diff --git a/app/test/test_cryptodev_mod_test_vectors.h b/app/test/test_cryptodev_mod_test_vectors.h
index a4e06c02912d8..b2250dc95afe0 100644
--- a/app/test/test_cryptodev_mod_test_vectors.h
+++ b/app/test/test_cryptodev_mod_test_vectors.h
@@ -167,103 +167,135 @@ modinv_test_data modinv_test_case = {
 };
 
 /* modular operation test data */
-uint8_t base[] = {
-	0xF8, 0xBA, 0x1A, 0x55, 0xD0, 0x2F, 0x85,
-	0xAE, 0x96, 0x7B, 0xB6, 0x2F, 0xB6, 0xCD,
-	0xA8, 0xEB, 0x7E, 0x78, 0xA0, 0x50
-};
-
-/* MODEX data. 8< */
-uint8_t mod_p[] = {
-	0x00, 0xb3, 0xa1, 0xaf, 0xb7, 0x13, 0x08, 0x00,
-	0x0a, 0x35, 0xdc, 0x2b, 0x20, 0x8d, 0xa1, 0xb5,
-	0xce, 0x47, 0x8a, 0xc3, 0x80, 0xf4, 0x7d, 0x4a,
-	0xa2, 0x62, 0xfd, 0x61, 0x7f, 0xb5, 0xa8, 0xde,
-	0x0a, 0x17, 0x97, 0xa0, 0xbf, 0xdf, 0x56, 0x5a,
-	0x3d, 0x51, 0x56, 0x4f, 0x70, 0x70, 0x3f, 0x63,
-	0x6a, 0x44, 0x5b, 0xad, 0x84, 0x0d, 0x3f, 0x27,
-	0x6e, 0x3b, 0x34, 0x91, 0x60, 0x14, 0xb9, 0xaa,
-	0x72, 0xfd, 0xa3, 0x64, 0xd2, 0x03, 0xa7, 0x53,
-	0x87, 0x9e, 0x88, 0x0b, 0xc1, 0x14, 0x93, 0x1a,
-	0x62, 0xff, 0xb1, 0x5d, 0x74, 0xcd, 0x59, 0x63,
-	0x18, 0x11, 0x3d, 0x4f, 0xba, 0x75, 0xd4, 0x33,
-	0x4e, 0x23, 0x6b, 0x7b, 0x57, 0x44, 0xe1, 0xd3,
-	0x03, 0x13, 0xa6, 0xf0, 0x8b, 0x60, 0xb0, 0x9e,
-	0xee, 0x75, 0x08, 0x9d, 0x71, 0x63, 0x13, 0xcb,
-	0xa6, 0x81, 0x92, 0x14, 0x03, 0x22, 0x2d, 0xde,
-	0x55
-};
-
-uint8_t mod_e[] = {0x01, 0x00, 0x01};
-/* >8 End of MODEX data. */
-
-/* Precomputed modular exponentiation for verification */
-uint8_t mod_exp[] = {
-	0x2C, 0x60, 0x75, 0x45, 0x98, 0x9D, 0xE0, 0x72,
-	0xA0, 0x9D, 0x3A, 0x9E, 0x03, 0x38, 0x73, 0x3C,
-	0x31, 0x83, 0x04, 0xFE, 0x75, 0x43, 0xE6, 0x17,
-	0x5C, 0x01, 0x29, 0x51, 0x69, 0x33, 0x62, 0x2D,
-	0x78, 0xBE, 0xAE, 0xC4, 0xBC, 0xDE, 0x7E, 0x2C,
-	0x77, 0x84, 0xF2, 0xC5, 0x14, 0xB5, 0x2F, 0xF7,
-	0xC5, 0x94, 0xEF, 0x86, 0x75, 0x75, 0xB5, 0x11,
-	0xE5, 0x0E, 0x0A, 0x29, 0x76, 0xE2, 0xEA, 0x32,
-	0x0E, 0x43, 0x77, 0x7E, 0x2C, 0x27, 0xAC, 0x3B,
-	0x86, 0xA5, 0xDB, 0xC9, 0x48, 0x40, 0xE8, 0x99,
-	0x9A, 0x0A, 0x3D, 0xD6, 0x74, 0xFA, 0x2E, 0x2E,
-	0x5B, 0xAF, 0x8C, 0x99, 0x44, 0x2A, 0x67, 0x38,
-	0x27, 0x41, 0x59, 0x9D, 0xB8, 0x51, 0xC9, 0xF7,
-	0x43, 0x61, 0x31, 0x6E, 0xF1, 0x25, 0x38, 0x7F,
-	0xAE, 0xC6, 0xD0, 0xBB, 0x29, 0x76, 0x3F, 0x46,
-	0x2E, 0x1B, 0xE4, 0x67, 0x71, 0xE3, 0x87, 0x5A
-};
 
 /* Precomputed modular inverse for verification */
-uint8_t mod_inv[] = {
-	0x52, 0xb1, 0xa3, 0x8c, 0xc5, 0x8a, 0xb9, 0x1f,
-	0xb6, 0x82, 0xf5, 0x6a, 0x9a, 0xde, 0x8d, 0x2e,
-	0x62, 0x4b, 0xac, 0x49, 0x21, 0x1d, 0x30, 0x4d,
-	0x32, 0xac, 0x1f, 0x40, 0x6d, 0x52, 0xc7, 0x9b,
-	0x6c, 0x0a, 0x82, 0x3a, 0x2c, 0xaf, 0x6b, 0x6d,
-	0x17, 0xbe, 0x43, 0xed, 0x97, 0x78, 0xeb, 0x4c,
-	0x92, 0x6f, 0xcf, 0xed, 0xb1, 0x09, 0xcb, 0x27,
-	0xc2, 0xde, 0x62, 0xfd, 0x21, 0xe6, 0xbd, 0x4f,
-	0xfe, 0x7a, 0x1b, 0x50, 0xfe, 0x10, 0x4a, 0xb0,
-	0xb7, 0xcf, 0xdb, 0x7d, 0xca, 0xc2, 0xf0, 0x1c,
-	0x39, 0x48, 0x6a, 0xb5, 0x4d, 0x8c, 0xfe, 0x63,
-	0x91, 0x9c, 0x21, 0xc3, 0x0e, 0x76, 0xad, 0x44,
-	0x8d, 0x54, 0x33, 0x99, 0xe1, 0x80, 0x19, 0xba,
-	0xb5, 0xac, 0x7d, 0x9c, 0xce, 0x91, 0x2a, 0xd9,
-	0x2c, 0xe1, 0x16, 0xd6, 0xd7, 0xcf, 0x9d, 0x05,
-	0x9a, 0x66, 0x9a, 0x3a, 0xc1, 0xb8, 0x4b, 0xc3
+static const struct
+modinv_test_data modinv_test_cases[] = {
+{
+	.description = "Modular Inverse (mod=129, base=20, exp=3, inv=128)",
+	.xform_type = RTE_CRYPTO_ASYM_XFORM_MODINV,
+	.base = {
+		.data = {
+			0xF8, 0xBA, 0x1A, 0x55, 0xD0, 0x2F, 0x85,
+			0xAE, 0x96, 0x7B, 0xB6, 0x2F, 0xB6, 0xCD,
+			0xA8, 0xEB, 0x7E, 0x78, 0xA0, 0x50
+		},
+		.len = 20
+	},
+	.inverse = {
+		.data = {
+			0x52, 0xb1, 0xa3, 0x8c, 0xc5, 0x8a, 0xb9, 0x1f,
+			0xb6, 0x82, 0xf5, 0x6a, 0x9a, 0xde, 0x8d, 0x2e,
+			0x62, 0x4b, 0xac, 0x49, 0x21, 0x1d, 0x30, 0x4d,
+			0x32, 0xac, 0x1f, 0x40, 0x6d, 0x52, 0xc7, 0x9b,
+			0x6c, 0x0a, 0x82, 0x3a, 0x2c, 0xaf, 0x6b, 0x6d,
+			0x17, 0xbe, 0x43, 0xed, 0x97, 0x78, 0xeb, 0x4c,
+			0x92, 0x6f, 0xcf, 0xed, 0xb1, 0x09, 0xcb, 0x27,
+			0xc2, 0xde, 0x62, 0xfd, 0x21, 0xe6, 0xbd, 0x4f,
+			0xfe, 0x7a, 0x1b, 0x50, 0xfe, 0x10, 0x4a, 0xb0,
+			0xb7, 0xcf, 0xdb, 0x7d, 0xca, 0xc2, 0xf0, 0x1c,
+			0x39, 0x48, 0x6a, 0xb5, 0x4d, 0x8c, 0xfe, 0x63,
+			0x91, 0x9c, 0x21, 0xc3, 0x0e, 0x76, 0xad, 0x44,
+			0x8d, 0x54, 0x33, 0x99, 0xe1, 0x80, 0x19, 0xba,
+			0xb5, 0xac, 0x7d, 0x9c, 0xce, 0x91, 0x2a, 0xd9,
+			0x2c, 0xe1, 0x16, 0xd6, 0xd7, 0xcf, 0x9d, 0x05,
+			0x9a, 0x66, 0x9a, 0x3a, 0xc1, 0xb8, 0x4b, 0xc3
+		},
+		.len = 128
+	},
+	.modulus = {
+		.data = {
+			0x00, 0xb3, 0xa1, 0xaf, 0xb7, 0x13, 0x08, 0x00,
+			0x0a, 0x35, 0xdc, 0x2b, 0x20, 0x8d, 0xa1, 0xb5,
+			0xce, 0x47, 0x8a, 0xc3, 0x80, 0xf4, 0x7d, 0x4a,
+			0xa2, 0x62, 0xfd, 0x61, 0x7f, 0xb5, 0xa8, 0xde,
+			0x0a, 0x17, 0x97, 0xa0, 0xbf, 0xdf, 0x56, 0x5a,
+			0x3d, 0x51, 0x56, 0x4f, 0x70, 0x70, 0x3f, 0x63,
+			0x6a, 0x44, 0x5b, 0xad, 0x84, 0x0d, 0x3f, 0x27,
+			0x6e, 0x3b, 0x34, 0x91, 0x60, 0x14, 0xb9, 0xaa,
+			0x72, 0xfd, 0xa3, 0x64, 0xd2, 0x03, 0xa7, 0x53,
+			0x87, 0x9e, 0x88, 0x0b, 0xc1, 0x14, 0x93, 0x1a,
+			0x62, 0xff, 0xb1, 0x5d, 0x74, 0xcd, 0x59, 0x63,
+			0x18, 0x11, 0x3d, 0x4f, 0xba, 0x75, 0xd4, 0x33,
+			0x4e, 0x23, 0x6b, 0x7b, 0x57, 0x44, 0xe1, 0xd3,
+			0x03, 0x13, 0xa6, 0xf0, 0x8b, 0x60, 0xb0, 0x9e,
+			0xee, 0x75, 0x08, 0x9d, 0x71, 0x63, 0x13, 0xcb,
+			0xa6, 0x81, 0x92, 0x14, 0x03, 0x22, 0x2d, 0xde,
+			0x55
+		},
+		.len = 129
+	}
+}
 };
 
 /* MODEX vector. 8< */
-struct rte_crypto_asym_xform modex_xform = {
-	.next = NULL,
+
+static const struct
+modex_test_data modex_test_cases[] = {
+{
+	.description = "Modular Exponentiation tests",
 	.xform_type = RTE_CRYPTO_ASYM_XFORM_MODEX,
-	.modex = {
-		.modulus = {
-			.data = mod_p,
-			.length = sizeof(mod_p)
+	.base = {
+		.data = {
+			0xF8, 0xBA, 0x1A, 0x55, 0xD0, 0x2F, 0x85, 0xAE,
+			0x96, 0x7B, 0xB6, 0x2F, 0xB6, 0xCD,	0xA8, 0xEB,
+			0x7E, 0x78, 0xA0, 0x50
+		},
+		.len = 20
+	},
+	.exponent = {
+		.data = {
+			0x01, 0x00, 0x01
+		},
+		.len = 3
+	},
+	.reminder = {
+		.data = {
+			0x2C, 0x60, 0x75, 0x45, 0x98, 0x9D, 0xE0, 0x72,
+			0xA0, 0x9D, 0x3A, 0x9E, 0x03, 0x38, 0x73, 0x3C,
+			0x31, 0x83, 0x04, 0xFE, 0x75, 0x43, 0xE6, 0x17,
+			0x5C, 0x01, 0x29, 0x51, 0x69, 0x33, 0x62, 0x2D,
+			0x78, 0xBE, 0xAE, 0xC4, 0xBC, 0xDE, 0x7E, 0x2C,
+			0x77, 0x84, 0xF2, 0xC5, 0x14, 0xB5, 0x2F, 0xF7,
+			0xC5, 0x94, 0xEF, 0x86, 0x75, 0x75, 0xB5, 0x11,
+			0xE5, 0x0E, 0x0A, 0x29, 0x76, 0xE2, 0xEA, 0x32,
+			0x0E, 0x43, 0x77, 0x7E, 0x2C, 0x27, 0xAC, 0x3B,
+			0x86, 0xA5, 0xDB, 0xC9, 0x48, 0x40, 0xE8, 0x99,
+			0x9A, 0x0A, 0x3D, 0xD6, 0x74, 0xFA, 0x2E, 0x2E,
+			0x5B, 0xAF, 0x8C, 0x99, 0x44, 0x2A, 0x67, 0x38,
+			0x27, 0x41, 0x59, 0x9D, 0xB8, 0x51, 0xC9, 0xF7,
+			0x43, 0x61, 0x31, 0x6E, 0xF1, 0x25, 0x38, 0x7F,
+			0xAE, 0xC6, 0xD0, 0xBB, 0x29, 0x76, 0x3F, 0x46,
+			0x2E, 0x1B, 0xE4, 0x67, 0x71, 0xE3, 0x87, 0x5A
 		},
-		.exponent = {
-			.data = mod_e,
-			.length = sizeof(mod_e)
-		}
+		.len = 128
+	},
+	.modulus = {
+		.data = {
+			0x00, 0xb3, 0xa1, 0xaf, 0xb7, 0x13, 0x08, 0x00,
+			0x0a, 0x35, 0xdc, 0x2b, 0x20, 0x8d, 0xa1, 0xb5,
+			0xce, 0x47, 0x8a, 0xc3, 0x80, 0xf4, 0x7d, 0x4a,
+			0xa2, 0x62, 0xfd, 0x61, 0x7f, 0xb5, 0xa8, 0xde,
+			0x0a, 0x17, 0x97, 0xa0, 0xbf, 0xdf, 0x56, 0x5a,
+			0x3d, 0x51, 0x56, 0x4f, 0x70, 0x70, 0x3f, 0x63,
+			0x6a, 0x44, 0x5b, 0xad, 0x84, 0x0d, 0x3f, 0x27,
+			0x6e, 0x3b, 0x34, 0x91, 0x60, 0x14, 0xb9, 0xaa,
+			0x72, 0xfd, 0xa3, 0x64, 0xd2, 0x03, 0xa7, 0x53,
+			0x87, 0x9e, 0x88, 0x0b, 0xc1, 0x14, 0x93, 0x1a,
+			0x62, 0xff, 0xb1, 0x5d, 0x74, 0xcd, 0x59, 0x63,
+			0x18, 0x11, 0x3d, 0x4f, 0xba, 0x75, 0xd4, 0x33,
+			0x4e, 0x23, 0x6b, 0x7b, 0x57, 0x44, 0xe1, 0xd3,
+			0x03, 0x13, 0xa6, 0xf0, 0x8b, 0x60, 0xb0, 0x9e,
+			0xee, 0x75, 0x08, 0x9d, 0x71, 0x63, 0x13, 0xcb,
+			0xa6, 0x81, 0x92, 0x14, 0x03, 0x22, 0x2d, 0xde,
+			0x55
+		},
+		.len = 129
 	}
+}
 };
-/* >8 End of MODEX vector. */
 
-struct rte_crypto_asym_xform modinv_xform = {
-	.next = NULL,
-	.xform_type = RTE_CRYPTO_ASYM_XFORM_MODINV,
-	.modinv = {
-		.modulus = {
-			.data = mod_p,
-			.length = sizeof(mod_p)
-		}
-	}
-};
+/* >8 End of MODEX vector. */
 
 static const struct
 modex_test_data modex_group_test_cases[] = {
-- 
2.25.1

