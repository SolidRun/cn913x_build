From 4ba0497c4afe2964b0ece2bc2f75bd63bf543afb Mon Sep 17 00:00:00 2001
From: Harman Kalra <hkalra@marvell.com>
Date: Thu, 14 Dec 2023 10:15:45 +0530
Subject: [PATCH 164/513] net/cnxk: ethernet statistic for representor

Adding representor ethernet statistics support which can fetch stats
for representees which are operating independently or part of
companian app.

Change-Id: I9af63aa10d01bb85bbe7a3686665bf4945760940
Signed-off-by: Harman Kalra <hkalra@marvell.com>
---
 drivers/net/cnxk/cnxk_rep_msg.h |   7 ++
 drivers/net/cnxk/cnxk_rep_ops.c | 140 +++++++++++++++++++++++++++++++-
 2 files changed, 143 insertions(+), 4 deletions(-)

diff --git a/drivers/net/cnxk/cnxk_rep_msg.h b/drivers/net/cnxk/cnxk_rep_msg.h
index 63cfbe3f19d43..277e25d92a62d 100644
--- a/drivers/net/cnxk/cnxk_rep_msg.h
+++ b/drivers/net/cnxk/cnxk_rep_msg.h
@@ -21,6 +21,8 @@ typedef enum CNXK_REP_MSG {
 	CNXK_REP_MSG_EXIT,
 	/* Ethernet operation msgs */
 	CNXK_REP_MSG_ETH_SET_MAC,
+	CNXK_REP_MSG_ETH_STATS_GET,
+	CNXK_REP_MSG_ETH_STATS_CLEAR,
 	/* End of messaging sequence */
 	CNXK_REP_MSG_END,
 } cnxk_rep_msg_t;
@@ -89,6 +91,11 @@ typedef struct cnxk_rep_msg_eth_mac_set_meta {
 	uint8_t addr_bytes[RTE_ETHER_ADDR_LEN];
 } __rte_packed cnxk_rep_msg_eth_set_mac_meta_t;
 
+/* Ethernet op - get/clear stats */
+typedef struct cnxk_rep_msg_eth_stats_meta {
+	uint16_t portid;
+} __rte_packed cnxk_rep_msg_eth_stats_meta_t;
+
 void cnxk_rep_msg_populate_command(void *buffer, uint32_t *length, cnxk_rep_msg_t type,
 				   uint32_t size);
 void cnxk_rep_msg_populate_command_meta(void *buffer, uint32_t *length, void *msg_meta, uint32_t sz,
diff --git a/drivers/net/cnxk/cnxk_rep_ops.c b/drivers/net/cnxk/cnxk_rep_ops.c
index 97643a50f24ea..124fc47b1e9e0 100644
--- a/drivers/net/cnxk/cnxk_rep_ops.c
+++ b/drivers/net/cnxk/cnxk_rep_ops.c
@@ -486,19 +486,151 @@ cnxk_rep_tx_queue_release(struct rte_eth_dev *ethdev, uint16_t queue_id)
 		plt_err("Failed to release txq %d, rc=%d", rc, txq->qid);
 }
 
+static int
+process_eth_stats(struct cnxk_rep_dev *rep_dev, cnxk_rep_msg_ack_data_t *adata, cnxk_rep_msg_t msg)
+{
+	cnxk_rep_msg_eth_stats_meta_t msg_st_meta;
+	uint32_t len = 0, rc;
+	void *buffer;
+	size_t size;
+
+	size = CNXK_REP_MSG_MAX_BUFFER_SZ;
+	buffer = plt_zmalloc(size, 0);
+	if (!buffer) {
+		plt_err("Failed to allocate mem");
+		rc = -ENOMEM;
+		goto fail;
+	}
+
+	cnxk_rep_msg_populate_header(buffer, &len);
+
+	msg_st_meta.portid = rep_dev->rep_id;
+	cnxk_rep_msg_populate_command_meta(buffer, &len, &msg_st_meta,
+					   sizeof(cnxk_rep_msg_eth_stats_meta_t), msg);
+	cnxk_rep_msg_populate_msg_end(buffer, &len);
+
+	rc = cnxk_rep_msg_send_process(rep_dev, buffer, len, adata);
+	if (rc) {
+		plt_err("Failed to process the message, err %d", rc);
+		goto fail;
+	}
+
+	rte_free(buffer);
+
+	return 0;
+fail:
+	rte_free(buffer);
+	return rc;
+}
+
+static int
+native_repte_eth_stats(struct cnxk_rep_dev *rep_dev, struct rte_eth_stats *stats)
+{
+	struct roc_nix_stats nix_stats;
+	int rc = 0;
+
+	rc = roc_eswitch_nix_repte_stats(&rep_dev->parent_dev->nix, rep_dev->hw_func, &nix_stats);
+	if (rc) {
+		plt_err("Failed to get stats for representee %x, err %d", rep_dev->hw_func, rc);
+		goto fail;
+	}
+
+	memset(stats, 0, sizeof(struct rte_eth_stats));
+	stats->opackets = nix_stats.tx_ucast;
+	stats->opackets += nix_stats.tx_mcast;
+	stats->opackets += nix_stats.tx_bcast;
+	stats->oerrors = nix_stats.tx_drop;
+	stats->obytes = nix_stats.tx_octs;
+
+	stats->ipackets = nix_stats.rx_ucast;
+	stats->ipackets += nix_stats.rx_mcast;
+	stats->ipackets += nix_stats.rx_bcast;
+	stats->imissed = nix_stats.rx_drop;
+	stats->ibytes = nix_stats.rx_octs;
+	stats->ierrors = nix_stats.rx_err;
+
+	return 0;
+fail:
+	return rc;
+}
+
 int
 cnxk_rep_stats_get(struct rte_eth_dev *ethdev, struct rte_eth_stats *stats)
 {
-	PLT_SET_USED(ethdev);
-	PLT_SET_USED(stats);
+	struct cnxk_rep_dev *rep_dev = cnxk_rep_pmd_priv(ethdev);
+	struct rte_eth_stats vf_stats;
+	cnxk_rep_msg_ack_data_t adata;
+	int rc;
+
+	/* If representor not representing any active VF, return 0 */
+	if (!rep_dev->is_vf_active)
+		return 0;
+
+	if (rep_dev->native_repte) {
+		/* For representees which are independent */
+		rc = native_repte_eth_stats(rep_dev, &vf_stats);
+		if (rc) {
+			plt_err("Failed to get stats for vf rep %x (hw_func %x), err %d",
+				rep_dev->port_id, rep_dev->hw_func, rc);
+			goto fail;
+		}
+	} else {
+		/* For representees which are part of companian app */
+		rc = process_eth_stats(rep_dev, &adata, CNXK_REP_MSG_ETH_STATS_GET);
+		if (rc || adata.u.sval < 0) {
+			if (adata.u.sval < 0)
+				rc = adata.u.sval;
+
+			plt_err("Failed to get stats for vf rep %x, err %d", rep_dev->port_id, rc);
+		}
+
+		if (adata.size != sizeof(struct rte_eth_stats)) {
+			rc = -EINVAL;
+			plt_err("Incomplete stats received for vf rep %d", rep_dev->port_id);
+			goto fail;
+		}
+
+		rte_memcpy(&vf_stats, adata.u.data, adata.size);
+	}
+
+	stats->q_ipackets[0] = vf_stats.ipackets;
+	stats->q_ibytes[0] = vf_stats.ibytes;
+	stats->ipackets = vf_stats.ipackets;
+	stats->ibytes = vf_stats.ibytes;
+
+	stats->q_opackets[0] = vf_stats.opackets;
+	stats->q_obytes[0] = vf_stats.obytes;
+	stats->opackets = vf_stats.opackets;
+	stats->obytes = vf_stats.obytes;
+
+	plt_rep_dbg("Input packets %ld stats->ipackets %ld Output %ld stats->opacket %ld",
+		    stats->q_ipackets[0], stats->ipackets, stats->q_opackets[0], stats->opackets);
+
 	return 0;
+fail:
+	return rc;
 }
 
 int
 cnxk_rep_stats_reset(struct rte_eth_dev *ethdev)
 {
-	PLT_SET_USED(ethdev);
-	return 0;
+	struct cnxk_rep_dev *rep_dev = cnxk_rep_pmd_priv(ethdev);
+	cnxk_rep_msg_ack_data_t adata;
+	int rc = 0;
+
+	/* If representor not representing any active VF, return 0 */
+	if (!rep_dev->is_vf_active)
+		return 0;
+
+	rc = process_eth_stats(rep_dev, &adata, CNXK_REP_MSG_ETH_STATS_CLEAR);
+	if (rc || adata.u.sval < 0) {
+		if (adata.u.sval < 0)
+			rc = adata.u.sval;
+
+		plt_err("Failed to clear stats for vf rep %x, err %d", rep_dev->port_id, rc);
+	}
+
+	return rc;
 }
 
 int
-- 
2.25.1

