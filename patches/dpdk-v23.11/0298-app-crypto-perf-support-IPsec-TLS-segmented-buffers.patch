From 2bcdbfb29ad63a4ba43567a9547849c1419eeb9d Mon Sep 17 00:00:00 2001
From: Akhil Goyal <gakhil@marvell.com>
Date: Tue, 26 Mar 2024 23:05:11 +0530
Subject: [PATCH 298/513] app/crypto-perf: support IPsec/TLS segmented buffers

Added support to allow segmented buffers for IPsec
and tls-record security offload cases.

Signed-off-by: Akhil Goyal <gakhil@marvell.com>
Change-Id: I4f6400f88e4ee8f80e696aafd4eddda8b2098540
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/dataplane/dpdk/+/124463
Base-Builds: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Base-Tests: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Tested-by: sa_ip-toolkits-Jenkins <sa_ip-toolkits-jenkins@marvell.com>
Reviewed-by: Jerin Jacob <jerinj@marvell.com>
---
 app/test-crypto-perf/cperf_ops.c | 55 ++++++++++++++++++++------------
 1 file changed, 34 insertions(+), 21 deletions(-)

diff --git a/app/test-crypto-perf/cperf_ops.c b/app/test-crypto-perf/cperf_ops.c
index d3fd115bc0ff5..4ca001b721a4b 100644
--- a/app/test-crypto-perf/cperf_ops.c
+++ b/app/test-crypto-perf/cperf_ops.c
@@ -43,10 +43,8 @@ test_ipsec_vec_populate(struct rte_mbuf *m, const struct cperf_options *options,
 	struct rte_ipv4_hdr *ip = rte_pktmbuf_mtod(m, struct rte_ipv4_hdr *);
 
 	if (options->is_outbound) {
-		memcpy(ip, test_vector->plaintext.data,
-		       sizeof(struct rte_ipv4_hdr));
-
-		ip->total_length = rte_cpu_to_be_16(m->data_len);
+		memcpy(ip, test_vector->plaintext.data, sizeof(struct rte_ipv4_hdr));
+		ip->total_length = rte_cpu_to_be_16(m->pkt_len);
 	}
 }
 
@@ -131,8 +129,6 @@ cperf_set_ops_security_ipsec(struct rte_crypto_op **ops,
 {
 	void *sec_sess = sess;
 	const uint32_t test_buffer_size = options->test_buffer_size;
-	const uint32_t headroom_sz = options->headroom_sz;
-	const uint32_t segment_sz = options->segment_sz;
 	uint64_t tsc_start_temp, tsc_end_temp;
 	uint16_t i = 0;
 
@@ -141,20 +137,27 @@ cperf_set_ops_security_ipsec(struct rte_crypto_op **ops,
 	for (i = 0; i < nb_ops; i++) {
 		struct rte_crypto_sym_op *sym_op = ops[i]->sym;
 		struct rte_mbuf *m = sym_op->m_src;
+		uint32_t offset = test_buffer_size;
 
 		ops[i]->status = RTE_CRYPTO_OP_STATUS_NOT_PROCESSED;
 		rte_security_attach_session(ops[i], sec_sess);
-		sym_op->m_src = (struct rte_mbuf *)((uint8_t *)ops[i] +
-							src_buf_offset);
+		sym_op->m_src = (struct rte_mbuf *)((uint8_t *)ops[i] + src_buf_offset);
+		sym_op->m_src->pkt_len = test_buffer_size;
 
-		/* In case of IPsec, headroom is consumed by PMD,
-		 * hence resetting it.
+		while ((m->next != NULL) && (offset >= m->data_len)) {
+			offset -= m->data_len;
+			m = m->next;
+		}
+		m->data_len = offset;
+		/*
+		 * If there is not enough room in segment,
+		 * place the digest in the next segment
 		 */
-		m->data_off = headroom_sz;
-
-		m->buf_len = segment_sz;
-		m->data_len = test_buffer_size;
-		m->pkt_len = test_buffer_size;
+		if (rte_pktmbuf_tailroom(m) < options->digest_sz) {
+			m = m->next;
+			offset = 0;
+		}
+		m->next = NULL;
 
 		sym_op->m_dst = NULL;
 	}
@@ -186,8 +189,6 @@ cperf_set_ops_security_tls(struct rte_crypto_op **ops,
 		uint64_t *tsc_start)
 {
 	const uint32_t test_buffer_size = options->test_buffer_size;
-	const uint32_t headroom_sz = options->headroom_sz;
-	const uint32_t segment_sz = options->segment_sz;
 	uint16_t i = 0;
 
 	RTE_SET_USED(imix_idx);
@@ -197,16 +198,28 @@ cperf_set_ops_security_tls(struct rte_crypto_op **ops,
 	for (i = 0; i < nb_ops; i++) {
 		struct rte_crypto_sym_op *sym_op = ops[i]->sym;
 		struct rte_mbuf *m = sym_op->m_src;
+		uint32_t offset = test_buffer_size;
 
 		ops[i]->status = RTE_CRYPTO_OP_STATUS_NOT_PROCESSED;
 		ops[i]->param1.tls_record.content_type = 0x17;
 		rte_security_attach_session(ops[i], sess);
 		sym_op->m_src = (struct rte_mbuf *)((uint8_t *)ops[i] + src_buf_offset);
+		sym_op->m_src->pkt_len = test_buffer_size;
 
-		m->data_off = headroom_sz;
-		m->buf_len = segment_sz;
-		m->data_len = test_buffer_size;
-		m->pkt_len = test_buffer_size;
+		while ((m->next != NULL) && (offset >= m->data_len)) {
+			offset -= m->data_len;
+			m = m->next;
+		}
+		m->data_len = offset;
+		/*
+		 * If there is not enough room in segment,
+		 * place the digest in the next segment
+		 */
+		if ((rte_pktmbuf_tailroom(m)) < options->digest_sz) {
+			m = m->next;
+			m->data_len = 0;
+		}
+		m->next = NULL;
 
 		sym_op->m_dst = NULL;
 	}
-- 
2.25.1

