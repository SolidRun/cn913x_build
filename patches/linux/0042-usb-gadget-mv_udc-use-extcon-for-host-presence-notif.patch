From 764a4d0a10c706bc9c2461d1f56b1d6aac9b8aec Mon Sep 17 00:00:00 2001
From: Josua Mayer <josua@solid-run.com>
Date: Sun, 19 May 2024 13:20:03 +0200
Subject: [PATCH 42/45] usb: gadget: mv_udc: use extcon for host presence
 notificationsover gpio

usb 2.0 and 3.0 controllers both require notifications for presence of
vbus (host). Rather than finding ways to share gpio, rely on extcon
notifications.

Signed-off-by: Josua Mayer <josua@solid-run.com>
---
 drivers/usb/gadget/udc/mv_udc.h      |  4 +-
 drivers/usb/gadget/udc/mv_udc_core.c | 71 +++++++++++++---------------
 2 files changed, 36 insertions(+), 39 deletions(-)

diff --git a/drivers/usb/gadget/udc/mv_udc.h b/drivers/usb/gadget/udc/mv_udc.h
index dda0414e25f3..21e3d5ecb5dd 100644
--- a/drivers/usb/gadget/udc/mv_udc.h
+++ b/drivers/usb/gadget/udc/mv_udc.h
@@ -217,8 +217,8 @@ struct mv_udc {
 				active:1,
 				stopped:1;      /* stop bit is setted */
 
-
-	int vbus_pin;
+	struct extcon_dev	*edev;
+	struct notifier_block	vbus_nb;
 	struct work_struct	vbus_work;
 	struct workqueue_struct *qwork;
 
diff --git a/drivers/usb/gadget/udc/mv_udc_core.c b/drivers/usb/gadget/udc/mv_udc_core.c
index e23babfee140..901bef27923e 100644
--- a/drivers/usb/gadget/udc/mv_udc_core.c
+++ b/drivers/usb/gadget/udc/mv_udc_core.c
@@ -35,10 +35,9 @@
 #include <linux/platform_device.h>
 #include <linux/clk.h>
 #include <linux/of.h>
-#include <linux/of_gpio.h>
 #include <linux/platform_data/mv_usb.h>
 #include <asm/unaligned.h>
-#include <linux/gpio.h>
+#include <linux/extcon.h>
 
 #include "mv_udc.h"
 
@@ -1375,9 +1374,6 @@ static int mv_udc_start(struct usb_gadget *gadget,
 	udc->ep0_state = WAIT_FOR_SETUP;
 	udc->ep0_dir = EP_DIR_OUT;
 
-	if (gpio_is_valid(udc->vbus_pin))
-		enable_irq(gpio_to_irq(udc->vbus_pin));
-
 	spin_unlock_irqrestore(&udc->lock, flags);
 
 	if (udc->transceiver) {
@@ -1405,9 +1401,6 @@ static int mv_udc_stop(struct usb_gadget *gadget)
 
 	udc = container_of(gadget, struct mv_udc, gadget);
 
-	if (gpio_is_valid(udc->vbus_pin))
-		disable_irq(gpio_to_irq(udc->vbus_pin));
-
 	spin_lock_irqsave(&udc->lock, flags);
 
 	mv_udc_enable(udc);
@@ -2096,6 +2089,18 @@ static irqreturn_t mv_udc_vbus_irq(int irq, void *dev)
 	return IRQ_HANDLED;
 }
 
+static int mv_udc_vbus_notifier(struct notifier_block *nb,
+	unsigned long event, void *ptr)
+{
+	struct mv_udc *udc = container_of(nb, struct mv_udc, vbus_nb);
+
+	/* TODO: can execute the work directly? */
+	if (udc->qwork)
+		queue_work(udc->qwork, &udc->vbus_work);
+
+	return NOTIFY_DONE;
+}
+
 static void mv_udc_vbus_work(struct work_struct *work)
 {
 	struct mv_udc *udc;
@@ -2104,8 +2109,8 @@ static void mv_udc_vbus_work(struct work_struct *work)
 	udc = container_of(work, struct mv_udc, vbus_work);
 	if (udc->pdata && udc->pdata->vbus)
 		vbus = udc->pdata->vbus->poll();
-	else if (gpio_is_valid(udc->vbus_pin))
-		vbus = gpio_get_value(udc->vbus_pin);
+	else if (!IS_ERR(udc->edev))
+		vbus = extcon_get_state(udc->edev, EXTCON_USB);
 	else
 		return;
 
@@ -2187,10 +2192,19 @@ static int mv_udc_probe(struct platform_device *pdev)
 		/* no phyregs for mvebu platform */
 		phyregs = NULL;
 
-		/* VBUS pin via GPIO */
-		udc->vbus_pin = of_get_named_gpio(pdev->dev.of_node, "vbus-gpio", 0);
-		if (udc->vbus_pin < 0)
-			udc->vbus_pin = -ENODEV;
+		/* use extcon for host detection */
+		udc->edev = extcon_get_edev_by_phandle(&pdev->dev, 0);
+		if (IS_ERR(udc->edev) && PTR_ERR(udc->edev) != -ENODEV) {
+			return PTR_ERR(udc->edev);
+		} else if (!IS_ERR(udc->edev)) {
+			udc->vbus_nb.notifier_call = mv_udc_vbus_notifier;
+			err = devm_extcon_register_notifier(&pdev->dev,
+							    udc->edev,
+							    EXTCON_USB,
+							    &udc->vbus_nb);
+			if (err < 0)
+				dev_err(&pdev->dev, "failed to register notifier for USB\n");
+		}
 
 		/* Get comphy and init if there is */
 		udc->utmi_phy = devm_of_phy_get(&pdev->dev, pdev->dev.of_node, "usb");
@@ -2228,8 +2242,8 @@ static int mv_udc_probe(struct platform_device *pdev)
 			return -ENODEV;
 		}
 
-		/* platform data registration doesn't use the VBUS GPIO subsystem */
-		udc->vbus_pin = -ENODEV;
+		/* platform data registration doesn't use the extcon subsystem */
+		udc->edev = ERR_PTR(-ENODEV);
 
 	} else {
 		dev_err(&pdev->dev, "missing platform_data or of_node\n");
@@ -2359,6 +2373,8 @@ static int mv_udc_probe(struct platform_device *pdev)
 	/* VBUS detect: we can disable/enable clock on demand.*/
 	if (udc->transceiver)
 		udc->clock_gating = 1;
+	else if (!IS_ERR(udc->edev))
+		udc->clock_gating = 1;
 	else if (pdata && pdata->vbus) {
 		udc->clock_gating = 1;
 		retval = devm_request_threaded_irq(&pdev->dev,
@@ -2370,29 +2386,10 @@ static int mv_udc_probe(struct platform_device *pdev)
 				"disable clock gating\n");
 			udc->clock_gating = 0;
 		}
-
-	} else if (gpio_is_valid(udc->vbus_pin)) {
-		udc->clock_gating = 1;
-		if (!devm_gpio_request(&pdev->dev, udc->vbus_pin, "mv-udc")) {
-			retval = devm_request_irq(&pdev->dev,
-					       gpio_to_irq(udc->vbus_pin),
-					       mv_udc_vbus_irq, IRQ_TYPE_EDGE_BOTH,
-					       "mv-udc", udc);
-			if (retval) {
-				udc->vbus_pin = -ENODEV;
-				dev_warn(&pdev->dev,
-					 "failed to request vbus irq; "
-					 "assuming always on\n");
-			} else
-				disable_irq(gpio_to_irq(udc->vbus_pin));
-		} else {
-			/* gpio_request fail so use -EINVAL for gpio_is_valid */
-			udc->vbus_pin = -EINVAL;
-		}
 	}
 
-	/* if using VBUS interrupt, initialize work queue */
-	if ((pdata && pdata->vbus) || gpio_is_valid(udc->vbus_pin)) {
+	/* if using VBUS interrupt / notifier, initialize work queue */
+	if ((pdata && pdata->vbus) || !IS_ERR(udc->edev)) {
 		udc->qwork = create_singlethread_workqueue("mv_udc_queue");
 		if (!udc->qwork) {
 			dev_err(&pdev->dev, "cannot create workqueue\n");
-- 
2.35.3

