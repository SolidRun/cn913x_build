From a3020f9cce4a5fbb7b12b62434534e9e62ec2e54 Mon Sep 17 00:00:00 2001
From: Lior Amsalem <alior@marvell.com>
Date: Thu, 4 Jun 2015 13:25:05 +0300
Subject: [PATCH 07/13] usb: gadget: mv_udc: add device tree support

- Add device tree support for mv_udc.
- Avoid phy_init & phy_deinit when platform data isn't initialized.
- General register renaming for more readable & shared code.

Change-Id: Iea2cbe9e7b5dca289520633f56ecc08b3998b81c
Signed-off-by: Lior Amsalem <alior@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/32804
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
---
 drivers/usb/gadget/udc/mv_udc_core.c | 120 ++++++++++++++++-----------
 1 file changed, 70 insertions(+), 50 deletions(-)

diff --git a/drivers/usb/gadget/udc/mv_udc_core.c b/drivers/usb/gadget/udc/mv_udc_core.c
index 4590bbbfda06..934ab4805b7d 100644
--- a/drivers/usb/gadget/udc/mv_udc_core.c
+++ b/drivers/usb/gadget/udc/mv_udc_core.c
@@ -34,6 +34,7 @@
 #include <linux/irq.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
+#include <linux/of.h>
 #include <linux/platform_data/mv_usb.h>
 #include <asm/unaligned.h>
 
@@ -1074,7 +1075,7 @@ static int mv_udc_enable_internal(struct mv_udc *udc)
 	if (retval)
 		return retval;
 
-	if (udc->pdata->phy_init) {
+	if (udc->pdata && udc->pdata->phy_init) {
 		retval = udc->pdata->phy_init(udc->phy_regs);
 		if (retval) {
 			dev_err(&udc->dev->dev,
@@ -1100,7 +1101,7 @@ static void mv_udc_disable_internal(struct mv_udc *udc)
 {
 	if (udc->active) {
 		dev_dbg(&udc->dev->dev, "disable udc\n");
-		if (udc->pdata->phy_deinit)
+		if (udc->pdata && udc->pdata->phy_deinit)
 			udc->pdata->phy_deinit(udc->phy_regs);
 		udc_clock_disable(udc);
 		udc->active = 0;
@@ -2115,69 +2116,80 @@ static int mv_udc_probe(struct platform_device *pdev)
 	struct mv_usb_platform_data *pdata = dev_get_platdata(&pdev->dev);
 	struct mv_udc *udc;
 	int retval = 0;
-	struct resource *r;
+	struct resource *capregs, *phyregs, *irq;
 	size_t size;
-
-	if (pdata == NULL) {
-		dev_err(&pdev->dev, "missing platform_data\n");
-		return -ENODEV;
-	}
+	struct clk *clk;
 
 	udc = devm_kzalloc(&pdev->dev, sizeof(*udc), GFP_KERNEL);
-	if (udc == NULL)
+	if (!udc)
 		return -ENOMEM;
 
-	udc->done = &release_done;
-	udc->pdata = dev_get_platdata(&pdev->dev);
-	spin_lock_init(&udc->lock);
-
-	udc->dev = pdev;
-
-	if (pdata->mode == MV_USB_MODE_OTG) {
-		udc->transceiver = devm_usb_get_phy(&pdev->dev,
-					USB_PHY_TYPE_USB2);
-		if (IS_ERR(udc->transceiver)) {
-			retval = PTR_ERR(udc->transceiver);
-
-			if (retval == -ENXIO)
-				return retval;
+	/* udc only have one sysclk. */
+	clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	if (pdev->dev.of_node) {
+		udc->pdata = NULL;
+
+		capregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		/* no phyregs for mvebu platform */
+		phyregs = NULL;
+
+	} else if (pdata) {
+		udc->pdata = pdev->dev.platform_data;
+		if (pdata->mode == MV_USB_MODE_OTG) {
+			udc->transceiver = devm_usb_get_phy(&pdev->dev,
+							    USB_PHY_TYPE_USB2);
+			if (IS_ERR(udc->transceiver)) {
+				retval = PTR_ERR(udc->transceiver);
+				if (retval == -ENXIO)
+					return retval;
+
+				udc->transceiver = NULL;
+				return -EPROBE_DEFER;
+			}
+		}
 
-			udc->transceiver = NULL;
-			return -EPROBE_DEFER;
+		capregs = platform_get_resource_byname(pdev, IORESOURCE_MEM, "capregs");
+		phyregs = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phyregs");
+		if (!phyregs) {
+			dev_err(&pdev->dev, "no phy I/O memory resource defined\n");
+			return -ENODEV;
 		}
+
+	} else {
+		dev_err(&pdev->dev, "missing platform_data or of_node\n");
+		return -ENODEV;
 	}
 
-	/* udc only have one sysclk. */
-	udc->clk = devm_clk_get(&pdev->dev, NULL);
-	if (IS_ERR(udc->clk))
-		return PTR_ERR(udc->clk);
+	/* set udc struct*/
+	udc->done = &release_done;
+	udc->clk = clk;
+	udc->dev = pdev;
+	spin_lock_init(&udc->lock);
 
-	r = platform_get_resource_byname(udc->dev, IORESOURCE_MEM, "capregs");
-	if (r == NULL) {
-		dev_err(&pdev->dev, "no I/O memory resource defined\n");
-		return -ENODEV;
+	if (!capregs) {
+		dev_err(&pdev->dev, "no capregs I/O memory resource defined\n");
+		return -ENXIO;
 	}
 
 	udc->cap_regs = (struct mv_cap_regs __iomem *)
-		devm_ioremap(&pdev->dev, r->start, resource_size(r));
-	if (udc->cap_regs == NULL) {
+		devm_ioremap(&pdev->dev, capregs->start, resource_size(capregs));
+	if (!udc->cap_regs) {
 		dev_err(&pdev->dev, "failed to map I/O memory\n");
 		return -EBUSY;
 	}
 
-	r = platform_get_resource_byname(udc->dev, IORESOURCE_MEM, "phyregs");
-	if (r == NULL) {
-		dev_err(&pdev->dev, "no phy I/O memory resource defined\n");
-		return -ENODEV;
-	}
-
-	udc->phy_regs = devm_ioremap(&pdev->dev, r->start, resource_size(r));
-	if (udc->phy_regs == NULL) {
-		dev_err(&pdev->dev, "failed to map phy I/O memory\n");
-		return -EBUSY;
+	if (phyregs) {
+		udc->phy_regs = ioremap(phyregs->start, resource_size(capregs));
+		if (!udc->phy_regs) {
+			dev_err(&pdev->dev, "failed to map phy I/O memory\n");
+			return -EBUSY;
+		}
 	}
 
-	/* we will acces controller register, so enable the clk */
+	/* we will access controller register, so enable the clk */
 	retval = mv_udc_enable_internal(udc);
 	if (retval)
 		return retval;
@@ -2244,13 +2256,14 @@ static int mv_udc_probe(struct platform_device *pdev)
 	udc->ep0_dir = EP_DIR_OUT;
 	udc->remote_wakeup = 0;
 
-	r = platform_get_resource(udc->dev, IORESOURCE_IRQ, 0);
-	if (r == NULL) {
+	/* request irq */
+	irq = platform_get_resource(udc->dev, IORESOURCE_IRQ, 0);
+	if (irq == NULL) {
 		dev_err(&pdev->dev, "no IRQ resource defined\n");
 		retval = -ENODEV;
 		goto err_destroy_dma;
 	}
-	udc->irq = r->start;
+	udc->irq = irq->start;
 	if (devm_request_irq(&pdev->dev, udc->irq, mv_udc_irq,
 		IRQF_SHARED, driver_name, udc)) {
 		dev_err(&pdev->dev, "Request irq %d for UDC failed\n",
@@ -2274,7 +2287,7 @@ static int mv_udc_probe(struct platform_device *pdev)
 	/* VBUS detect: we can disable/enable clock on demand.*/
 	if (udc->transceiver)
 		udc->clock_gating = 1;
-	else if (pdata->vbus) {
+	else if (pdata && pdata->vbus) {
 		udc->clock_gating = 1;
 		retval = devm_request_threaded_irq(&pdev->dev,
 				pdata->vbus->irq, NULL,
@@ -2412,12 +2425,19 @@ static void mv_udc_shutdown(struct platform_device *pdev)
 	mv_udc_disable(udc);
 }
 
+static const struct of_device_id mv_udc_dt_match[] = {
+	{ .compatible = "marvell,mv-udc" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, mv_udc_dt_match);
+
 static struct platform_driver udc_driver = {
 	.probe		= mv_udc_probe,
 	.remove		= mv_udc_remove,
 	.shutdown	= mv_udc_shutdown,
 	.driver		= {
 		.name	= "mv-udc",
+		.of_match_table = of_match_ptr(mv_udc_dt_match),
 #ifdef CONFIG_PM
 		.pm	= &mv_udc_pm_ops,
 #endif
-- 
2.35.3

