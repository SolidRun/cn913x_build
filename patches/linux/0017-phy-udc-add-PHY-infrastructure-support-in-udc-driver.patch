From c01cb9b293b7e5eb976262234ce23cbb5d47107d Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Wed, 18 Jan 2017 00:23:06 +0800
Subject: [PATCH 17/45] phy: udc: add PHY infrastructure support in udc driver

The patch added call for PHY init if exists via calling API
(phy_init, phy_power_on, etc.)
The main purposes to support phy infrastructure are:
  - Initialize udc PHY without bootloader dependency
  - power on/off in case doing suspend/resume

Change-Id: Ibe2b782330c6a9ab7f9cc05deaa940595d0c6695
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/37078
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
---
 .../devicetree/bindings/usb/marvell-udc.txt   | 32 +++++++++++++++++++
 drivers/usb/gadget/udc/mv_udc.h               |  2 ++
 drivers/usb/gadget/udc/mv_udc_core.c          | 26 +++++++++++++++
 3 files changed, 60 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/usb/marvell-udc.txt

diff --git a/Documentation/devicetree/bindings/usb/marvell-udc.txt b/Documentation/devicetree/bindings/usb/marvell-udc.txt
new file mode 100644
index 000000000000..6157471c5717
--- /dev/null
+++ b/Documentation/devicetree/bindings/usb/marvell-udc.txt
@@ -0,0 +1,32 @@
+Marvell USB2 device controller
+
+This controller is integrated in Armada 38x/3700/8K.
+
+Required properties:
+- compatible	: Must be "marvell,mv-udc"
+- reg		: Physical base address and size of the USB2 device registers map.
+- interrupts	: Should contain single irq line of USB2 device controller
+- clocks	: the clock associated to this controller
+- dma-coherent	: if controller is DMA coherent
+
+Optional properties :
+- vbus-gpio	: VBUS interrupt GPIO pin
+		  set to trigger VBUS event notification to PHY/controller
+		  whether VBUS was powered or not
+- phys		: the UTMI PHY associated to this controller
+- phy-names	: the name of UTMI PHY indicated by above property
+
+Example:
+	udc@524100 {
+		compatible = "marvell,mv-udc";
+		reg = <0x524100 0x2000>;
+		interrupts = <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&gateclk 24>, <&gateclk 16>;
+ 		dma-coherent;
+		vbus-gpio = <&gpio1 19 GPIO_ACTIVE_HIGH>;
+		phys = <&utmi_usb32>;
+		phy-names = "usb";
+		status = "disabled";
+	};
+
+
diff --git a/drivers/usb/gadget/udc/mv_udc.h b/drivers/usb/gadget/udc/mv_udc.h
index 3b2ed5a3f83d..dda0414e25f3 100644
--- a/drivers/usb/gadget/udc/mv_udc.h
+++ b/drivers/usb/gadget/udc/mv_udc.h
@@ -197,6 +197,8 @@ struct mv_udc {
 	struct mv_req			*status_req;
 	struct usb_ctrlrequest		local_setup_buff;
 
+	struct phy			*utmi_phy;
+
 	unsigned int		resume_state;	/* USB state to resume */
 	unsigned int		usb_state;	/* USB current state */
 	unsigned int		ep0_state;	/* Endpoint zero state */
diff --git a/drivers/usb/gadget/udc/mv_udc_core.c b/drivers/usb/gadget/udc/mv_udc_core.c
index def2d526f33c..a7b9c06a50cc 100644
--- a/drivers/usb/gadget/udc/mv_udc_core.c
+++ b/drivers/usb/gadget/udc/mv_udc_core.c
@@ -2152,6 +2152,12 @@ static int mv_udc_remove(struct platform_device *pdev)
 	/* free dev, wait for the release() finished */
 	wait_for_completion(udc->done);
 
+	/* Power off PHY and exit */
+	if (udc->utmi_phy) {
+		phy_power_off(udc->utmi_phy);
+		phy_exit(udc->utmi_phy);
+	}
+
 	return 0;
 }
 
@@ -2163,6 +2169,7 @@ static int mv_udc_probe(struct platform_device *pdev)
 	struct resource *capregs, *phyregs, *irq;
 	size_t size;
 	struct clk *clk;
+	int err;
 
 	udc = devm_kzalloc(&pdev->dev, sizeof(*udc), GFP_KERNEL);
 	if (!udc)
@@ -2185,6 +2192,20 @@ static int mv_udc_probe(struct platform_device *pdev)
 		if (udc->vbus_pin < 0)
 			udc->vbus_pin = -ENODEV;
 
+		/* Get comphy and init if there is */
+		udc->utmi_phy = devm_of_phy_get(&pdev->dev, pdev->dev.of_node, "usb");
+		if (!IS_ERR(udc->utmi_phy)) {
+			err = phy_init(udc->utmi_phy);
+			if (err)
+				goto disable_phys;
+
+			err = phy_power_on(udc->utmi_phy);
+			if (err) {
+				phy_exit(udc->utmi_phy);
+				goto disable_phys;
+			}
+		}
+
 	} else if (pdata) {
 		udc->pdata = pdev->dev.platform_data;
 		if (pdata->mode == MV_USB_MODE_OTG) {
@@ -2414,6 +2435,11 @@ static int mv_udc_probe(struct platform_device *pdev)
 			udc->ep_dqh, udc->ep_dqh_dma);
 err_disable_clock:
 	mv_udc_disable_internal(udc);
+disable_phys:
+	if (udc->utmi_phy) {
+		phy_power_off(udc->utmi_phy);
+		phy_exit(udc->utmi_phy);
+	}
 
 	return retval;
 }
-- 
2.35.3

