From 3364228a15366b4fb9763d41887e3af620747c0c Mon Sep 17 00:00:00 2001
From: Victor Gu <xigu@marvell.com>
Date: Thu, 13 Apr 2017 20:27:09 +0800
Subject: [PATCH 27/45] fix: usb: gadget: u3d: send EP ready until mass storage
 thread is ready

During system suspend to RAM, the kernel modules will be resumed at
first then re-start all the kernel threads, which leads to issue for
USB3 device mode. The USB3 device driver will start negotiate with host
when mass storage thread is not resumed, which leads to failure and
finally the host will set EP to suspend state, thus the USB3 device
can not work even after the mass storage thread is resumed.
This patch modify the u3d driver that do not send state ready to host
when the function report USB_GADGET_DELAYED_STATUS state, which is used
to delay the data/status stages of the control transfer till function
are ready.
In routine mvc2_handle_setup(), the USB_GADGET_DELAYED_STATUS will be
checked so that do not continue the transfer if it is set.
After the kernel USB mass storage thread is resumed, it will handle
the setup, then send the request to notify lower layer that the delayed
status is cleared by set the request packet length to 0.
In Marvell USB3 device driver, once it receives the request whose length
is 0, it knows the delay status is cleared, then it will notify the host
that EP is ready(by calling mvc2_send_erdy) to continue the transfer.
JIRA ID: A3700-858 USB3 device do not resume when working with SATA disk
connected.

Change-Id: If3bb547c5ff7f8563ba002db7478a6d46bf961f3
Signed-off-by: Victor Gu <xigu@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/38669
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
---
 drivers/usb/gadget/udc/mvebu_u3d.c | 47 +++++++++++++++++++++++-------
 1 file changed, 36 insertions(+), 11 deletions(-)

diff --git a/drivers/usb/gadget/udc/mvebu_u3d.c b/drivers/usb/gadget/udc/mvebu_u3d.c
index d727b2c48ca8..f49e8145135c 100644
--- a/drivers/usb/gadget/udc/mvebu_u3d.c
+++ b/drivers/usb/gadget/udc/mvebu_u3d.c
@@ -43,6 +43,7 @@
 #include <linux/of_gpio.h>
 #include <linux/gpio.h>
 #include <linux/phy/phy.h>
+#include <linux/usb/composite.h>
 
 #include "mvebu_u3d.h"
 
@@ -935,6 +936,13 @@ static int mvc2_ep_disable(struct usb_ep *_ep)
 	return 0;
 }
 
+static inline void mvc2_send_erdy(struct mvc2 *cp)
+{
+	/* ep0 erdy should be smp safe, and no lock is needed */
+	MV_CP_WRITE(MV_CP_READ(MVCP_ENDPOINT_0_CONFIG) |
+		    MVCP_ENDPOINT_0_CONFIG_CHG_STATE, MVCP_ENDPOINT_0_CONFIG);
+}
+
 #ifndef ASSEMBLE_REQ
 /* queues (submits) an I/O request to an endpoint */
 static int
@@ -953,8 +961,18 @@ mvc2_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 	num = _ep->desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
 	/* Reset the endpoint 0 to prevent previous left data */
 	if (num == 0) {
-		if (!req->req.length)
+		/*
+		 * After USB_GADGET_DELAYED_STATUS is set and the USB upper layer in USB function thread
+		 * finishes the handling, the USB compsite layer will send request to continue with the
+		 * control transfer, within this request, the request length is set 0.
+		 * Since the request length will not be 0 for normal transfer, once it is 0, it means
+		 * that to continue the transfer after USB_GADGET_DELAYED_STATUS. Thus the erdy is set
+		 * here to notify the host that device is ready for latter transfer.
+		 */
+		if (!req->req.length) {
+			mvc2_send_erdy(cp);
 			return 0;
+		}
 
 		if (cp->ep0_dir == USB_DIR_IN)
 			ep = &cp->eps[1];
@@ -1013,8 +1031,18 @@ mvc2_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 	num = _ep->desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
 	/* Reset the endpoint 0 to prevent previous left data */
 	if (num == 0) {
-		if (!req->req.length)
+		/*
+		 * After USB_GADGET_DELAYED_STATUS is set and the USB upper layer in USB function thread
+		 * finishes the handling, the USB compsite layer will send request to continue with the
+		 * control transfer. Within this request, the request length is set 0.
+		 * Since the request length will not be 0 for normal transfer, once it is 0, it means
+		 * that to continue the transfer after USB_GADGET_DELAYED_STATUS. Thus the erdy is set
+		 * here to notify the host that device is ready for latter transfer.
+		 */
+		if (!req->req.length) {
+			mvc2_send_erdy(cp);
 			return 0;
+		}
 
 		if (cp->ep0_dir == USB_DIR_IN)
 			ep = &cp->eps[1];
@@ -1298,13 +1326,6 @@ static void stop_activity(struct mvc2 *udc, struct usb_gadget_driver *driver)
 		driver->disconnect(&udc->gadget);
 }
 
-static inline void mvc2_send_erdy(struct mvc2 *cp)
-{
-	/* ep0 erdy should be smp safe, and no lock is needed */
-	MV_CP_WRITE(MV_CP_READ(MVCP_ENDPOINT_0_CONFIG) |
-		    MVCP_ENDPOINT_0_CONFIG_CHG_STATE, MVCP_ENDPOINT_0_CONFIG);
-}
-
 static void mvc2_init_interrupt(struct mvc2 *cp)
 {
 	int i;
@@ -1633,9 +1654,13 @@ void mvc2_handle_setup(struct mvc2 *cp)
 		ep_set_halt(cp, 0, 0, 1);
 	/*
 	 * If current setup has no data pharse or failed, we would directly
-	 * jump to status pharse
+	 * jump to status pharse.
+	 * If the USB_GADGET_DELAYED_STATUS is set, the USB interface requests
+	 * delay for it to handle the setup, thus here should not send erdy to
+	 * continue the transfer. Instead, the erdy will be sent from mvc2_ep_queue,
+	 * once a request with length 0 is issued.
 	 */
-	if (r->wLength == 0 || ret < 0)
+	 if ((ret < 0) || (r->wLength == 0 && ret != USB_GADGET_DELAYED_STATUS))
 		mvc2_send_erdy(cp);
 }
 
-- 
2.35.3

