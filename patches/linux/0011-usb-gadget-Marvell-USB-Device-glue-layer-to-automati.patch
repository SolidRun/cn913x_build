From 0fd9a070c1d7c2276764c99f274a5390513369dc Mon Sep 17 00:00:00 2001
From: Lior Amsalem <alior@marvell.com>
Date: Thu, 11 Jun 2015 19:00:57 +0300
Subject: [PATCH 11/45] usb: gadget: Marvell USB Device glue layer to
 automatically switch USB2.0 and USB3.0

This patch introduce a layer to control the load and unload
of the Marvell USB2.0 driver and USB3.0 driver in USB device mode
for Marvell Armada 38x/3700/8K platforms.

Change-Id: I1a47c382d369352986a76b78728866b56890406a
Signed-off-by: Lior Amsalem <alior@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/32809
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
---
 drivers/usb/gadget/udc/Makefile      |   2 +-
 drivers/usb/gadget/udc/core.c        |  28 +---
 drivers/usb/gadget/udc/mv_udc_core.c |  34 ++++-
 drivers/usb/gadget/udc/mvebu_glue.c  | 189 +++++++++++++++++++++++++++
 drivers/usb/gadget/udc/mvebu_u3d.c   |   9 +-
 drivers/usb/gadget/udc/mvebu_u3d.h   |  21 +++
 include/linux/usb/gadget.h           |  20 +++
 7 files changed, 274 insertions(+), 29 deletions(-)
 create mode 100644 drivers/usb/gadget/udc/mvebu_glue.c

diff --git a/drivers/usb/gadget/udc/Makefile b/drivers/usb/gadget/udc/Makefile
index ab7efda68f05..71388c6266fd 100644
--- a/drivers/usb/gadget/udc/Makefile
+++ b/drivers/usb/gadget/udc/Makefile
@@ -36,7 +36,7 @@ mv_udc-y			:= mv_udc_core.o
 obj-$(CONFIG_USB_FUSB300)	+= fusb300_udc.o
 obj-$(CONFIG_USB_FOTG210_UDC)	+= fotg210-udc.o
 obj-$(CONFIG_USB_MV_U3D)	+= mv_u3d_core.o
-obj-$(CONFIG_USB_MVEBU_U3D)	+= mvebu_u3d.o
+obj-$(CONFIG_USB_MVEBU_U3D)	+= mvebu_glue.o mvebu_u3d.o
 obj-$(CONFIG_USB_GR_UDC)	+= gr_udc.o
 obj-$(CONFIG_USB_GADGET_XILINX)	+= udc-xilinx.o
 obj-$(CONFIG_USB_SNP_UDC_PLAT) += snps_udc_plat.o
diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index cc6a6a680aca..1369e76c9cbc 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -33,26 +33,6 @@
 
 #include "trace.h"
 
-/**
- * struct usb_udc - describes one usb device controller
- * @driver - the gadget driver pointer. For use by the class code
- * @dev - the child device to the actual controller
- * @gadget - the gadget. For use by the class code
- * @list - for use by the udc class driver
- * @vbus - for udcs who care about vbus status, this value is real vbus status;
- * for udcs who do not care about vbus status, this value is always true
- *
- * This represents the internal data structure which is used by the UDC-class
- * to hold information about udc driver and gadget together.
- */
-struct usb_udc {
-	struct usb_gadget_driver	*driver;
-	struct usb_gadget		*gadget;
-	struct device			dev;
-	struct list_head		list;
-	bool				vbus;
-};
-
 static struct class *udc_class;
 static LIST_HEAD(udc_list);
 static LIST_HEAD(gadget_driver_pending_list);
@@ -1383,11 +1363,9 @@ int usb_gadget_probe_driver(struct usb_gadget_driver *driver)
 		else
 			goto found;
 	} else {
-		list_for_each_entry(udc, &udc_list, list) {
-			/* For now we take the first one */
-			if (!udc->driver)
-				goto found;
-		}
+		udc = udc_detect(&udc_list, driver);
+		if (udc)
+			goto found;
 	}
 
 	if (!driver->match_existing_only) {
diff --git a/drivers/usb/gadget/udc/mv_udc_core.c b/drivers/usb/gadget/udc/mv_udc_core.c
index e4beee0ae505..b416226386af 100644
--- a/drivers/usb/gadget/udc/mv_udc_core.c
+++ b/drivers/usb/gadget/udc/mv_udc_core.c
@@ -2010,6 +2010,32 @@ static void irq_process_error(struct mv_udc *udc)
 	udc->errors++;
 }
 
+static ATOMIC_NOTIFIER_HEAD(mv_udc_status_list);
+
+int mv_udc_register_status_notify(struct notifier_block *nb)
+{
+	int ret = 0;
+
+	ret = atomic_notifier_chain_register(&mv_udc_status_list, nb);
+	if (ret)
+		return ret;
+
+	return 0;
+
+}
+EXPORT_SYMBOL(mv_udc_register_status_notify);
+
+int mv_udc_unregister_status_notify(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_unregister(&mv_udc_status_list, nb);
+}
+EXPORT_SYMBOL(mv_udc_unregister_status_notify);
+
+static void status_change(struct mv_udc *udc, int event)
+{
+	atomic_notifier_call_chain(&mv_udc_status_list, event, NULL);
+}
+
 static irqreturn_t mv_udc_irq(int irq, void *dev)
 {
 	struct mv_udc *udc = (struct mv_udc *)dev;
@@ -2037,8 +2063,10 @@ static irqreturn_t mv_udc_irq(int irq, void *dev)
 	if (status & USBSTS_ERR)
 		irq_process_error(udc);
 
-	if (status & USBSTS_RESET)
+	if (status & USBSTS_RESET) {
 		irq_process_reset(udc);
+		status_change(udc, 1);
+	}
 
 	if (status & USBSTS_PORT_CHANGE)
 		irq_process_port_change(udc);
@@ -2046,8 +2074,10 @@ static irqreturn_t mv_udc_irq(int irq, void *dev)
 	if (status & USBSTS_INT)
 		irq_process_tr_complete(udc);
 
-	if (status & USBSTS_SUSPEND)
+	if (status & USBSTS_SUSPEND) {
 		irq_process_suspend(udc);
+		status_change(udc, 1);
+	}
 
 	spin_unlock(&udc->lock);
 
diff --git a/drivers/usb/gadget/udc/mvebu_glue.c b/drivers/usb/gadget/udc/mvebu_glue.c
new file mode 100644
index 000000000000..46262efdb2de
--- /dev/null
+++ b/drivers/usb/gadget/udc/mvebu_glue.c
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2013 Marvell International Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/usb/gadget.h>
+#include <linux/pm.h>
+#include <linux/pm_qos.h>
+#include <linux/usb/composite.h>
+
+#include "mvebu_u3d.h"
+
+#define CONNECTION_MAX_NUM    3
+
+struct mvc2_glue glue;
+static struct work_struct glue_work;
+static DEFINE_MUTEX(work_lock);
+struct usb_udc *udc_detect(struct list_head *udc_list,
+			   struct usb_gadget_driver *driver)
+{
+	struct usb_udc *udc20, *udc30, *udc;
+	struct mvc2 *cp;
+
+	udc20 = udc30 = NULL;
+	list_for_each_entry(udc, udc_list, list) {
+		if (strncmp(udc->gadget->name, "mv_udc", 6) == 0)
+			udc20 = udc;
+
+		if (strncmp(udc->gadget->name, "mvebu-u3d", 9) == 0)
+			udc30 = udc;
+	}
+
+	/* We need at least 3.0 controller driver being installed! */
+	if (!udc30) {
+		pr_err("Failed to detect usb3 device!\n");
+		return NULL;
+	}
+
+	cp = container_of(udc30->gadget, struct mvc2, gadget);
+	cp->work = &glue_work;
+	glue.u20 = udc20;
+	glue.u30 = udc30;
+
+	if (glue.usb2_connect)
+		return udc20;
+	else
+		return udc30;
+}
+
+void mvc2_usb2_connect(void)
+{
+	struct mvc2 *cp;
+	struct usb_udc *u30 = glue.u30;
+	struct usb_gadget_driver *driver = u30->driver;
+	struct usb_gadget *u3d = u30->gadget;
+
+	cp = container_of(u3d, struct mvc2, gadget);
+	pr_info("USB device: USB2.0 connected\n");
+	/*
+	 * add de-bounce for usb cable plug
+	 */
+	msleep(200);
+	if (mvc2_checkvbus(cp) == 0) {
+		pr_info("USB device: power off\n");
+		return;
+	}
+
+	/*
+	 * The de-bounce time added before just can filter
+	 * most cases but not all.
+	 * The power off interrupt still has chance to break
+	 * this workqueue.
+	 * So we disable the USB3 irq here to guarantee this
+	 * workqueue will not be interrupted by USB3 interrupt anymore,
+	 * such as the power off interrupt, until all of the works have
+	 * been done.
+	 * The power off interrupt may happen when
+	 * the USB3 irq was disabled.
+	 * We hope this interrupt still there once
+	 * we enabled USB3 irq again.
+	 * To achieve this, need to keep the corresponding
+	 * interrupt status(refer to mvc2_pullup,
+	 * don't clear the ref int status register).
+	 * Note, during the USB3 irq disabled, there may be
+	 * may times plug/unplug, thus, the power on/off interrupt
+	 * may co-exisit once enable the irq again.
+	 * To avoid this, we need to check the VBUS of the final state,
+	 * please refer to mvc2_irq.
+	 */
+
+	disable_irq(cp->irq);
+
+	glue.usb2_connect = 1;
+	usb_gadget_unregister_driver(driver);
+	usb_gadget_probe_driver(driver);
+
+	enable_irq(cp->irq);
+
+}
+
+void mvc2_usb2_disconnect(void)
+{
+	struct mvc2 *cp;
+	struct usb_udc *u30 = glue.u30;
+	struct usb_gadget *u3d = u30->gadget;
+	struct usb_udc *u20 = glue.u20;
+	struct usb_gadget_driver *driver = u20->driver;
+	int has_setup = 0;
+
+	cp = container_of(u3d, struct mvc2, gadget);
+
+	if (u20->driver)
+		driver = u20->driver;
+	else if (u30->driver) {
+		driver = u30->driver;
+		return;
+	}
+
+	pr_info("USB device: USB2.0 disconnected\n");
+	glue.usb2_connect = 0;
+	usb_gadget_unregister_driver(driver);
+	disable_irq(cp->irq);
+	usb3_disconnect = false;
+
+	if (ioread32(cp->base + MVCP_SS_CORE_INT) & MVCP_SS_CORE_INT_SETUP)
+		has_setup = 1;
+	usb_gadget_probe_driver(driver);
+	usb3_disconnect = true;
+	enable_irq(cp->irq);
+	if (has_setup)
+		mvc2_handle_setup(cp);
+
+}
+
+static int
+u20_status_change(struct notifier_block *this, unsigned long event, void *ptr)
+{
+	struct mvc2 *cp;
+	struct usb_gadget *u30 = glue.u30->gadget;
+
+	cp = container_of(u30, struct mvc2, gadget);
+
+	mvc2_usb2_operation(cp, event);
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block u20_status = {
+	.notifier_call = u20_status_change,
+};
+
+void mv_connect_work(struct work_struct *work)
+{
+	struct mvc2 *cp;
+	struct usb_gadget *u30 = glue.u30->gadget;
+
+	cp = container_of(u30, struct mvc2, gadget);
+
+	mutex_lock(&work_lock);
+
+	if (glue.status & MVCP_STATUS_USB2)
+		mvc2_usb2_connect();
+	else
+		mvc2_usb2_disconnect();
+
+	mutex_unlock(&work_lock);
+}
+
+static int __init mvc2_glue_init(void)
+{
+	glue.u20 = glue.u30 = NULL;
+	glue.usb2_connect = 0;
+	mv_udc_register_status_notify(&u20_status);
+	INIT_WORK(&glue_work, mv_connect_work);
+	return 0;
+}
+
+device_initcall(mvc2_glue_init);
diff --git a/drivers/usb/gadget/udc/mvebu_u3d.c b/drivers/usb/gadget/udc/mvebu_u3d.c
index 6ca88831e711..263563873776 100644
--- a/drivers/usb/gadget/udc/mvebu_u3d.c
+++ b/drivers/usb/gadget/udc/mvebu_u3d.c
@@ -1959,6 +1959,8 @@ static irqreturn_t mvc2_irq(int irq, void *devid)
 				cp->gadget.speed = USB_SPEED_UNKNOWN;
 
 				cp->status &= ~MVCP_STATUS_USB2;
+				glue.status = cp->status;
+				schedule_work(cp->work);
 			}
 		}
 
@@ -1980,14 +1982,19 @@ static irqreturn_t mvc2_irq(int irq, void *devid)
 			stop_activity(cp, cp->driver);
 
 			cp->status |= MVCP_STATUS_USB2;
+			glue.status = cp->status;
+			schedule_work(cp->work);
 		}
 
 		if ((refint & MVCP_REF_INTEN_USB2_DISCNT) &&
 		    (MV_CP_READ(cp->reg->ref_inten) &
 		     MVCP_REF_INTEN_USB2_DISCNT)) {
 			usb3_disconnect = true;
-			if (mvc2_checkvbus(cp))
+			if (mvc2_checkvbus(cp)) {
 				cp->status &= ~MVCP_STATUS_USB2;
+				glue.status = cp->status;
+				schedule_work(cp->work);
+			}
 		}
 
 		if (refint & MVCP_REF_INTEN_RESUME)
diff --git a/drivers/usb/gadget/udc/mvebu_u3d.h b/drivers/usb/gadget/udc/mvebu_u3d.h
index d614393d056e..b83685def6a2 100644
--- a/drivers/usb/gadget/udc/mvebu_u3d.h
+++ b/drivers/usb/gadget/udc/mvebu_u3d.h
@@ -544,5 +544,26 @@ static inline unsigned int lfps_signal(struct mvc2 *cp, unsigned int n)
 	return cp->reg->lfps_signal + ((n - 1) << 2);
 }
 
+/*
+ * struct mvc2_glue - glue structure to combine 2.0/3.0 udc together
+ * @u20: 2.0 driver udc
+ * @u30: 3.0 driver udc
+ * @usb2_connect: whether usb2.0 is in connection
+ * @connect_num: how many usb3 has been tried
+ */
+struct mvc2_glue {
+	struct usb_udc  *u20;
+	struct usb_udc  *u30;
+
+	int usb2_connect;
+	unsigned int status;
+};
+
+extern struct mvc2_glue glue;
+extern bool usb3_disconnect;
+
+int mvc2_checkvbus(struct mvc2 *cp);
+void mvc2_handle_setup(struct mvc2 *cp);
+int mv_udc_register_status_notify(struct notifier_block *nb);
 
 #endif
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index d3badbbbda97..75431651ab9f 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -864,4 +864,24 @@ extern void usb_ep_autoconfig_release(struct usb_ep *);
 
 extern void usb_ep_autoconfig_reset(struct usb_gadget *);
 
+/**
+ * struct usb_udc - describes one usb device controller
+ * @driver - the gadget driver pointer. For use by the class code
+ * @dev - the child device to the actual controller
+ * @gadget - the gadget. For use by the class code
+ * @list - for use by the udc class driver
+ *
+ * This represents the internal data structure which is used by the UDC-class
+ * to hold information about udc driver and gadget together.
+ */
+struct usb_udc {
+	struct usb_gadget_driver	*driver;
+	struct usb_gadget		*gadget;
+	struct device			dev;
+	struct list_head		list;
+	bool				vbus;
+};
+
+extern struct usb_udc *udc_detect(struct list_head *udc_list, struct usb_gadget_driver *driver);
+
 #endif /* __LINUX_USB_GADGET_H */
-- 
2.35.3

